diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/def.h b/drivers/net/wireless/rtlwifi/rtl8192cu/def.h
index c940a87..24db198 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/def.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/def.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -32,24 +39,24 @@
 /*-------------------------------------------------------------------------
  *	Chip specific
  *-------------------------------------------------------------------------*/
-#define CHIP_8723			BIT(2) /* RTL8723 With BT feature */
-#define CHIP_8723_DRV_REV		BIT(3) /* RTL8723 Driver Revised */
-#define NORMAL_CHIP			BIT(4)
-#define CHIP_VENDOR_UMC			BIT(5)
-#define CHIP_VENDOR_UMC_B_CUT		BIT(6)
+#define CHIP_8723			BIT( 2 ) /* RTL8723 With BT feature */
+#define CHIP_8723_DRV_REV		BIT( 3 ) /* RTL8723 Driver Revised */
+#define NORMAL_CHIP			BIT( 4 )
+#define CHIP_VENDOR_UMC			BIT( 5 )
+#define CHIP_VENDOR_UMC_B_CUT		BIT( 6 )
 
-#define IS_8723_SERIES(version)		\
-	(((version) & CHIP_8723) ? true : false)
+#define IS_8723_SERIES( version )		\
+	( ( ( version ) & CHIP_8723 ) ? true : false )
 
-#define IS_92C_1T2R(version)		\
-	(((version) & CHIP_92C) && ((version) & CHIP_92C_1T2R))
+#define IS_92C_1T2R( version )		\
+	( ( ( version ) & CHIP_92C ) && ( ( version ) & CHIP_92C_1T2R ) )
 
-#define IS_VENDOR_UMC(version)		\
-	(((version) & CHIP_VENDOR_UMC) ? true : false)
+#define IS_VENDOR_UMC( version )		\
+	( ( ( version ) & CHIP_VENDOR_UMC ) ? true : false )
 
-#define IS_VENDOR_8723_A_CUT(version)	\
-	(((version) & CHIP_VENDOR_UMC) ? (((version) & (BIT(6))) ? \
-	false : true) : false)
+#define IS_VENDOR_8723_A_CUT( version )	\
+	( ( ( version ) & CHIP_VENDOR_UMC ) ? ( ( ( version ) & ( BIT( 6 ) ) ) ? \
+	false : true ) : false )
 
 #define CHIP_BONDING_92C_1T2R	0x1
-#define CHIP_BONDING_IDENTIFIER(_value)	(((_value) >> 22) & 0x3)
+#define CHIP_BONDING_IDENTIFIER( _value )	( ( ( _value ) >> 22 ) & 0x3 )
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/dm.c b/drivers/net/wireless/rtlwifi/rtl8192cu/dm.c
index c16209a..2580e7c 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/dm.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/dm.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -34,25 +41,25 @@
 #include "phy.h"
 #include "dm.h"
 
-void rtl92cu_dm_dynamic_txpower(struct ieee80211_hw *hw)
+void rtl92cu_dm_dynamic_txpower( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	long undec_sm_pwdb;
 
-	if (!rtlpriv->dm.dynamic_txpower_enable)
+	if ( !rtlpriv->dm.dynamic_txpower_enable )
 		return;
 
-	if (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {
+	if ( rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE ) {
 		rtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;
 		return;
 	}
 
-	if ((mac->link_state < MAC80211_LINKED) &&
-	    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
-			 "Not connected to any\n");
+	if ( ( mac->link_state < MAC80211_LINKED ) &&
+	    ( rtlpriv->dm.entry_min_undec_sm_pwdb == 0 ) ) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_TRACE,
+			 "Not connected to any\n" );
 
 		rtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;
 
@@ -60,56 +67,56 @@ void rtl92cu_dm_dynamic_txpower(struct ieee80211_hw *hw)
 		return;
 	}
 
-	if (mac->link_state >= MAC80211_LINKED) {
-		if (mac->opmode == NL80211_IFTYPE_ADHOC) {
+	if ( mac->link_state >= MAC80211_LINKED ) {
+		if ( mac->opmode == NL80211_IFTYPE_ADHOC ) {
 			undec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;
-			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+			RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
 				 "AP Client PWDB = 0x%lx\n",
-				 undec_sm_pwdb);
+				 undec_sm_pwdb );
 		} else {
 			undec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;
-			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+			RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
 				 "STA Default Port PWDB = 0x%lx\n",
-				 undec_sm_pwdb);
+				 undec_sm_pwdb );
 		}
 	} else {
 		undec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;
 
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
 			 "AP Ext Port PWDB = 0x%lx\n",
-			 undec_sm_pwdb);
+			 undec_sm_pwdb );
 	}
 
-	if (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2) {
+	if ( undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2 ) {
 		rtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\n");
-	} else if ((undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3)) &&
-		   (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL1)) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
+			 "TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\n" );
+	} else if ( ( undec_sm_pwdb < ( TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3 ) ) &&
+		   ( undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL1 ) ) {
 
 		rtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\n");
-	} else if (undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
+			 "TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\n" );
+	} else if ( undec_sm_pwdb < ( TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5 ) ) {
 		rtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "TXHIGHPWRLEVEL_NORMAL\n");
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
+			 "TXHIGHPWRLEVEL_NORMAL\n" );
 	}
 
-	if ((rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl)) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+	if ( ( rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl ) ) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
 			 "PHY_SetTxPowerLevel8192S() Channel = %d\n",
-			 rtlphy->current_channel);
-		rtl92c_phy_set_txpower_level(hw, rtlphy->current_channel);
-		if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-		    TXHIGHPWRLEVEL_NORMAL)
-			dm_restorepowerindex(hw);
-		else if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-			 TXHIGHPWRLEVEL_LEVEL1)
-			dm_writepowerindex(hw, 0x14);
-		else if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-			 TXHIGHPWRLEVEL_LEVEL2)
-			dm_writepowerindex(hw, 0x10);
+			 rtlphy->current_channel );
+		rtl92c_phy_set_txpower_level( hw, rtlphy->current_channel );
+		if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+		    TXHIGHPWRLEVEL_NORMAL )
+			dm_restorepowerindex( hw );
+		else if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+			 TXHIGHPWRLEVEL_LEVEL1 )
+			dm_writepowerindex( hw, 0x14 );
+		else if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+			 TXHIGHPWRLEVEL_LEVEL2 )
+			dm_writepowerindex( hw, 0x10 );
 	}
 
 	rtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/dm.h b/drivers/net/wireless/rtlwifi/rtl8192cu/dm.h
index fafa6ba..d35bec7 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/dm.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/dm.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,13 +23,20 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
 
 #include "../rtl8192ce/dm.h"
 
-void rtl92cu_dm_dynamic_txpower(struct ieee80211_hw *hw);
-void dm_savepowerindex(struct ieee80211_hw *hw);
-void dm_writepowerindex(struct ieee80211_hw *hw, u8 value);
-void dm_restorepowerindex(struct ieee80211_hw *hw);
+void rtl92cu_dm_dynamic_txpower( struct ieee80211_hw *hw );
+void dm_savepowerindex( struct ieee80211_hw *hw );
+void dm_writepowerindex( struct ieee80211_hw *hw, u8 value );
+void dm_restorepowerindex( struct ieee80211_hw *hw );
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/hw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/hw.c
index 873363a..60daa76 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/hw.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/hw.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -47,15 +54,15 @@
 #include "led.h"
 #include "table.h"
 
-static void _rtl92cu_phy_param_tab_init(struct ieee80211_hw *hw)
+static void _rtl92cu_phy_param_tab_init( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtlpriv );
 
 	rtlphy->hwparam_tables[MAC_REG].length = RTL8192CUMAC_2T_ARRAYLENGTH;
 	rtlphy->hwparam_tables[MAC_REG].pdata = RTL8192CUMAC_2T_ARRAY;
-	if (IS_HIGHT_PA(rtlefuse->board_type)) {
+	if ( IS_HIGHT_PA( rtlefuse->board_type ) ) {
 		rtlphy->hwparam_tables[PHY_REG_PG].length =
 			RTL8192CUPHY_REG_Array_PG_HPLength;
 		rtlphy->hwparam_tables[PHY_REG_PG].pdata =
@@ -84,7 +91,7 @@ static void _rtl92cu_phy_param_tab_init(struct ieee80211_hw *hw)
 	rtlphy->hwparam_tables[AGCTAB_2T].pdata =
 			RTL8192CUAGCTAB_2TARRAY;
 	/* 1T */
-	if (IS_HIGHT_PA(rtlefuse->board_type)) {
+	if ( IS_HIGHT_PA( rtlefuse->board_type ) ) {
 		rtlphy->hwparam_tables[PHY_REG_1T].length =
 			RTL8192CUPHY_REG_1T_HPArrayLength;
 		rtlphy->hwparam_tables[PHY_REG_1T].pdata =
@@ -121,18 +128,18 @@ static void _rtl92cu_phy_param_tab_init(struct ieee80211_hw *hw)
 	}
 }
 
-static void _rtl92cu_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
+static void _rtl92cu_read_txpower_info_from_hwpg( struct ieee80211_hw *hw,
 						 bool autoload_fail,
-						 u8 *hwinfo)
+						 u8 *hwinfo )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	u8 rf_path, index, tempval;
 	u16 i;
 
-	for (rf_path = 0; rf_path < 2; rf_path++) {
-		for (i = 0; i < 3; i++) {
-			if (!autoload_fail) {
+	for ( rf_path = 0; rf_path < 2; rf_path++ ) {
+		for ( i = 0; i < 3; i++ ) {
+			if ( !autoload_fail ) {
 				rtlefuse->
 				    eeprom_chnlarea_txpwr_cck[rf_path][i] =
 				    hwinfo[EEPROM_TXPOWERCCK + rf_path * 3 + i];
@@ -150,50 +157,50 @@ static void _rtl92cu_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
 			}
 		}
 	}
-	for (i = 0; i < 3; i++) {
-		if (!autoload_fail)
+	for ( i = 0; i < 3; i++ ) {
+		if ( !autoload_fail )
 			tempval = hwinfo[EEPROM_TXPOWERHT40_2SDIFF + i];
 		else
 			tempval = EEPROM_DEFAULT_HT40_2SDIFF;
 		rtlefuse->eprom_chnl_txpwr_ht40_2sdf[RF90_PATH_A][i] =
-		    (tempval & 0xf);
+		    ( tempval & 0xf );
 		rtlefuse->eprom_chnl_txpwr_ht40_2sdf[RF90_PATH_B][i] =
-		    ((tempval & 0xf0) >> 4);
+		    ( ( tempval & 0xf0 ) >> 4 );
 	}
-	for (rf_path = 0; rf_path < 2; rf_path++)
-		for (i = 0; i < 3; i++)
-			RTPRINT(rtlpriv, FINIT, INIT_EEPROM,
+	for ( rf_path = 0; rf_path < 2; rf_path++ )
+		for ( i = 0; i < 3; i++ )
+			RTPRINT( rtlpriv, FINIT, INIT_EEPROM,
 				"RF(%d) EEPROM CCK Area(%d) = 0x%x\n",
 				rf_path, i,
 				rtlefuse->
-				eeprom_chnlarea_txpwr_cck[rf_path][i]);
-	for (rf_path = 0; rf_path < 2; rf_path++)
-		for (i = 0; i < 3; i++)
-			RTPRINT(rtlpriv, FINIT, INIT_EEPROM,
+				eeprom_chnlarea_txpwr_cck[rf_path][i] );
+	for ( rf_path = 0; rf_path < 2; rf_path++ )
+		for ( i = 0; i < 3; i++ )
+			RTPRINT( rtlpriv, FINIT, INIT_EEPROM,
 				"RF(%d) EEPROM HT40 1S Area(%d) = 0x%x\n",
 				rf_path, i,
 				rtlefuse->
-				eeprom_chnlarea_txpwr_ht40_1s[rf_path][i]);
-	for (rf_path = 0; rf_path < 2; rf_path++)
-		for (i = 0; i < 3; i++)
-			RTPRINT(rtlpriv, FINIT, INIT_EEPROM,
+				eeprom_chnlarea_txpwr_ht40_1s[rf_path][i] );
+	for ( rf_path = 0; rf_path < 2; rf_path++ )
+		for ( i = 0; i < 3; i++ )
+			RTPRINT( rtlpriv, FINIT, INIT_EEPROM,
 				"RF(%d) EEPROM HT40 2S Diff Area(%d) = 0x%x\n",
 				rf_path, i,
 				rtlefuse->
-				eprom_chnl_txpwr_ht40_2sdf[rf_path][i]);
-	for (rf_path = 0; rf_path < 2; rf_path++) {
-		for (i = 0; i < 14; i++) {
-			index = rtl92c_get_chnl_group((u8)i);
+				eprom_chnl_txpwr_ht40_2sdf[rf_path][i] );
+	for ( rf_path = 0; rf_path < 2; rf_path++ ) {
+		for ( i = 0; i < 14; i++ ) {
+			index = rtl92c_get_chnl_group( ( u8 )i );
 			rtlefuse->txpwrlevel_cck[rf_path][i] =
 			    rtlefuse->eeprom_chnlarea_txpwr_cck[rf_path][index];
 			rtlefuse->txpwrlevel_ht40_1s[rf_path][i] =
 			    rtlefuse->
 			    eeprom_chnlarea_txpwr_ht40_1s[rf_path][index];
-			if ((rtlefuse->
+			if ( ( rtlefuse->
 			     eeprom_chnlarea_txpwr_ht40_1s[rf_path][index] -
 			     rtlefuse->
-			     eprom_chnl_txpwr_ht40_2sdf[rf_path][index])
-			    > 0) {
+			     eprom_chnl_txpwr_ht40_2sdf[rf_path][index] )
+			    > 0 ) {
 				rtlefuse->txpwrlevel_ht40_2s[rf_path][i] =
 				    rtlefuse->
 				    eeprom_chnlarea_txpwr_ht40_1s[rf_path]
@@ -204,16 +211,16 @@ static void _rtl92cu_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
 				rtlefuse->txpwrlevel_ht40_2s[rf_path][i] = 0;
 			}
 		}
-		for (i = 0; i < 14; i++) {
-			RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+		for ( i = 0; i < 14; i++ ) {
+			RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 				"RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n", rf_path, i,
 				rtlefuse->txpwrlevel_cck[rf_path][i],
 				rtlefuse->txpwrlevel_ht40_1s[rf_path][i],
-				rtlefuse->txpwrlevel_ht40_2s[rf_path][i]);
+				rtlefuse->txpwrlevel_ht40_2s[rf_path][i] );
 		}
 	}
-	for (i = 0; i < 3; i++) {
-		if (!autoload_fail) {
+	for ( i = 0; i < 3; i++ ) {
+		if ( !autoload_fail ) {
 			rtlefuse->eeprom_pwrlimit_ht40[i] =
 			    hwinfo[EEPROM_TXPWR_GROUP + i];
 			rtlefuse->eeprom_pwrlimit_ht20[i] =
@@ -223,180 +230,180 @@ static void _rtl92cu_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
 			rtlefuse->eeprom_pwrlimit_ht20[i] = 0;
 		}
 	}
-	for (rf_path = 0; rf_path < 2; rf_path++) {
-		for (i = 0; i < 14; i++) {
-			index = rtl92c_get_chnl_group((u8)i);
-			if (rf_path == RF90_PATH_A) {
+	for ( rf_path = 0; rf_path < 2; rf_path++ ) {
+		for ( i = 0; i < 14; i++ ) {
+			index = rtl92c_get_chnl_group( ( u8 )i );
+			if ( rf_path == RF90_PATH_A ) {
 				rtlefuse->pwrgroup_ht20[rf_path][i] =
-				    (rtlefuse->eeprom_pwrlimit_ht20[index]
-				     & 0xf);
+				    ( rtlefuse->eeprom_pwrlimit_ht20[index]
+				     & 0xf );
 				rtlefuse->pwrgroup_ht40[rf_path][i] =
-				    (rtlefuse->eeprom_pwrlimit_ht40[index]
-				     & 0xf);
-			} else if (rf_path == RF90_PATH_B) {
+				    ( rtlefuse->eeprom_pwrlimit_ht40[index]
+				     & 0xf );
+			} else if ( rf_path == RF90_PATH_B ) {
 				rtlefuse->pwrgroup_ht20[rf_path][i] =
-				    ((rtlefuse->eeprom_pwrlimit_ht20[index]
-				      & 0xf0) >> 4);
+				    ( ( rtlefuse->eeprom_pwrlimit_ht20[index]
+				      & 0xf0 ) >> 4 );
 				rtlefuse->pwrgroup_ht40[rf_path][i] =
-				    ((rtlefuse->eeprom_pwrlimit_ht40[index]
-				      & 0xf0) >> 4);
+				    ( ( rtlefuse->eeprom_pwrlimit_ht40[index]
+				      & 0xf0 ) >> 4 );
 			}
-			RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+			RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 				"RF-%d pwrgroup_ht20[%d] = 0x%x\n",
 				rf_path, i,
-				rtlefuse->pwrgroup_ht20[rf_path][i]);
-			RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+				rtlefuse->pwrgroup_ht20[rf_path][i] );
+			RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 				"RF-%d pwrgroup_ht40[%d] = 0x%x\n",
 				rf_path, i,
-				rtlefuse->pwrgroup_ht40[rf_path][i]);
+				rtlefuse->pwrgroup_ht40[rf_path][i] );
 		}
 	}
-	for (i = 0; i < 14; i++) {
-		index = rtl92c_get_chnl_group((u8)i);
-		if (!autoload_fail)
+	for ( i = 0; i < 14; i++ ) {
+		index = rtl92c_get_chnl_group( ( u8 )i );
+		if ( !autoload_fail )
 			tempval = hwinfo[EEPROM_TXPOWERHT20DIFF + index];
 		else
 			tempval = EEPROM_DEFAULT_HT20_DIFF;
-		rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] = (tempval & 0xF);
+		rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] = ( tempval & 0xF );
 		rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] =
-		    ((tempval >> 4) & 0xF);
-		if (rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] & BIT(3))
+		    ( ( tempval >> 4 ) & 0xF );
+		if ( rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] & BIT( 3 ) )
 			rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] |= 0xF0;
-		if (rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] & BIT(3))
+		if ( rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] & BIT( 3 ) )
 			rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] |= 0xF0;
-		index = rtl92c_get_chnl_group((u8)i);
-		if (!autoload_fail)
+		index = rtl92c_get_chnl_group( ( u8 )i );
+		if ( !autoload_fail )
 			tempval = hwinfo[EEPROM_TXPOWER_OFDMDIFF + index];
 		else
 			tempval = EEPROM_DEFAULT_LEGACYHTTXPOWERDIFF;
-		rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] = (tempval & 0xF);
+		rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] = ( tempval & 0xF );
 		rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i] =
-		    ((tempval >> 4) & 0xF);
+		    ( ( tempval >> 4 ) & 0xF );
 	}
 	rtlefuse->legacy_ht_txpowerdiff =
 	    rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][7];
-	for (i = 0; i < 14; i++)
-		RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+	for ( i = 0; i < 14; i++ )
+		RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 			"RF-A Ht20 to HT40 Diff[%d] = 0x%x\n",
-			i, rtlefuse->txpwr_ht20diff[RF90_PATH_A][i]);
-	for (i = 0; i < 14; i++)
-		RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+			i, rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] );
+	for ( i = 0; i < 14; i++ )
+		RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 			"RF-A Legacy to Ht40 Diff[%d] = 0x%x\n",
-			i, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i]);
-	for (i = 0; i < 14; i++)
-		RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+			i, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] );
+	for ( i = 0; i < 14; i++ )
+		RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 			"RF-B Ht20 to HT40 Diff[%d] = 0x%x\n",
-			i, rtlefuse->txpwr_ht20diff[RF90_PATH_B][i]);
-	for (i = 0; i < 14; i++)
-		RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+			i, rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] );
+	for ( i = 0; i < 14; i++ )
+		RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 			"RF-B Legacy to HT40 Diff[%d] = 0x%x\n",
-			i, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i]);
-	if (!autoload_fail)
-		rtlefuse->eeprom_regulatory = (hwinfo[RF_OPTION1] & 0x7);
+			i, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i] );
+	if ( !autoload_fail )
+		rtlefuse->eeprom_regulatory = ( hwinfo[RF_OPTION1] & 0x7 );
 	else
 		rtlefuse->eeprom_regulatory = 0;
-	RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
-		"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory);
-	if (!autoload_fail) {
+	RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
+		"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory );
+	if ( !autoload_fail ) {
 		rtlefuse->eeprom_tssi[RF90_PATH_A] = hwinfo[EEPROM_TSSI_A];
 		rtlefuse->eeprom_tssi[RF90_PATH_B] = hwinfo[EEPROM_TSSI_B];
 	} else {
 		rtlefuse->eeprom_tssi[RF90_PATH_A] = EEPROM_DEFAULT_TSSI;
 		rtlefuse->eeprom_tssi[RF90_PATH_B] = EEPROM_DEFAULT_TSSI;
 	}
-	RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
+	RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
 		"TSSI_A = 0x%x, TSSI_B = 0x%x\n",
 		rtlefuse->eeprom_tssi[RF90_PATH_A],
-		rtlefuse->eeprom_tssi[RF90_PATH_B]);
-	if (!autoload_fail)
+		rtlefuse->eeprom_tssi[RF90_PATH_B] );
+	if ( !autoload_fail )
 		tempval = hwinfo[EEPROM_THERMAL_METER];
 	else
 		tempval = EEPROM_DEFAULT_THERMALMETER;
-	rtlefuse->eeprom_thermalmeter = (tempval & 0x1f);
-	if (rtlefuse->eeprom_thermalmeter < 0x06 ||
-	    rtlefuse->eeprom_thermalmeter > 0x1c)
+	rtlefuse->eeprom_thermalmeter = ( tempval & 0x1f );
+	if ( rtlefuse->eeprom_thermalmeter < 0x06 ||
+	    rtlefuse->eeprom_thermalmeter > 0x1c )
 		rtlefuse->eeprom_thermalmeter = 0x12;
-	if (rtlefuse->eeprom_thermalmeter == 0x1f || autoload_fail)
+	if ( rtlefuse->eeprom_thermalmeter == 0x1f || autoload_fail )
 		rtlefuse->apk_thermalmeterignore = true;
 	rtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;
-	RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
-		"thermalmeter = 0x%x\n", rtlefuse->eeprom_thermalmeter);
+	RTPRINT( rtlpriv, FINIT, INIT_TXPOWER,
+		"thermalmeter = 0x%x\n", rtlefuse->eeprom_thermalmeter );
 }
 
-static void _rtl92cu_read_board_type(struct ieee80211_hw *hw, u8 *contents)
+static void _rtl92cu_read_board_type( struct ieee80211_hw *hw, u8 *contents )
 {
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u8 boardType;
 
-	if (IS_NORMAL_CHIP(rtlhal->version)) {
-		boardType = ((contents[EEPROM_RF_OPT1]) &
-			    BOARD_TYPE_NORMAL_MASK) >> 5; /*bit[7:5]*/
+	if ( IS_NORMAL_CHIP( rtlhal->version ) ) {
+		boardType = ( ( contents[EEPROM_RF_OPT1] ) &
+			    BOARD_TYPE_NORMAL_MASK ) >> 5; /*bit[7:5]*/
 	} else {
 		boardType = contents[EEPROM_RF_OPT4];
 		boardType &= BOARD_TYPE_TEST_MASK;
 	}
 	rtlefuse->board_type = boardType;
-	if (IS_HIGHT_PA(rtlefuse->board_type))
+	if ( IS_HIGHT_PA( rtlefuse->board_type ) )
 		rtlefuse->external_pa = 1;
-	pr_info("Board Type %x\n", rtlefuse->board_type);
+	pr_info( "Board Type %x\n", rtlefuse->board_type );
 }
 
-static void _rtl92cu_read_adapter_info(struct ieee80211_hw *hw)
+static void _rtl92cu_read_adapter_info( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u16 i, usvalue;
 	u8 hwinfo[HWSET_MAX_SIZE] = {0};
 	u16 eeprom_id;
 
-	if (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {
-		rtl_efuse_shadow_map_update(hw);
-		memcpy((void *)hwinfo,
-		       (void *)&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
-		       HWSET_MAX_SIZE);
-	} else if (rtlefuse->epromtype == EEPROM_93C46) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "RTL819X Not boot from eeprom, check it !!\n");
+	if ( rtlefuse->epromtype == EEPROM_BOOT_EFUSE ) {
+		rtl_efuse_shadow_map_update( hw );
+		memcpy( ( void * )hwinfo,
+		       ( void * )&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
+		       HWSET_MAX_SIZE );
+	} else if ( rtlefuse->epromtype == EEPROM_93C46 ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "RTL819X Not boot from eeprom, check it !!\n" );
 	}
-	RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_LOUD, "MAP",
-		      hwinfo, HWSET_MAX_SIZE);
-	eeprom_id = le16_to_cpu(*((__le16 *)&hwinfo[0]));
-	if (eeprom_id != RTL8190_EEPROM_ID) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "EEPROM ID(%#x) is invalid!!\n", eeprom_id);
+	RT_PRINT_DATA( rtlpriv, COMP_INIT, DBG_LOUD, "MAP",
+		      hwinfo, HWSET_MAX_SIZE );
+	eeprom_id = le16_to_cpu( *( ( __le16 * )&hwinfo[0] ) );
+	if ( eeprom_id != RTL8190_EEPROM_ID ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "EEPROM ID(%#x) is invalid!!\n", eeprom_id );
 		rtlefuse->autoload_failflag = true;
 	} else {
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n" );
 		rtlefuse->autoload_failflag = false;
 	}
-	if (rtlefuse->autoload_failflag)
+	if ( rtlefuse->autoload_failflag )
 		return;
-	for (i = 0; i < 6; i += 2) {
-		usvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR + i];
-		*((u16 *) (&rtlefuse->dev_addr[i])) = usvalue;
+	for ( i = 0; i < 6; i += 2 ) {
+		usvalue = *( u16 * )&hwinfo[EEPROM_MAC_ADDR + i];
+		*( ( u16 * ) ( &rtlefuse->dev_addr[i] ) ) = usvalue;
 	}
-	pr_info("MAC address: %pM\n", rtlefuse->dev_addr);
-	_rtl92cu_read_txpower_info_from_hwpg(hw,
-					   rtlefuse->autoload_failflag, hwinfo);
-	rtlefuse->eeprom_vid = le16_to_cpu(*(__le16 *)&hwinfo[EEPROM_VID]);
-	rtlefuse->eeprom_did = le16_to_cpu(*(__le16 *)&hwinfo[EEPROM_DID]);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, " VID = 0x%02x PID = 0x%02x\n",
-		 rtlefuse->eeprom_vid, rtlefuse->eeprom_did);
+	pr_info( "MAC address: %pM\n", rtlefuse->dev_addr );
+	_rtl92cu_read_txpower_info_from_hwpg( hw,
+					   rtlefuse->autoload_failflag, hwinfo );
+	rtlefuse->eeprom_vid = le16_to_cpu( *( __le16 * )&hwinfo[EEPROM_VID] );
+	rtlefuse->eeprom_did = le16_to_cpu( *( __le16 * )&hwinfo[EEPROM_DID] );
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG, " VID = 0x%02x PID = 0x%02x\n",
+		 rtlefuse->eeprom_vid, rtlefuse->eeprom_did );
 	rtlefuse->eeprom_channelplan = hwinfo[EEPROM_CHANNELPLAN];
 	rtlefuse->eeprom_version =
-			 le16_to_cpu(*(__le16 *)&hwinfo[EEPROM_VERSION]);
+			 le16_to_cpu( *( __le16 * )&hwinfo[EEPROM_VERSION] );
 	rtlefuse->txpwr_fromeprom = true;
 	rtlefuse->eeprom_oemid = hwinfo[EEPROM_CUSTOMER_ID];
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "EEPROM Customer ID: 0x%2x\n",
-		 rtlefuse->eeprom_oemid);
-	if (rtlhal->oem_id == RT_CID_DEFAULT) {
-		switch (rtlefuse->eeprom_oemid) {
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD, "EEPROM Customer ID: 0x%2x\n",
+		 rtlefuse->eeprom_oemid );
+	if ( rtlhal->oem_id == RT_CID_DEFAULT ) {
+		switch ( rtlefuse->eeprom_oemid ) {
 		case EEPROM_CID_DEFAULT:
-			if (rtlefuse->eeprom_did == 0x8176) {
-				if ((rtlefuse->eeprom_svid == 0x103C &&
-				     rtlefuse->eeprom_smid == 0x1629))
+			if ( rtlefuse->eeprom_did == 0x8176 ) {
+				if ( ( rtlefuse->eeprom_svid == 0x103C &&
+				     rtlefuse->eeprom_smid == 0x1629 ) )
 					rtlhal->oem_id = RT_CID_819X_HP;
 				else
 					rtlhal->oem_id = RT_CID_DEFAULT;
@@ -416,16 +423,16 @@ static void _rtl92cu_read_adapter_info(struct ieee80211_hw *hw)
 			break;
 		}
 	}
-	_rtl92cu_read_board_type(hw, hwinfo);
+	_rtl92cu_read_board_type( hw, hwinfo );
 }
 
-static void _rtl92cu_hal_customized_behavior(struct ieee80211_hw *hw)
+static void _rtl92cu_hal_customized_behavior( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb_priv *usb_priv = rtl_usbpriv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 
-	switch (rtlhal->oem_id) {
+	switch ( rtlhal->oem_id ) {
 	case RT_CID_819X_HP:
 		usb_priv->ledctl.led_opendrain = true;
 		break;
@@ -438,36 +445,36 @@ static void _rtl92cu_hal_customized_behavior(struct ieee80211_hw *hw)
 	default:
 		break;
 	}
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "RT Customized ID: 0x%02X\n",
-		 rtlhal->oem_id);
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG, "RT Customized ID: 0x%02X\n",
+		 rtlhal->oem_id );
 }
 
-void rtl92cu_read_eeprom_info(struct ieee80211_hw *hw)
+void rtl92cu_read_eeprom_info( struct ieee80211_hw *hw )
 {
 
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u8 tmp_u1b;
 
-	if (!IS_NORMAL_CHIP(rtlhal->version))
+	if ( !IS_NORMAL_CHIP( rtlhal->version ) )
 		return;
-	tmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);
-	rtlefuse->epromtype = (tmp_u1b & BOOT_FROM_EEPROM) ?
+	tmp_u1b = rtl_read_byte( rtlpriv, REG_9346CR );
+	rtlefuse->epromtype = ( tmp_u1b & BOOT_FROM_EEPROM ) ?
 			       EEPROM_93C46 : EEPROM_BOOT_EFUSE;
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from %s\n",
-		 tmp_u1b & BOOT_FROM_EEPROM ? "EERROM" : "EFUSE");
-	rtlefuse->autoload_failflag = (tmp_u1b & EEPROM_EN) ? false : true;
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload %s\n",
-		 tmp_u1b & EEPROM_EN ? "OK!!" : "ERR!!");
-	_rtl92cu_read_adapter_info(hw);
-	_rtl92cu_hal_customized_behavior(hw);
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG, "Boot from %s\n",
+		 tmp_u1b & BOOT_FROM_EEPROM ? "EERROM" : "EFUSE" );
+	rtlefuse->autoload_failflag = ( tmp_u1b & EEPROM_EN ) ? false : true;
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD, "Autoload %s\n",
+		 tmp_u1b & EEPROM_EN ? "OK!!" : "ERR!!" );
+	_rtl92cu_read_adapter_info( hw );
+	_rtl92cu_hal_customized_behavior( hw );
 	return;
 }
 
-static int _rtl92cu_init_power_on(struct ieee80211_hw *hw)
+static int _rtl92cu_init_power_on( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	int		status = 0;
 	u16		value16;
 	u8		value8;
@@ -475,82 +482,82 @@ static int _rtl92cu_init_power_on(struct ieee80211_hw *hw)
 	u32	pollingCount = 0;
 
 	do {
-		if (rtl_read_byte(rtlpriv, REG_APS_FSMCO) & PFM_ALDN) {
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-				 "Autoload Done!\n");
+		if ( rtl_read_byte( rtlpriv, REG_APS_FSMCO ) & PFM_ALDN ) {
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+				 "Autoload Done!\n" );
 			break;
 		}
-		if (pollingCount++ > 100) {
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG,
-				 "Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n");
+		if ( pollingCount++ > 100 ) {
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_EMERG,
+				 "Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n" );
 			return -ENODEV;
 		}
-	} while (true);
+	} while ( true );
 	/* 0. RSV_CTRL 0x1C[7:0] = 0 unlock ISO/CLK/Power control register */
-	rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0);
+	rtl_write_byte( rtlpriv, REG_RSV_CTRL, 0x0 );
 	/* Power on when re-enter from IPS/Radio off/card disable */
 	/* enable SPS into PWM mode */
-	rtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);
-	udelay(100);
-	value8 = rtl_read_byte(rtlpriv, REG_LDOV12D_CTRL);
-	if (0 == (value8 & LDV12_EN)) {
+	rtl_write_byte( rtlpriv, REG_SPS0_CTRL, 0x2b );
+	udelay( 100 );
+	value8 = rtl_read_byte( rtlpriv, REG_LDOV12D_CTRL );
+	if ( 0 == ( value8 & LDV12_EN ) ) {
 		value8 |= LDV12_EN;
-		rtl_write_byte(rtlpriv, REG_LDOV12D_CTRL, value8);
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
+		rtl_write_byte( rtlpriv, REG_LDOV12D_CTRL, value8 );
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
 			 " power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x\n",
-			 value8);
-		udelay(100);
-		value8 = rtl_read_byte(rtlpriv, REG_SYS_ISO_CTRL);
+			 value8 );
+		udelay( 100 );
+		value8 = rtl_read_byte( rtlpriv, REG_SYS_ISO_CTRL );
 		value8 &= ~ISO_MD2PP;
-		rtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, value8);
+		rtl_write_byte( rtlpriv, REG_SYS_ISO_CTRL, value8 );
 	}
 	/*  auto enable WLAN */
 	pollingCount = 0;
-	value16 = rtl_read_word(rtlpriv, REG_APS_FSMCO);
+	value16 = rtl_read_word( rtlpriv, REG_APS_FSMCO );
 	value16 |= APFM_ONMAC;
-	rtl_write_word(rtlpriv, REG_APS_FSMCO, value16);
+	rtl_write_word( rtlpriv, REG_APS_FSMCO, value16 );
 	do {
-		if (!(rtl_read_word(rtlpriv, REG_APS_FSMCO) & APFM_ONMAC)) {
-			pr_info("MAC auto ON okay!\n");
+		if ( !( rtl_read_word( rtlpriv, REG_APS_FSMCO ) & APFM_ONMAC ) ) {
+			pr_info( "MAC auto ON okay!\n" );
 			break;
 		}
-		if (pollingCount++ > 1000) {
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG,
-				 "Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n");
+		if ( pollingCount++ > 1000 ) {
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_EMERG,
+				 "Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n" );
 			return -ENODEV;
 		}
-	} while (true);
+	} while ( true );
 	/* Enable Radio ,GPIO ,and LED function */
-	rtl_write_word(rtlpriv, REG_APS_FSMCO, 0x0812);
+	rtl_write_word( rtlpriv, REG_APS_FSMCO, 0x0812 );
 	/* release RF digital isolation */
-	value16 = rtl_read_word(rtlpriv, REG_SYS_ISO_CTRL);
+	value16 = rtl_read_word( rtlpriv, REG_SYS_ISO_CTRL );
 	value16 &= ~ISO_DIOR;
-	rtl_write_word(rtlpriv, REG_SYS_ISO_CTRL, value16);
+	rtl_write_word( rtlpriv, REG_SYS_ISO_CTRL, value16 );
 	/* Reconsider when to do this operation after asking HWSD. */
 	pollingCount = 0;
-	rtl_write_byte(rtlpriv, REG_APSD_CTRL, (rtl_read_byte(rtlpriv,
-						REG_APSD_CTRL) & ~BIT(6)));
+	rtl_write_byte( rtlpriv, REG_APSD_CTRL, ( rtl_read_byte( rtlpriv,
+						REG_APSD_CTRL ) & ~BIT( 6 ) ) );
 	do {
 		pollingCount++;
-	} while ((pollingCount < 200) &&
-		 (rtl_read_byte(rtlpriv, REG_APSD_CTRL) & BIT(7)));
+	} while ( ( pollingCount < 200 ) &&
+		 ( rtl_read_byte( rtlpriv, REG_APSD_CTRL ) & BIT( 7 ) ) );
 	/* Enable MAC DMA/WMAC/SCHEDULE/SEC block */
-	value16 = rtl_read_word(rtlpriv,  REG_CR);
-	value16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN |
-		    PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);
-	rtl_write_word(rtlpriv, REG_CR, value16);
+	value16 = rtl_read_word( rtlpriv,  REG_CR );
+	value16 |= ( HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN |
+		    PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC );
+	rtl_write_word( rtlpriv, REG_CR, value16 );
 	return status;
 }
 
-static void _rtl92cu_init_queue_reserved_page(struct ieee80211_hw *hw,
+static void _rtl92cu_init_queue_reserved_page( struct ieee80211_hw *hw,
 					      bool wmm_enable,
 					      u8 out_ep_num,
-					      u8 queue_sel)
+					      u8 queue_sel )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	bool isChipN = IS_NORMAL_CHIP(rtlhal->version);
-	u32 outEPNum = (u32)out_ep_num;
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	bool isChipN = IS_NORMAL_CHIP( rtlhal->version );
+	u32 outEPNum = ( u32 )out_ep_num;
 	u32 numHQ = 0;
 	u32 numLQ = 0;
 	u32 numNQ = 0;
@@ -559,96 +566,96 @@ static void _rtl92cu_init_queue_reserved_page(struct ieee80211_hw *hw,
 	u8 value8;
 	u32 txQPageNum, txQPageUnit, txQRemainPage;
 
-	if (!wmm_enable) {
-		numPubQ = (isChipN) ? CHIP_B_PAGE_NUM_PUBQ :
+	if ( !wmm_enable ) {
+		numPubQ = ( isChipN ) ? CHIP_B_PAGE_NUM_PUBQ :
 			  CHIP_A_PAGE_NUM_PUBQ;
 		txQPageNum = TX_TOTAL_PAGE_NUMBER - numPubQ;
 
 		txQPageUnit = txQPageNum/outEPNum;
 		txQRemainPage = txQPageNum % outEPNum;
-		if (queue_sel & TX_SELE_HQ)
+		if ( queue_sel & TX_SELE_HQ )
 			numHQ = txQPageUnit;
-		if (queue_sel & TX_SELE_LQ)
+		if ( queue_sel & TX_SELE_LQ )
 			numLQ = txQPageUnit;
 		/* HIGH priority queue always present in the configuration of
 		 * 2 out-ep. Remainder pages have assigned to High queue */
-		if ((outEPNum > 1) && (txQRemainPage))
+		if ( ( outEPNum > 1 ) && ( txQRemainPage ) )
 			numHQ += txQRemainPage;
 		/* NOTE: This step done before writting REG_RQPN. */
-		if (isChipN) {
-			if (queue_sel & TX_SELE_NQ)
+		if ( isChipN ) {
+			if ( queue_sel & TX_SELE_NQ )
 				numNQ = txQPageUnit;
-			value8 = (u8)_NPQ(numNQ);
-			rtl_write_byte(rtlpriv,  REG_RQPN_NPQ, value8);
+			value8 = ( u8 )_NPQ( numNQ );
+			rtl_write_byte( rtlpriv,  REG_RQPN_NPQ, value8 );
 		}
 	} else {
 		/* for WMM ,number of out-ep must more than or equal to 2! */
 		numPubQ = isChipN ? WMM_CHIP_B_PAGE_NUM_PUBQ :
 			  WMM_CHIP_A_PAGE_NUM_PUBQ;
-		if (queue_sel & TX_SELE_HQ) {
+		if ( queue_sel & TX_SELE_HQ ) {
 			numHQ = isChipN ? WMM_CHIP_B_PAGE_NUM_HPQ :
 				WMM_CHIP_A_PAGE_NUM_HPQ;
 		}
-		if (queue_sel & TX_SELE_LQ) {
+		if ( queue_sel & TX_SELE_LQ ) {
 			numLQ = isChipN ? WMM_CHIP_B_PAGE_NUM_LPQ :
 				WMM_CHIP_A_PAGE_NUM_LPQ;
 		}
 		/* NOTE: This step done before writting REG_RQPN. */
-		if (isChipN) {
-			if (queue_sel & TX_SELE_NQ)
+		if ( isChipN ) {
+			if ( queue_sel & TX_SELE_NQ )
 				numNQ = WMM_CHIP_B_PAGE_NUM_NPQ;
-			value8 = (u8)_NPQ(numNQ);
-			rtl_write_byte(rtlpriv, REG_RQPN_NPQ, value8);
+			value8 = ( u8 )_NPQ( numNQ );
+			rtl_write_byte( rtlpriv, REG_RQPN_NPQ, value8 );
 		}
 	}
 	/* TX DMA */
-	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
-	rtl_write_dword(rtlpriv, REG_RQPN, value32);
+	value32 = _HPQ( numHQ ) | _LPQ( numLQ ) | _PUBQ( numPubQ ) | LD_RQPN;
+	rtl_write_dword( rtlpriv, REG_RQPN, value32 );
 }
 
-static void _rtl92c_init_trx_buffer(struct ieee80211_hw *hw, bool wmm_enable)
+static void _rtl92c_init_trx_buffer( struct ieee80211_hw *hw, bool wmm_enable )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u8	txpktbuf_bndy;
 	u8	value8;
 
-	if (!wmm_enable)
+	if ( !wmm_enable )
 		txpktbuf_bndy = TX_PAGE_BOUNDARY;
 	else /* for WMM */
-		txpktbuf_bndy = (IS_NORMAL_CHIP(rtlhal->version))
+		txpktbuf_bndy = ( IS_NORMAL_CHIP( rtlhal->version ) )
 						? WMM_CHIP_B_TX_PAGE_BOUNDARY
 						: WMM_CHIP_A_TX_PAGE_BOUNDARY;
-	rtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
-	rtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
-	rtl_write_byte(rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
-	rtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);
-	rtl_write_byte(rtlpriv, REG_TDECTRL+1, txpktbuf_bndy);
-	rtl_write_word(rtlpriv,  (REG_TRXFF_BNDY + 2), 0x27FF);
-	value8 = _PSRX(RX_PAGE_SIZE_REG_VALUE) | _PSTX(PBP_128);
-	rtl_write_byte(rtlpriv, REG_PBP, value8);
+	rtl_write_byte( rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy );
+	rtl_write_byte( rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy );
+	rtl_write_byte( rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy );
+	rtl_write_byte( rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy );
+	rtl_write_byte( rtlpriv, REG_TDECTRL+1, txpktbuf_bndy );
+	rtl_write_word( rtlpriv,  ( REG_TRXFF_BNDY + 2 ), 0x27FF );
+	value8 = _PSRX( RX_PAGE_SIZE_REG_VALUE ) | _PSTX( PBP_128 );
+	rtl_write_byte( rtlpriv, REG_PBP, value8 );
 }
 
-static void _rtl92c_init_chipN_reg_priority(struct ieee80211_hw *hw, u16 beQ,
+static void _rtl92c_init_chipN_reg_priority( struct ieee80211_hw *hw, u16 beQ,
 					    u16 bkQ, u16 viQ, u16 voQ,
-					    u16 mgtQ, u16 hiQ)
+					    u16 mgtQ, u16 hiQ )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u16 value16 = (rtl_read_word(rtlpriv, REG_TRXDMA_CTRL) & 0x7);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	u16 value16 = ( rtl_read_word( rtlpriv, REG_TRXDMA_CTRL ) & 0x7 );
 
-	value16 |= _TXDMA_BEQ_MAP(beQ) | _TXDMA_BKQ_MAP(bkQ) |
-		   _TXDMA_VIQ_MAP(viQ) | _TXDMA_VOQ_MAP(voQ) |
-		   _TXDMA_MGQ_MAP(mgtQ) | _TXDMA_HIQ_MAP(hiQ);
-	rtl_write_word(rtlpriv,  REG_TRXDMA_CTRL, value16);
+	value16 |= _TXDMA_BEQ_MAP( beQ ) | _TXDMA_BKQ_MAP( bkQ ) |
+		   _TXDMA_VIQ_MAP( viQ ) | _TXDMA_VOQ_MAP( voQ ) |
+		   _TXDMA_MGQ_MAP( mgtQ ) | _TXDMA_HIQ_MAP( hiQ );
+	rtl_write_word( rtlpriv,  REG_TRXDMA_CTRL, value16 );
 }
 
-static void _rtl92cu_init_chipN_one_out_ep_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_chipN_one_out_ep_priority( struct ieee80211_hw *hw,
 						    bool wmm_enable,
-						    u8 queue_sel)
+						    u8 queue_sel )
 {
-	u16 uninitialized_var(value);
+	u16 uninitialized_var( value );
 
-	switch (queue_sel) {
+	switch ( queue_sel ) {
 	case TX_SELE_HQ:
 		value = QUEUE_HIGH;
 		break;
@@ -659,40 +666,40 @@ static void _rtl92cu_init_chipN_one_out_ep_priority(struct ieee80211_hw *hw,
 		value = QUEUE_NORMAL;
 		break;
 	default:
-		WARN_ON(1); /* Shall not reach here! */
+		WARN_ON( 1 ); /* Shall not reach here! */
 		break;
 	}
-	_rtl92c_init_chipN_reg_priority(hw, value, value, value, value,
-					value, value);
-	pr_info("Tx queue select: 0x%02x\n", queue_sel);
+	_rtl92c_init_chipN_reg_priority( hw, value, value, value, value,
+					value, value );
+	pr_info( "Tx queue select: 0x%02x\n", queue_sel );
 }
 
-static void _rtl92cu_init_chipN_two_out_ep_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_chipN_two_out_ep_priority( struct ieee80211_hw *hw,
 								bool wmm_enable,
-								u8 queue_sel)
+								u8 queue_sel )
 {
 	u16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;
-	u16 uninitialized_var(valueHi);
-	u16 uninitialized_var(valueLow);
+	u16 uninitialized_var( valueHi );
+	u16 uninitialized_var( valueLow );
 
-	switch (queue_sel) {
-	case (TX_SELE_HQ | TX_SELE_LQ):
+	switch ( queue_sel ) {
+	case ( TX_SELE_HQ | TX_SELE_LQ ):
 		valueHi = QUEUE_HIGH;
 		valueLow = QUEUE_LOW;
 		break;
-	case (TX_SELE_NQ | TX_SELE_LQ):
+	case ( TX_SELE_NQ | TX_SELE_LQ ):
 		valueHi = QUEUE_NORMAL;
 		valueLow = QUEUE_LOW;
 		break;
-	case (TX_SELE_HQ | TX_SELE_NQ):
+	case ( TX_SELE_HQ | TX_SELE_NQ ):
 		valueHi = QUEUE_HIGH;
 		valueLow = QUEUE_NORMAL;
 		break;
 	default:
-		WARN_ON(1);
+		WARN_ON( 1 );
 		break;
 	}
-	if (!wmm_enable) {
+	if ( !wmm_enable ) {
 		beQ = valueLow;
 		bkQ = valueLow;
 		viQ = valueHi;
@@ -707,18 +714,18 @@ static void _rtl92cu_init_chipN_two_out_ep_priority(struct ieee80211_hw *hw,
 		mgtQ = valueHi;
 		hiQ = valueHi;
 	}
-	_rtl92c_init_chipN_reg_priority(hw, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
-	pr_info("Tx queue select: 0x%02x\n", queue_sel);
+	_rtl92c_init_chipN_reg_priority( hw, beQ, bkQ, viQ, voQ, mgtQ, hiQ );
+	pr_info( "Tx queue select: 0x%02x\n", queue_sel );
 }
 
-static void _rtl92cu_init_chipN_three_out_ep_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_chipN_three_out_ep_priority( struct ieee80211_hw *hw,
 						      bool wmm_enable,
-						      u8 queue_sel)
+						      u8 queue_sel )
 {
 	u16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (!wmm_enable) { /* typical setting */
+	if ( !wmm_enable ) { /* typical setting */
 		beQ	= QUEUE_LOW;
 		bkQ	= QUEUE_LOW;
 		viQ	= QUEUE_NORMAL;
@@ -733,46 +740,46 @@ static void _rtl92cu_init_chipN_three_out_ep_priority(struct ieee80211_hw *hw,
 		mgtQ	= QUEUE_HIGH;
 		hiQ	= QUEUE_HIGH;
 	}
-	_rtl92c_init_chipN_reg_priority(hw, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG, "Tx queue select :0x%02x..\n",
-		 queue_sel);
+	_rtl92c_init_chipN_reg_priority( hw, beQ, bkQ, viQ, voQ, mgtQ, hiQ );
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_EMERG, "Tx queue select :0x%02x..\n",
+		 queue_sel );
 }
 
-static void _rtl92cu_init_chipN_queue_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_chipN_queue_priority( struct ieee80211_hw *hw,
 					       bool wmm_enable,
 					       u8 out_ep_num,
-					       u8 queue_sel)
+					       u8 queue_sel )
 {
-	switch (out_ep_num) {
+	switch ( out_ep_num ) {
 	case 1:
-		_rtl92cu_init_chipN_one_out_ep_priority(hw, wmm_enable,
-							queue_sel);
+		_rtl92cu_init_chipN_one_out_ep_priority( hw, wmm_enable,
+							queue_sel );
 		break;
 	case 2:
-		_rtl92cu_init_chipN_two_out_ep_priority(hw, wmm_enable,
-							queue_sel);
+		_rtl92cu_init_chipN_two_out_ep_priority( hw, wmm_enable,
+							queue_sel );
 		break;
 	case 3:
-		_rtl92cu_init_chipN_three_out_ep_priority(hw, wmm_enable,
-							  queue_sel);
+		_rtl92cu_init_chipN_three_out_ep_priority( hw, wmm_enable,
+							  queue_sel );
 		break;
 	default:
-		WARN_ON(1); /* Shall not reach here! */
+		WARN_ON( 1 ); /* Shall not reach here! */
 		break;
 	}
 }
 
-static void _rtl92cu_init_chipT_queue_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_chipT_queue_priority( struct ieee80211_hw *hw,
 					       bool wmm_enable,
 					       u8 out_ep_num,
-					       u8 queue_sel)
+					       u8 queue_sel )
 {
 	u8 hq_sele = 0;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	switch (out_ep_num) {
-	case 2:	/* (TX_SELE_HQ|TX_SELE_LQ) */
-		if (!wmm_enable) /* typical setting */
+	switch ( out_ep_num ) {
+	case 2:	/* ( TX_SELE_HQ|TX_SELE_LQ ) */
+		if ( !wmm_enable ) /* typical setting */
 			hq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_MGTQ |
 				   HQSEL_HIQ;
 		else	/* for WMM */
@@ -780,282 +787,282 @@ static void _rtl92cu_init_chipT_queue_priority(struct ieee80211_hw *hw,
 				  HQSEL_HIQ;
 		break;
 	case 1:
-		if (TX_SELE_LQ == queue_sel) {
+		if ( TX_SELE_LQ == queue_sel ) {
 			/* map all endpoint to Low queue */
 			hq_sele = 0;
-		} else if (TX_SELE_HQ == queue_sel) {
+		} else if ( TX_SELE_HQ == queue_sel ) {
 			/* map all endpoint to High queue */
 			hq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_BEQ |
 				   HQSEL_BKQ | HQSEL_MGTQ | HQSEL_HIQ;
 		}
 		break;
 	default:
-		WARN_ON(1); /* Shall not reach here! */
+		WARN_ON( 1 ); /* Shall not reach here! */
 		break;
 	}
-	rtl_write_byte(rtlpriv, (REG_TRXDMA_CTRL+1), hq_sele);
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG, "Tx queue select :0x%02x..\n",
-		 hq_sele);
+	rtl_write_byte( rtlpriv, ( REG_TRXDMA_CTRL+1 ), hq_sele );
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_EMERG, "Tx queue select :0x%02x..\n",
+		 hq_sele );
 }
 
-static void _rtl92cu_init_queue_priority(struct ieee80211_hw *hw,
+static void _rtl92cu_init_queue_priority( struct ieee80211_hw *hw,
 						bool wmm_enable,
 						u8 out_ep_num,
-						u8 queue_sel)
+						u8 queue_sel )
 {
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		_rtl92cu_init_chipN_queue_priority(hw, wmm_enable, out_ep_num,
-						   queue_sel);
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		_rtl92cu_init_chipN_queue_priority( hw, wmm_enable, out_ep_num,
+						   queue_sel );
 	else
-		_rtl92cu_init_chipT_queue_priority(hw, wmm_enable, out_ep_num,
-						   queue_sel);
+		_rtl92cu_init_chipT_queue_priority( hw, wmm_enable, out_ep_num,
+						   queue_sel );
 }
 
-static void _rtl92cu_init_usb_aggregation(struct ieee80211_hw *hw)
+static void _rtl92cu_init_usb_aggregation( struct ieee80211_hw *hw )
 {
 }
 
-static void _rtl92cu_init_wmac_setting(struct ieee80211_hw *hw)
+static void _rtl92cu_init_wmac_setting( struct ieee80211_hw *hw )
 {
 	u16			value16;
 
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 
-	mac->rx_conf = (RCR_APM | RCR_AM | RCR_ADF | RCR_AB | RCR_APPFCS |
+	mac->rx_conf = ( RCR_APM | RCR_AM | RCR_ADF | RCR_AB | RCR_APPFCS |
 		      RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL |
-		      RCR_APP_MIC | RCR_APP_PHYSTS | RCR_ACRC32);
-	rtl_write_dword(rtlpriv, REG_RCR, mac->rx_conf);
+		      RCR_APP_MIC | RCR_APP_PHYSTS | RCR_ACRC32 );
+	rtl_write_dword( rtlpriv, REG_RCR, mac->rx_conf );
 	/* Accept all multicast address */
-	rtl_write_dword(rtlpriv,  REG_MAR, 0xFFFFFFFF);
-	rtl_write_dword(rtlpriv,  REG_MAR + 4, 0xFFFFFFFF);
+	rtl_write_dword( rtlpriv,  REG_MAR, 0xFFFFFFFF );
+	rtl_write_dword( rtlpriv,  REG_MAR + 4, 0xFFFFFFFF );
 	/* Accept all management frames */
 	value16 = 0xFFFF;
-	rtl92c_set_mgt_filter(hw, value16);
+	rtl92c_set_mgt_filter( hw, value16 );
 	/* Reject all control frame - default value is 0 */
-	rtl92c_set_ctrl_filter(hw, 0x0);
+	rtl92c_set_ctrl_filter( hw, 0x0 );
 	/* Accept all data frames */
 	value16 = 0xFFFF;
-	rtl92c_set_data_filter(hw, value16);
+	rtl92c_set_data_filter( hw, value16 );
 }
 
-static int _rtl92cu_init_mac(struct ieee80211_hw *hw)
+static int _rtl92cu_init_mac( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(usb_priv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_usb_priv *usb_priv = rtl_usbpriv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( usb_priv );
 	int err = 0;
 	u32	boundary = 0;
 	u8 wmm_enable = false; /* TODO */
 	u8 out_ep_nums = rtlusb->out_ep_nums;
 	u8 queue_sel = rtlusb->out_queue_sel;
-	err = _rtl92cu_init_power_on(hw);
+	err = _rtl92cu_init_power_on( hw );
 
-	if (err) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "Failed to init power on!\n");
+	if ( err ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "Failed to init power on!\n" );
 		return err;
 	}
-	if (!wmm_enable) {
+	if ( !wmm_enable ) {
 		boundary = TX_PAGE_BOUNDARY;
 	} else { /* for WMM */
-		boundary = (IS_NORMAL_CHIP(rtlhal->version))
+		boundary = ( IS_NORMAL_CHIP( rtlhal->version ) )
 					? WMM_CHIP_B_TX_PAGE_BOUNDARY
 					: WMM_CHIP_A_TX_PAGE_BOUNDARY;
 	}
-	if (false == rtl92c_init_llt_table(hw, boundary)) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "Failed to init LLT Table!\n");
+	if ( false == rtl92c_init_llt_table( hw, boundary ) ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "Failed to init LLT Table!\n" );
 		return -EINVAL;
 	}
-	_rtl92cu_init_queue_reserved_page(hw, wmm_enable, out_ep_nums,
-					  queue_sel);
-	_rtl92c_init_trx_buffer(hw, wmm_enable);
-	_rtl92cu_init_queue_priority(hw, wmm_enable, out_ep_nums,
-				     queue_sel);
+	_rtl92cu_init_queue_reserved_page( hw, wmm_enable, out_ep_nums,
+					  queue_sel );
+	_rtl92c_init_trx_buffer( hw, wmm_enable );
+	_rtl92cu_init_queue_priority( hw, wmm_enable, out_ep_nums,
+				     queue_sel );
 	/* Get Rx PHY status in order to report RSSI and others. */
-	rtl92c_init_driver_info_size(hw, RTL92C_DRIVER_INFO_SIZE);
-	rtl92c_init_interrupt(hw);
-	rtl92c_init_network_type(hw);
-	_rtl92cu_init_wmac_setting(hw);
-	rtl92c_init_adaptive_ctrl(hw);
-	rtl92c_init_edca(hw);
-	rtl92c_init_rate_fallback(hw);
-	rtl92c_init_retry_function(hw);
-	_rtl92cu_init_usb_aggregation(hw);
-	rtlpriv->cfg->ops->set_bw_mode(hw, NL80211_CHAN_HT20);
-	rtl92c_set_min_space(hw, IS_92C_SERIAL(rtlhal->version));
-	rtl92c_init_beacon_parameters(hw, rtlhal->version);
-	rtl92c_init_ampdu_aggregation(hw);
-	rtl92c_init_beacon_max_error(hw, true);
+	rtl92c_init_driver_info_size( hw, RTL92C_DRIVER_INFO_SIZE );
+	rtl92c_init_interrupt( hw );
+	rtl92c_init_network_type( hw );
+	_rtl92cu_init_wmac_setting( hw );
+	rtl92c_init_adaptive_ctrl( hw );
+	rtl92c_init_edca( hw );
+	rtl92c_init_rate_fallback( hw );
+	rtl92c_init_retry_function( hw );
+	_rtl92cu_init_usb_aggregation( hw );
+	rtlpriv->cfg->ops->set_bw_mode( hw, NL80211_CHAN_HT20 );
+	rtl92c_set_min_space( hw, IS_92C_SERIAL( rtlhal->version ) );
+	rtl92c_init_beacon_parameters( hw, rtlhal->version );
+	rtl92c_init_ampdu_aggregation( hw );
+	rtl92c_init_beacon_max_error( hw, true );
 	return err;
 }
 
-void rtl92cu_enable_hw_security_config(struct ieee80211_hw *hw)
+void rtl92cu_enable_hw_security_config( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u8 sec_reg_value = 0x0;
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD,
 		 "PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\n",
 		 rtlpriv->sec.pairwise_enc_algorithm,
-		 rtlpriv->sec.group_enc_algorithm);
-	if (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {
-		RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
-			 "not open sw encryption\n");
+		 rtlpriv->sec.group_enc_algorithm );
+	if ( rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec ) {
+		RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG,
+			 "not open sw encryption\n" );
 		return;
 	}
 	sec_reg_value = SCR_TxEncEnable | SCR_RxDecEnable;
-	if (rtlpriv->sec.use_defaultkey) {
+	if ( rtlpriv->sec.use_defaultkey ) {
 		sec_reg_value |= SCR_TxUseDK;
 		sec_reg_value |= SCR_RxUseDK;
 	}
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		sec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);
-	rtl_write_byte(rtlpriv, REG_CR + 1, 0x02);
-	RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD, "The SECR-value %x\n",
-		 sec_reg_value);
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		sec_reg_value |= ( SCR_RXBCUSEDK | SCR_TXBCUSEDK );
+	rtl_write_byte( rtlpriv, REG_CR + 1, 0x02 );
+	RT_TRACE( rtlpriv, COMP_SEC, DBG_LOUD, "The SECR-value %x\n",
+		 sec_reg_value );
+	rtlpriv->cfg->ops->set_hw_reg( hw, HW_VAR_WPA_CONFIG, &sec_reg_value );
 }
 
-static void _rtl92cu_hw_configure(struct ieee80211_hw *hw)
+static void _rtl92cu_hw_configure( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( rtl_usbpriv( hw ) );
 
 	/* To Fix MAC loopback mode fail. */
-	rtl_write_byte(rtlpriv, REG_LDOHCI12_CTRL, 0x0f);
-	rtl_write_byte(rtlpriv, 0x15, 0xe9);
+	rtl_write_byte( rtlpriv, REG_LDOHCI12_CTRL, 0x0f );
+	rtl_write_byte( rtlpriv, 0x15, 0xe9 );
 	/* HW SEQ CTRL */
 	/* set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM. */
-	rtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);
+	rtl_write_byte( rtlpriv, REG_HWSEQ_CTRL, 0xFF );
 	/* fixed USB interface interference issue */
-	rtl_write_byte(rtlpriv, 0xfe40, 0xe0);
-	rtl_write_byte(rtlpriv, 0xfe41, 0x8d);
-	rtl_write_byte(rtlpriv, 0xfe42, 0x80);
+	rtl_write_byte( rtlpriv, 0xfe40, 0xe0 );
+	rtl_write_byte( rtlpriv, 0xfe41, 0x8d );
+	rtl_write_byte( rtlpriv, 0xfe42, 0x80 );
 	rtlusb->reg_bcn_ctrl_val = 0x18;
-	rtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlusb->reg_bcn_ctrl_val);
+	rtl_write_byte( rtlpriv, REG_BCN_CTRL, ( u8 )rtlusb->reg_bcn_ctrl_val );
 }
 
-static void _InitPABias(struct ieee80211_hw *hw)
+static void _InitPABias( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u8 pa_setting;
 
 	/* FIXED PA current issue */
-	pa_setting = efuse_read_1byte(hw, 0x1FA);
-	if (!(pa_setting & BIT(0))) {
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x0F406);
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x4F406);
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x8F406);
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0xCF406);
+	pa_setting = efuse_read_1byte( hw, 0x1FA );
+	if ( !( pa_setting & BIT( 0 ) ) ) {
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x0F406 );
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x4F406 );
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x8F406 );
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0xCF406 );
 	}
-	if (!(pa_setting & BIT(1)) && IS_NORMAL_CHIP(rtlhal->version) &&
-	    IS_92C_SERIAL(rtlhal->version)) {
-		rtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x0F406);
-		rtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x4F406);
-		rtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x8F406);
-		rtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0xCF406);
+	if ( !( pa_setting & BIT( 1 ) ) && IS_NORMAL_CHIP( rtlhal->version ) &&
+	    IS_92C_SERIAL( rtlhal->version ) ) {
+		rtl_set_rfreg( hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x0F406 );
+		rtl_set_rfreg( hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x4F406 );
+		rtl_set_rfreg( hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x8F406 );
+		rtl_set_rfreg( hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0xCF406 );
 	}
-	if (!(pa_setting & BIT(4))) {
-		pa_setting = rtl_read_byte(rtlpriv, 0x16);
+	if ( !( pa_setting & BIT( 4 ) ) ) {
+		pa_setting = rtl_read_byte( rtlpriv, 0x16 );
 		pa_setting &= 0x0F;
-		rtl_write_byte(rtlpriv, 0x16, pa_setting | 0x90);
+		rtl_write_byte( rtlpriv, 0x16, pa_setting | 0x90 );
 	}
 }
 
-static void _update_mac_setting(struct ieee80211_hw *hw)
+static void _update_mac_setting( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 
-	mac->rx_conf = rtl_read_dword(rtlpriv, REG_RCR);
-	mac->rx_mgt_filter = rtl_read_word(rtlpriv, REG_RXFLTMAP0);
-	mac->rx_ctrl_filter = rtl_read_word(rtlpriv, REG_RXFLTMAP1);
-	mac->rx_data_filter = rtl_read_word(rtlpriv, REG_RXFLTMAP2);
+	mac->rx_conf = rtl_read_dword( rtlpriv, REG_RCR );
+	mac->rx_mgt_filter = rtl_read_word( rtlpriv, REG_RXFLTMAP0 );
+	mac->rx_ctrl_filter = rtl_read_word( rtlpriv, REG_RXFLTMAP1 );
+	mac->rx_data_filter = rtl_read_word( rtlpriv, REG_RXFLTMAP2 );
 }
 
-int rtl92cu_hw_init(struct ieee80211_hw *hw)
+int rtl92cu_hw_init( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
 	int err = 0;
 	static bool iqk_initialized;
 	unsigned long flags;
 
-	/* As this function can take a very long time (up to 350 ms)
+	/* As this function can take a very long time ( up to 350 ms )
 	 * and can be called with irqs disabled, reenable the irqs
 	 * to let the other devices continue being serviced.
 	 *
 	 * It is safe doing so since our own interrupts will only be enabled
 	 * in a subsequent step.
 	 */
-	local_save_flags(flags);
+	local_save_flags( flags );
 	local_irq_enable();
 
 	rtlhal->hw_type = HARDWARE_TYPE_RTL8192CU;
-	err = _rtl92cu_init_mac(hw);
-	if (err) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "init mac failed!\n");
+	err = _rtl92cu_init_mac( hw );
+	if ( err ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG, "init mac failed!\n" );
 		goto exit;
 	}
-	err = rtl92c_download_fw(hw);
-	if (err) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
-			 "Failed to download FW. Init HW without FW now..\n");
+	err = rtl92c_download_fw( hw );
+	if ( err ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
+			 "Failed to download FW. Init HW without FW now..\n" );
 		err = 1;
 		goto exit;
 	}
 	rtlhal->last_hmeboxnum = 0; /* h2c */
-	_rtl92cu_phy_param_tab_init(hw);
-	rtl92cu_phy_mac_config(hw);
-	rtl92cu_phy_bb_config(hw);
+	_rtl92cu_phy_param_tab_init( hw );
+	rtl92cu_phy_mac_config( hw );
+	rtl92cu_phy_bb_config( hw );
 	rtlphy->rf_mode = RF_OP_BY_SW_3WIRE;
-	rtl92c_phy_rf_config(hw);
-	if (IS_VENDOR_UMC_A_CUT(rtlhal->version) &&
-	    !IS_92C_SERIAL(rtlhal->version)) {
-		rtl_set_rfreg(hw, RF90_PATH_A, RF_RX_G1, MASKDWORD, 0x30255);
-		rtl_set_rfreg(hw, RF90_PATH_A, RF_RX_G2, MASKDWORD, 0x50a00);
+	rtl92c_phy_rf_config( hw );
+	if ( IS_VENDOR_UMC_A_CUT( rtlhal->version ) &&
+	    !IS_92C_SERIAL( rtlhal->version ) ) {
+		rtl_set_rfreg( hw, RF90_PATH_A, RF_RX_G1, MASKDWORD, 0x30255 );
+		rtl_set_rfreg( hw, RF90_PATH_A, RF_RX_G2, MASKDWORD, 0x50a00 );
 	}
-	rtlphy->rfreg_chnlval[0] = rtl_get_rfreg(hw, (enum radio_path)0,
-						 RF_CHNLBW, RFREG_OFFSET_MASK);
-	rtlphy->rfreg_chnlval[1] = rtl_get_rfreg(hw, (enum radio_path)1,
-						 RF_CHNLBW, RFREG_OFFSET_MASK);
-	rtl92cu_bb_block_on(hw);
-	rtl_cam_reset_all_entry(hw);
-	rtl92cu_enable_hw_security_config(hw);
+	rtlphy->rfreg_chnlval[0] = rtl_get_rfreg( hw, ( enum radio_path )0,
+						 RF_CHNLBW, RFREG_OFFSET_MASK );
+	rtlphy->rfreg_chnlval[1] = rtl_get_rfreg( hw, ( enum radio_path )1,
+						 RF_CHNLBW, RFREG_OFFSET_MASK );
+	rtl92cu_bb_block_on( hw );
+	rtl_cam_reset_all_entry( hw );
+	rtl92cu_enable_hw_security_config( hw );
 	ppsc->rfpwr_state = ERFON;
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);
-	if (ppsc->rfpwr_state == ERFON) {
-		rtl92c_phy_set_rfpath_switch(hw, 1);
-		if (iqk_initialized) {
-			rtl92c_phy_iq_calibrate(hw, true);
+	rtlpriv->cfg->ops->set_hw_reg( hw, HW_VAR_ETHER_ADDR, mac->mac_addr );
+	if ( ppsc->rfpwr_state == ERFON ) {
+		rtl92c_phy_set_rfpath_switch( hw, 1 );
+		if ( iqk_initialized ) {
+			rtl92c_phy_iq_calibrate( hw, true );
 		} else {
-			rtl92c_phy_iq_calibrate(hw, false);
+			rtl92c_phy_iq_calibrate( hw, false );
 			iqk_initialized = true;
 		}
-		rtl92c_dm_check_txpower_tracking(hw);
-		rtl92c_phy_lc_calibrate(hw);
+		rtl92c_dm_check_txpower_tracking( hw );
+		rtl92c_phy_lc_calibrate( hw );
 	}
-	_rtl92cu_hw_configure(hw);
-	_InitPABias(hw);
-	_update_mac_setting(hw);
-	rtl92c_dm_init(hw);
+	_rtl92cu_hw_configure( hw );
+	_InitPABias( hw );
+	_update_mac_setting( hw );
+	rtl92c_dm_init( hw );
 exit:
-	local_irq_restore(flags);
+	local_irq_restore( flags );
 	return err;
 }
 
-static void _DisableRFAFEAndResetBB(struct ieee80211_hw *hw)
+static void _DisableRFAFEAndResetBB( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 /**************************************
 a.	TXPAUSE 0x522[7:0] = 0xFF	Pause MAC TX queue
 b.	RF path 0 offset 0x00 = 0x00	disable RF
@@ -1064,71 +1071,71 @@ d.	SYS_FUNC_EN 0x02[7:0] = 0x16	reset BB state machine
 e.	SYS_FUNC_EN 0x02[7:0] = 0x14	reset BB state machine
 ***************************************/
 	u8 eRFPath = 0, value8 = 0;
-	rtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);
-	rtl_set_rfreg(hw, (enum radio_path)eRFPath, 0x0, MASKBYTE0, 0x0);
+	rtl_write_byte( rtlpriv, REG_TXPAUSE, 0xFF );
+	rtl_set_rfreg( hw, ( enum radio_path )eRFPath, 0x0, MASKBYTE0, 0x0 );
 
 	value8 |= APSDOFF;
-	rtl_write_byte(rtlpriv, REG_APSD_CTRL, value8); /*0x40*/
+	rtl_write_byte( rtlpriv, REG_APSD_CTRL, value8 ); /*0x40*/
 	value8 = 0;
-	value8 |= (FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, value8);/*0x16*/
-	value8 &= (~FEN_BB_GLB_RSTn);
-	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, value8); /*0x14*/
+	value8 |= ( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn );
+	rtl_write_byte( rtlpriv, REG_SYS_FUNC_EN, value8 );/*0x16*/
+	value8 &= ( ~FEN_BB_GLB_RSTn );
+	rtl_write_byte( rtlpriv, REG_SYS_FUNC_EN, value8 ); /*0x14*/
 }
 
-static void  _ResetDigitalProcedure1(struct ieee80211_hw *hw, bool bWithoutHWSM)
+static void  _ResetDigitalProcedure1( struct ieee80211_hw *hw, bool bWithoutHWSM )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 
-	if (rtlhal->fw_version <=  0x20) {
+	if ( rtlhal->fw_version <=  0x20 ) {
 		/*****************************
 		f. MCUFWDL 0x80[7:0]=0		reset MCU ready status
-		g. SYS_FUNC_EN 0x02[10]= 0	reset MCU reg, (8051 reset)
+		g. SYS_FUNC_EN 0x02[10]= 0	reset MCU reg, ( 8051 reset )
 		h. SYS_FUNC_EN 0x02[15-12]= 5	reset MAC reg, DCORE
-		i. SYS_FUNC_EN 0x02[10]= 1	enable MCU reg, (8051 enable)
+		i. SYS_FUNC_EN 0x02[10]= 1	enable MCU reg, ( 8051 enable )
 		******************************/
 		u16 valu16 = 0;
 
-		rtl_write_byte(rtlpriv, REG_MCUFWDL, 0);
-		valu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);
-		rtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 &
-			       (~FEN_CPUEN))); /* reset MCU ,8051 */
-		valu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN)&0x0FFF;
-		rtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 |
-			      (FEN_HWPDN|FEN_ELDR))); /* reset MAC */
-		valu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);
-		rtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 |
-			       FEN_CPUEN)); /* enable MCU ,8051 */
+		rtl_write_byte( rtlpriv, REG_MCUFWDL, 0 );
+		valu16 = rtl_read_word( rtlpriv, REG_SYS_FUNC_EN );
+		rtl_write_word( rtlpriv, REG_SYS_FUNC_EN, ( valu16 &
+			       ( ~FEN_CPUEN ) ) ); /* reset MCU ,8051 */
+		valu16 = rtl_read_word( rtlpriv, REG_SYS_FUNC_EN )&0x0FFF;
+		rtl_write_word( rtlpriv, REG_SYS_FUNC_EN, ( valu16 |
+			      ( FEN_HWPDN|FEN_ELDR ) ) ); /* reset MAC */
+		valu16 = rtl_read_word( rtlpriv, REG_SYS_FUNC_EN );
+		rtl_write_word( rtlpriv, REG_SYS_FUNC_EN, ( valu16 |
+			       FEN_CPUEN ) ); /* enable MCU ,8051 */
 	} else {
 		u8 retry_cnts = 0;
 
 		/* IF fw in RAM code, do reset */
-		if (rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(1)) {
+		if ( rtl_read_byte( rtlpriv, REG_MCUFWDL ) & BIT( 1 ) ) {
 			/* reset MCU ready status */
-			rtl_write_byte(rtlpriv, REG_MCUFWDL, 0);
+			rtl_write_byte( rtlpriv, REG_MCUFWDL, 0 );
 			/* 8051 reset by self */
-			rtl_write_byte(rtlpriv, REG_HMETFR+3, 0x20);
-			while ((retry_cnts++ < 100) &&
-			       (FEN_CPUEN & rtl_read_word(rtlpriv,
-			       REG_SYS_FUNC_EN))) {
-				udelay(50);
+			rtl_write_byte( rtlpriv, REG_HMETFR+3, 0x20 );
+			while ( ( retry_cnts++ < 100 ) &&
+			       ( FEN_CPUEN & rtl_read_word( rtlpriv,
+			       REG_SYS_FUNC_EN ) ) ) {
+				udelay( 50 );
 			}
-			if (retry_cnts >= 100) {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-					 "#####=> 8051 reset failed!.........................\n");
+			if ( retry_cnts >= 100 ) {
+				RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+					 "#####=> 8051 reset failed!.........................\n" );
 				/* if 8051 reset fail, reset MAC. */
-				rtl_write_byte(rtlpriv,
+				rtl_write_byte( rtlpriv,
 					       REG_SYS_FUNC_EN + 1,
-					       0x50);
-				udelay(100);
+					       0x50 );
+				udelay( 100 );
 			}
 		}
 		/* Reset MAC and Enable 8051 */
-		rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, 0x54);
-		rtl_write_byte(rtlpriv, REG_MCUFWDL, 0);
+		rtl_write_byte( rtlpriv, REG_SYS_FUNC_EN + 1, 0x54 );
+		rtl_write_byte( rtlpriv, REG_MCUFWDL, 0 );
 	}
-	if (bWithoutHWSM) {
+	if ( bWithoutHWSM ) {
 		/*****************************
 		  Without HW auto state machine
 		g.SYS_CLKR 0x08[15:0] = 0x30A3		disable MAC clock
@@ -1136,32 +1143,32 @@ static void  _ResetDigitalProcedure1(struct ieee80211_hw *hw, bool bWithoutHWSM)
 		i.AFE_XTAL_CTRL 0x24[15:0] = 0x880F	gated AFE DIG_CLOCK
 		j.SYS_ISu_CTRL 0x00[7:0] = 0xF9		isolated digital to PON
 		******************************/
-		rtl_write_word(rtlpriv, REG_SYS_CLKR, 0x70A3);
-		rtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x80);
-		rtl_write_word(rtlpriv, REG_AFE_XTAL_CTRL, 0x880F);
-		rtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, 0xF9);
+		rtl_write_word( rtlpriv, REG_SYS_CLKR, 0x70A3 );
+		rtl_write_byte( rtlpriv, REG_AFE_PLL_CTRL, 0x80 );
+		rtl_write_word( rtlpriv, REG_AFE_XTAL_CTRL, 0x880F );
+		rtl_write_byte( rtlpriv, REG_SYS_ISO_CTRL, 0xF9 );
 	}
 }
 
-static void _ResetDigitalProcedure2(struct ieee80211_hw *hw)
+static void _ResetDigitalProcedure2( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 /*****************************
 k. SYS_FUNC_EN 0x03[7:0] = 0x44		disable ELDR runction
 l. SYS_CLKR 0x08[15:0] = 0x3083		disable ELDR clock
 m. SYS_ISO_CTRL 0x01[7:0] = 0x83	isolated ELDR to PON
 ******************************/
-	rtl_write_word(rtlpriv, REG_SYS_CLKR, 0x70A3);
-	rtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL+1, 0x82);
+	rtl_write_word( rtlpriv, REG_SYS_CLKR, 0x70A3 );
+	rtl_write_byte( rtlpriv, REG_SYS_ISO_CTRL+1, 0x82 );
 }
 
-static void _DisableGPIO(struct ieee80211_hw *hw)
+static void _DisableGPIO( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 /***************************************
 j. GPIO_PIN_CTRL 0x44[31:0]=0x000
 k. Value = GPIO_PIN_CTRL[7:0]
-l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); write ext PIN level
+l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | ( value <<8 ); write ext PIN level
 m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
 n. LEDCFG 0x4C[15:0] = 0x8080
 ***************************************/
@@ -1170,327 +1177,327 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	u32	value32;
 
 	/* 1. Disable GPIO[7:0] */
-	rtl_write_word(rtlpriv, REG_GPIO_PIN_CTRL+2, 0x0000);
-	value32 = rtl_read_dword(rtlpriv, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
-	value8 = (u8)(value32&0x000000FF);
-	value32 |= ((value8<<8) | 0x00FF0000);
-	rtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, value32);
+	rtl_write_word( rtlpriv, REG_GPIO_PIN_CTRL+2, 0x0000 );
+	value32 = rtl_read_dword( rtlpriv, REG_GPIO_PIN_CTRL ) & 0xFFFF00FF;
+	value8 = ( u8 )( value32&0x000000FF );
+	value32 |= ( ( value8<<8 ) | 0x00FF0000 );
+	rtl_write_dword( rtlpriv, REG_GPIO_PIN_CTRL, value32 );
 	/* 2. Disable GPIO[10:8] */
-	rtl_write_byte(rtlpriv, REG_GPIO_MUXCFG+3, 0x00);
-	value16 = rtl_read_word(rtlpriv, REG_GPIO_MUXCFG+2) & 0xFF0F;
-	value8 = (u8)(value16&0x000F);
-	value16 |= ((value8<<4) | 0x0780);
-	rtl_write_word(rtlpriv, REG_GPIO_PIN_CTRL+2, value16);
+	rtl_write_byte( rtlpriv, REG_GPIO_MUXCFG+3, 0x00 );
+	value16 = rtl_read_word( rtlpriv, REG_GPIO_MUXCFG+2 ) & 0xFF0F;
+	value8 = ( u8 )( value16&0x000F );
+	value16 |= ( ( value8<<4 ) | 0x0780 );
+	rtl_write_word( rtlpriv, REG_GPIO_PIN_CTRL+2, value16 );
 	/* 3. Disable LED0 & 1 */
-	rtl_write_word(rtlpriv, REG_LEDCFG0, 0x8080);
+	rtl_write_word( rtlpriv, REG_LEDCFG0, 0x8080 );
 }
 
-static void _DisableAnalog(struct ieee80211_hw *hw, bool bWithoutHWSM)
+static void _DisableAnalog( struct ieee80211_hw *hw, bool bWithoutHWSM )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u16 value16 = 0;
 	u8 value8 = 0;
 
-	if (bWithoutHWSM) {
+	if ( bWithoutHWSM ) {
 		/*****************************
 		n. LDOA15_CTRL 0x20[7:0] = 0x04	 disable A15 power
 		o. LDOV12D_CTRL 0x21[7:0] = 0x54 disable digital core power
 		r. When driver call disable, the ASIC will turn off remaining
 		   clock automatically
 		******************************/
-		rtl_write_byte(rtlpriv, REG_LDOA15_CTRL, 0x04);
-		value8 = rtl_read_byte(rtlpriv, REG_LDOV12D_CTRL);
-		value8 &= (~LDV12_EN);
-		rtl_write_byte(rtlpriv, REG_LDOV12D_CTRL, value8);
+		rtl_write_byte( rtlpriv, REG_LDOA15_CTRL, 0x04 );
+		value8 = rtl_read_byte( rtlpriv, REG_LDOV12D_CTRL );
+		value8 &= ( ~LDV12_EN );
+		rtl_write_byte( rtlpriv, REG_LDOV12D_CTRL, value8 );
 	}
 
 /*****************************
 h. SPS0_CTRL 0x11[7:0] = 0x23		enter PFM mode
 i. APS_FSMCO 0x04[15:0] = 0x4802	set USB suspend
 ******************************/
-	rtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x23);
-	value16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);
-	rtl_write_word(rtlpriv, REG_APS_FSMCO, (u16)value16);
-	rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0E);
+	rtl_write_byte( rtlpriv, REG_SPS0_CTRL, 0x23 );
+	value16 |= ( APDM_HOST | AFSM_HSUS | PFM_ALDN );
+	rtl_write_word( rtlpriv, REG_APS_FSMCO, ( u16 )value16 );
+	rtl_write_byte( rtlpriv, REG_RSV_CTRL, 0x0E );
 }
 
-static void _CardDisableHWSM(struct ieee80211_hw *hw)
+static void _CardDisableHWSM( struct ieee80211_hw *hw )
 {
 	/* ==== RF Off Sequence ==== */
-	_DisableRFAFEAndResetBB(hw);
+	_DisableRFAFEAndResetBB( hw );
 	/* ==== Reset digital sequence   ====== */
-	_ResetDigitalProcedure1(hw, false);
+	_ResetDigitalProcedure1( hw, false );
 	/*  ==== Pull GPIO PIN to balance level and LED control ====== */
-	_DisableGPIO(hw);
+	_DisableGPIO( hw );
 	/* ==== Disable analog sequence === */
-	_DisableAnalog(hw, false);
+	_DisableAnalog( hw, false );
 }
 
-static void _CardDisableWithoutHWSM(struct ieee80211_hw *hw)
+static void _CardDisableWithoutHWSM( struct ieee80211_hw *hw )
 {
 	/*==== RF Off Sequence ==== */
-	_DisableRFAFEAndResetBB(hw);
+	_DisableRFAFEAndResetBB( hw );
 	/*  ==== Reset digital sequence   ====== */
-	_ResetDigitalProcedure1(hw, true);
+	_ResetDigitalProcedure1( hw, true );
 	/*  ==== Pull GPIO PIN to balance level and LED control ====== */
-	_DisableGPIO(hw);
+	_DisableGPIO( hw );
 	/*  ==== Reset digital sequence   ====== */
-	_ResetDigitalProcedure2(hw);
+	_ResetDigitalProcedure2( hw );
 	/*  ==== Disable analog sequence === */
-	_DisableAnalog(hw, true);
+	_DisableAnalog( hw, true );
 }
 
-static void _rtl92cu_set_bcn_ctrl_reg(struct ieee80211_hw *hw,
-				      u8 set_bits, u8 clear_bits)
+static void _rtl92cu_set_bcn_ctrl_reg( struct ieee80211_hw *hw,
+				      u8 set_bits, u8 clear_bits )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( rtl_usbpriv( hw ) );
 
 	rtlusb->reg_bcn_ctrl_val |= set_bits;
 	rtlusb->reg_bcn_ctrl_val &= ~clear_bits;
-	rtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlusb->reg_bcn_ctrl_val);
+	rtl_write_byte( rtlpriv, REG_BCN_CTRL, ( u8 )rtlusb->reg_bcn_ctrl_val );
 }
 
-static void _rtl92cu_stop_tx_beacon(struct ieee80211_hw *hw)
+static void _rtl92cu_stop_tx_beacon( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 	u8 tmp1byte = 0;
-	if (IS_NORMAL_CHIP(rtlhal->version)) {
-		tmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);
-		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,
-			       tmp1byte & (~BIT(6)));
-		rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);
-		tmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);
-		tmp1byte &= ~(BIT(0));
-		rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);
+	if ( IS_NORMAL_CHIP( rtlhal->version ) ) {
+		tmp1byte = rtl_read_byte( rtlpriv, REG_FWHW_TXQ_CTRL + 2 );
+		rtl_write_byte( rtlpriv, REG_FWHW_TXQ_CTRL + 2,
+			       tmp1byte & ( ~BIT( 6 ) ) );
+		rtl_write_byte( rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64 );
+		tmp1byte = rtl_read_byte( rtlpriv, REG_TBTT_PROHIBIT + 2 );
+		tmp1byte &= ~( BIT( 0 ) );
+		rtl_write_byte( rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte );
 	} else {
-		rtl_write_byte(rtlpriv, REG_TXPAUSE,
-			       rtl_read_byte(rtlpriv, REG_TXPAUSE) | BIT(6));
+		rtl_write_byte( rtlpriv, REG_TXPAUSE,
+			       rtl_read_byte( rtlpriv, REG_TXPAUSE ) | BIT( 6 ) );
 	}
 }
 
-static void _rtl92cu_resume_tx_beacon(struct ieee80211_hw *hw)
+static void _rtl92cu_resume_tx_beacon( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 	u8 tmp1byte = 0;
 
-	if (IS_NORMAL_CHIP(rtlhal->version)) {
-		tmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);
-		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,
-			       tmp1byte | BIT(6));
-		rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);
-		tmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);
-		tmp1byte |= BIT(0);
-		rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);
+	if ( IS_NORMAL_CHIP( rtlhal->version ) ) {
+		tmp1byte = rtl_read_byte( rtlpriv, REG_FWHW_TXQ_CTRL + 2 );
+		rtl_write_byte( rtlpriv, REG_FWHW_TXQ_CTRL + 2,
+			       tmp1byte | BIT( 6 ) );
+		rtl_write_byte( rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff );
+		tmp1byte = rtl_read_byte( rtlpriv, REG_TBTT_PROHIBIT + 2 );
+		tmp1byte |= BIT( 0 );
+		rtl_write_byte( rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte );
 	} else {
-		rtl_write_byte(rtlpriv, REG_TXPAUSE,
-			       rtl_read_byte(rtlpriv, REG_TXPAUSE) & (~BIT(6)));
+		rtl_write_byte( rtlpriv, REG_TXPAUSE,
+			       rtl_read_byte( rtlpriv, REG_TXPAUSE ) & ( ~BIT( 6 ) ) );
 	}
 }
 
-static void _rtl92cu_enable_bcn_sub_func(struct ieee80211_hw *hw)
+static void _rtl92cu_enable_bcn_sub_func( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(1));
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		_rtl92cu_set_bcn_ctrl_reg( hw, 0, BIT( 1 ) );
 	else
-		_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(4));
+		_rtl92cu_set_bcn_ctrl_reg( hw, 0, BIT( 4 ) );
 }
 
-static void _rtl92cu_disable_bcn_sub_func(struct ieee80211_hw *hw)
+static void _rtl92cu_disable_bcn_sub_func( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		_rtl92cu_set_bcn_ctrl_reg(hw, BIT(1), 0);
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		_rtl92cu_set_bcn_ctrl_reg( hw, BIT( 1 ), 0 );
 	else
-		_rtl92cu_set_bcn_ctrl_reg(hw, BIT(4), 0);
+		_rtl92cu_set_bcn_ctrl_reg( hw, BIT( 4 ), 0 );
 }
 
-static int _rtl92cu_set_media_status(struct ieee80211_hw *hw,
-				     enum nl80211_iftype type)
+static int _rtl92cu_set_media_status( struct ieee80211_hw *hw,
+				     enum nl80211_iftype type )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	u8 bt_msr = rtl_read_byte(rtlpriv, MSR);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	u8 bt_msr = rtl_read_byte( rtlpriv, MSR );
 	enum led_ctl_mode ledaction = LED_CTL_NO_LINK;
 
 	bt_msr &= 0xfc;
-	rtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xFF);
-	if (type == NL80211_IFTYPE_UNSPECIFIED || type ==
-	    NL80211_IFTYPE_STATION) {
-		_rtl92cu_stop_tx_beacon(hw);
-		_rtl92cu_enable_bcn_sub_func(hw);
-	} else if (type == NL80211_IFTYPE_ADHOC || type == NL80211_IFTYPE_AP) {
-		_rtl92cu_resume_tx_beacon(hw);
-		_rtl92cu_disable_bcn_sub_func(hw);
+	rtl_write_byte( rtlpriv, REG_BCN_MAX_ERR, 0xFF );
+	if ( type == NL80211_IFTYPE_UNSPECIFIED || type ==
+	    NL80211_IFTYPE_STATION ) {
+		_rtl92cu_stop_tx_beacon( hw );
+		_rtl92cu_enable_bcn_sub_func( hw );
+	} else if ( type == NL80211_IFTYPE_ADHOC || type == NL80211_IFTYPE_AP ) {
+		_rtl92cu_resume_tx_beacon( hw );
+		_rtl92cu_disable_bcn_sub_func( hw );
 	} else {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 			 "Set HW_VAR_MEDIA_STATUS:No such media status(%x)\n",
-			 type);
+			 type );
 	}
-	switch (type) {
+	switch ( type ) {
 	case NL80211_IFTYPE_UNSPECIFIED:
 		bt_msr |= MSR_NOLINK;
 		ledaction = LED_CTL_LINK;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Set Network type to NO LINK!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Set Network type to NO LINK!\n" );
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		bt_msr |= MSR_ADHOC;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Set Network type to Ad Hoc!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Set Network type to Ad Hoc!\n" );
 		break;
 	case NL80211_IFTYPE_STATION:
 		bt_msr |= MSR_INFRA;
 		ledaction = LED_CTL_LINK;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Set Network type to STA!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Set Network type to STA!\n" );
 		break;
 	case NL80211_IFTYPE_AP:
 		bt_msr |= MSR_AP;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Set Network type to AP!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Set Network type to AP!\n" );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "Network type %d not supported!\n", type);
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "Network type %d not supported!\n", type );
 		goto error_out;
 	}
-	rtl_write_byte(rtlpriv, (MSR), bt_msr);
-	rtlpriv->cfg->ops->led_control(hw, ledaction);
-	if ((bt_msr & MSR_MASK) == MSR_AP)
-		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);
+	rtl_write_byte( rtlpriv, ( MSR ), bt_msr );
+	rtlpriv->cfg->ops->led_control( hw, ledaction );
+	if ( ( bt_msr & MSR_MASK ) == MSR_AP )
+		rtl_write_byte( rtlpriv, REG_BCNTCFG + 1, 0x00 );
 	else
-		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);
+		rtl_write_byte( rtlpriv, REG_BCNTCFG + 1, 0x66 );
 	return 0;
 error_out:
 	return 1;
 }
 
-void rtl92cu_card_disable(struct ieee80211_hw *hw)
+void rtl92cu_card_disable( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
+	struct rtl_usb *rtlusb = rtl_usbdev( rtl_usbpriv( hw ) );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	enum nl80211_iftype opmode;
 
 	mac->link_state = MAC80211_NOLINK;
 	opmode = NL80211_IFTYPE_UNSPECIFIED;
-	_rtl92cu_set_media_status(hw, opmode);
-	rtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);
-	RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
-	if (rtlusb->disableHWSM)
-		_CardDisableHWSM(hw);
+	_rtl92cu_set_media_status( hw, opmode );
+	rtlpriv->cfg->ops->led_control( hw, LED_CTL_POWER_OFF );
+	RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_HALT_NIC );
+	if ( rtlusb->disableHWSM )
+		_CardDisableHWSM( hw );
 	else
-		_CardDisableWithoutHWSM(hw);
+		_CardDisableWithoutHWSM( hw );
 }
 
-void rtl92cu_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)
+void rtl92cu_set_check_bssid( struct ieee80211_hw *hw, bool check_bssid )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 	u32 reg_rcr;
 
-	if (rtlpriv->psc.rfpwr_state != ERFON)
+	if ( rtlpriv->psc.rfpwr_state != ERFON )
 		return;
 
-	rtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));
+	rtlpriv->cfg->ops->get_hw_reg( hw, HW_VAR_RCR, ( u8 * )( &reg_rcr ) );
 
-	if (check_bssid) {
+	if ( check_bssid ) {
 		u8 tmp;
-		if (IS_NORMAL_CHIP(rtlhal->version)) {
-			reg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);
-			tmp = BIT(4);
+		if ( IS_NORMAL_CHIP( rtlhal->version ) ) {
+			reg_rcr |= ( RCR_CBSSID_DATA | RCR_CBSSID_BCN );
+			tmp = BIT( 4 );
 		} else {
 			reg_rcr |= RCR_CBSSID;
-			tmp = BIT(4) | BIT(5);
+			tmp = BIT( 4 ) | BIT( 5 );
 		}
-		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,
-					      (u8 *) (&reg_rcr));
-		_rtl92cu_set_bcn_ctrl_reg(hw, 0, tmp);
+		rtlpriv->cfg->ops->set_hw_reg( hw, HW_VAR_RCR,
+					      ( u8 * ) ( &reg_rcr ) );
+		_rtl92cu_set_bcn_ctrl_reg( hw, 0, tmp );
 	} else {
 		u8 tmp;
-		if (IS_NORMAL_CHIP(rtlhal->version)) {
-			reg_rcr &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
-			tmp = BIT(4);
+		if ( IS_NORMAL_CHIP( rtlhal->version ) ) {
+			reg_rcr &= ~( RCR_CBSSID_DATA | RCR_CBSSID_BCN );
+			tmp = BIT( 4 );
 		} else {
 			reg_rcr &= ~RCR_CBSSID;
-			tmp = BIT(4) | BIT(5);
+			tmp = BIT( 4 ) | BIT( 5 );
 		}
-		reg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));
-		rtlpriv->cfg->ops->set_hw_reg(hw,
-					      HW_VAR_RCR, (u8 *) (&reg_rcr));
-		_rtl92cu_set_bcn_ctrl_reg(hw, tmp, 0);
+		reg_rcr &= ( ~( RCR_CBSSID_DATA | RCR_CBSSID_BCN ) );
+		rtlpriv->cfg->ops->set_hw_reg( hw,
+					      HW_VAR_RCR, ( u8 * ) ( &reg_rcr ) );
+		_rtl92cu_set_bcn_ctrl_reg( hw, tmp, 0 );
 	}
 }
 
 /*========================================================================== */
 
-int rtl92cu_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)
+int rtl92cu_set_network_type( struct ieee80211_hw *hw, enum nl80211_iftype type )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (_rtl92cu_set_media_status(hw, type))
+	if ( _rtl92cu_set_media_status( hw, type ) )
 		return -EOPNOTSUPP;
 
-	if (rtlpriv->mac80211.link_state == MAC80211_LINKED) {
-		if (type != NL80211_IFTYPE_AP)
-			rtl92cu_set_check_bssid(hw, true);
+	if ( rtlpriv->mac80211.link_state == MAC80211_LINKED ) {
+		if ( type != NL80211_IFTYPE_AP )
+			rtl92cu_set_check_bssid( hw, true );
 	} else {
-		rtl92cu_set_check_bssid(hw, false);
+		rtl92cu_set_check_bssid( hw, false );
 	}
 
 	return 0;
 }
 
-static void _InitBeaconParameters(struct ieee80211_hw *hw)
+static void _InitBeaconParameters( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 
-	rtl_write_word(rtlpriv, REG_BCN_CTRL, 0x1010);
+	rtl_write_word( rtlpriv, REG_BCN_CTRL, 0x1010 );
 
 	/* TODO: Remove these magic number */
-	rtl_write_word(rtlpriv, REG_TBTT_PROHIBIT, 0x6404);
-	rtl_write_byte(rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);
-	rtl_write_byte(rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);
+	rtl_write_word( rtlpriv, REG_TBTT_PROHIBIT, 0x6404 );
+	rtl_write_byte( rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME );
+	rtl_write_byte( rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME );
 	/* Change beacon AIFS to the largest number
 	 * beacause test chip does not contension before sending beacon. */
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		rtl_write_word(rtlpriv, REG_BCNTCFG, 0x660F);
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		rtl_write_word( rtlpriv, REG_BCNTCFG, 0x660F );
 	else
-		rtl_write_word(rtlpriv, REG_BCNTCFG, 0x66FF);
+		rtl_write_word( rtlpriv, REG_BCNTCFG, 0x66FF );
 }
 
-static void _beacon_function_enable(struct ieee80211_hw *hw, bool Enable,
-				    bool Linked)
+static void _beacon_function_enable( struct ieee80211_hw *hw, bool Enable,
+				    bool Linked )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	_rtl92cu_set_bcn_ctrl_reg(hw, (BIT(4) | BIT(3) | BIT(1)), 0x00);
-	rtl_write_byte(rtlpriv, REG_RD_CTRL+1, 0x6F);
+	_rtl92cu_set_bcn_ctrl_reg( hw, ( BIT( 4 ) | BIT( 3 ) | BIT( 1 ) ), 0x00 );
+	rtl_write_byte( rtlpriv, REG_RD_CTRL+1, 0x6F );
 }
 
-void rtl92cu_set_beacon_related_registers(struct ieee80211_hw *hw)
+void rtl92cu_set_beacon_related_registers( struct ieee80211_hw *hw )
 {
 
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	u16 bcn_interval, atim_window;
 	u32 value32;
 
 	bcn_interval = mac->beacon_interval;
 	atim_window = 2;	/*FIX MERGE */
-	rtl_write_word(rtlpriv, REG_ATIMWND, atim_window);
-	rtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);
-	_InitBeaconParameters(hw);
-	rtl_write_byte(rtlpriv, REG_SLOT, 0x09);
+	rtl_write_word( rtlpriv, REG_ATIMWND, atim_window );
+	rtl_write_word( rtlpriv, REG_BCN_INTERVAL, bcn_interval );
+	_InitBeaconParameters( hw );
+	rtl_write_byte( rtlpriv, REG_SLOT, 0x09 );
 	/*
 	 * Force beacon frame transmission even after receiving beacon frame
 	 * from other ad hoc STA
@@ -1498,101 +1505,101 @@ void rtl92cu_set_beacon_related_registers(struct ieee80211_hw *hw)
 	 *
 	 * Reset TSF Timer to zero, added by Roger. 2008.06.24
 	 */
-	value32 = rtl_read_dword(rtlpriv, REG_TCR);
+	value32 = rtl_read_dword( rtlpriv, REG_TCR );
 	value32 &= ~TSFRST;
-	rtl_write_dword(rtlpriv, REG_TCR, value32);
+	rtl_write_dword( rtlpriv, REG_TCR, value32 );
 	value32 |= TSFRST;
-	rtl_write_dword(rtlpriv, REG_TCR, value32);
-	RT_TRACE(rtlpriv, COMP_INIT|COMP_BEACON, DBG_LOUD,
+	rtl_write_dword( rtlpriv, REG_TCR, value32 );
+	RT_TRACE( rtlpriv, COMP_INIT|COMP_BEACON, DBG_LOUD,
 		 "SetBeaconRelatedRegisters8192CUsb(): Set TCR(%x)\n",
-		 value32);
-	/* TODO: Modify later (Find the right parameters)
-	 * NOTE: Fix test chip's bug (about contention windows's randomness) */
-	if ((mac->opmode == NL80211_IFTYPE_ADHOC) ||
-	    (mac->opmode == NL80211_IFTYPE_AP)) {
-		rtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x50);
-		rtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x50);
+		 value32 );
+	/* TODO: Modify later ( Find the right parameters )
+	 * NOTE: Fix test chip's bug ( about contention windows's randomness ) */
+	if ( ( mac->opmode == NL80211_IFTYPE_ADHOC ) ||
+	    ( mac->opmode == NL80211_IFTYPE_AP ) ) {
+		rtl_write_byte( rtlpriv, REG_RXTSF_OFFSET_CCK, 0x50 );
+		rtl_write_byte( rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x50 );
 	}
-	_beacon_function_enable(hw, true, true);
+	_beacon_function_enable( hw, true, true );
 }
 
-void rtl92cu_set_beacon_interval(struct ieee80211_hw *hw)
+void rtl92cu_set_beacon_interval( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	u16 bcn_interval = mac->beacon_interval;
 
-	RT_TRACE(rtlpriv, COMP_BEACON, DBG_DMESG, "beacon_interval:%d\n",
-		 bcn_interval);
-	rtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);
+	RT_TRACE( rtlpriv, COMP_BEACON, DBG_DMESG, "beacon_interval:%d\n",
+		 bcn_interval );
+	rtl_write_word( rtlpriv, REG_BCN_INTERVAL, bcn_interval );
 }
 
-void rtl92cu_update_interrupt_mask(struct ieee80211_hw *hw,
-				   u32 add_msr, u32 rm_msr)
+void rtl92cu_update_interrupt_mask( struct ieee80211_hw *hw,
+				   u32 add_msr, u32 rm_msr )
 {
 }
 
-void rtl92cu_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
+void rtl92cu_get_hw_reg( struct ieee80211_hw *hw, u8 variable, u8 *val )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 
-	switch (variable) {
+	switch ( variable ) {
 	case HW_VAR_RCR:
-		*((u32 *)(val)) = mac->rx_conf;
+		*( ( u32 * )( val ) ) = mac->rx_conf;
 		break;
 	case HW_VAR_RF_STATE:
-		*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;
+		*( ( enum rf_pwrstate * )( val ) ) = ppsc->rfpwr_state;
 		break;
 	case HW_VAR_FWLPS_RF_ON:{
 			enum rf_pwrstate rfState;
 			u32 val_rcr;
 
-			rtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE,
-						      (u8 *)(&rfState));
-			if (rfState == ERFOFF) {
-				*((bool *) (val)) = true;
+			rtlpriv->cfg->ops->get_hw_reg( hw, HW_VAR_RF_STATE,
+						      ( u8 * )( &rfState ) );
+			if ( rfState == ERFOFF ) {
+				*( ( bool * ) ( val ) ) = true;
 			} else {
-				val_rcr = rtl_read_dword(rtlpriv, REG_RCR);
+				val_rcr = rtl_read_dword( rtlpriv, REG_RCR );
 				val_rcr &= 0x00070000;
-				if (val_rcr)
-					*((bool *) (val)) = false;
+				if ( val_rcr )
+					*( ( bool * ) ( val ) ) = false;
 				else
-					*((bool *) (val)) = true;
+					*( ( bool * ) ( val ) ) = true;
 			}
 			break;
 		}
 	case HW_VAR_FW_PSMODE_STATUS:
-		*((bool *) (val)) = ppsc->fw_current_inpsmode;
+		*( ( bool * ) ( val ) ) = ppsc->fw_current_inpsmode;
 		break;
 	case HW_VAR_CORRECT_TSF:{
 			u64 tsf;
-			u32 *ptsf_low = (u32 *)&tsf;
-			u32 *ptsf_high = ((u32 *)&tsf) + 1;
+			u32 *ptsf_low = ( u32 * )&tsf;
+			u32 *ptsf_high = ( ( u32 * )&tsf ) + 1;
 
-			*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));
-			*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);
-			*((u64 *)(val)) = tsf;
+			*ptsf_high = rtl_read_dword( rtlpriv, ( REG_TSFTR + 4 ) );
+			*ptsf_low = rtl_read_dword( rtlpriv, REG_TSFTR );
+			*( ( u64 * )( val ) ) = tsf;
 			break;
 		}
 	case HW_VAR_MGT_FILTER:
-		*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP0);
+		*( ( u16 * ) ( val ) ) = rtl_read_word( rtlpriv, REG_RXFLTMAP0 );
 		break;
 	case HW_VAR_CTRL_FILTER:
-		*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP1);
+		*( ( u16 * ) ( val ) ) = rtl_read_word( rtlpriv, REG_RXFLTMAP1 );
 		break;
 	case HW_VAR_DATA_FILTER:
-		*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP2);
+		*( ( u16 * ) ( val ) ) = rtl_read_word( rtlpriv, REG_RXFLTMAP2 );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	}
 }
 
-bool usb_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb)
+bool usb_cmd_send_packet( struct ieee80211_hw *hw, struct sk_buff *skb )
 {
   /* Currently nothing happens here.
    * Traffic stops after some seconds in WPA2 802.11n mode.
@@ -1601,110 +1608,110 @@ bool usb_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb)
    * if its "here".
    *
    * This is maybe necessary:
-   * rtlpriv->cfg->ops->fill_tx_cmddesc(hw, buffer, 1, 1, skb);
+   * rtlpriv->cfg->ops->fill_tx_cmddesc( hw, buffer, 1, 1, skb );
    */
 	return true;
 }
 
-void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
+void rtl92cu_set_hw_reg( struct ieee80211_hw *hw, u8 variable, u8 *val )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
+	struct rtl_usb *rtlusb = rtl_usbdev( rtl_usbpriv( hw ) );
 	enum wireless_mode wirelessmode = mac->mode;
 	u8 idx = 0;
 
-	switch (variable) {
+	switch ( variable ) {
 	case HW_VAR_ETHER_ADDR:{
-			for (idx = 0; idx < ETH_ALEN; idx++) {
-				rtl_write_byte(rtlpriv, (REG_MACID + idx),
-					       val[idx]);
+			for ( idx = 0; idx < ETH_ALEN; idx++ ) {
+				rtl_write_byte( rtlpriv, ( REG_MACID + idx ),
+					       val[idx] );
 			}
 			break;
 		}
 	case HW_VAR_BASIC_RATE:{
-			u16 rate_cfg = ((u16 *) val)[0];
+			u16 rate_cfg = ( ( u16 * ) val )[0];
 			u8 rate_index = 0;
 
 			rate_cfg &= 0x15f;
 			/* TODO */
-			/* if (mac->current_network.vender == HT_IOT_PEER_CISCO
-			 *     && ((rate_cfg & 0x150) == 0)) {
+			/* if ( mac->current_network.vender == HT_IOT_PEER_CISCO
+			 *     && ( ( rate_cfg & 0x150 ) == 0 ) ) {
 			 *	  rate_cfg |= 0x010;
 			 * } */
 			rate_cfg |= 0x01;
-			rtl_write_byte(rtlpriv, REG_RRSR, rate_cfg & 0xff);
-			rtl_write_byte(rtlpriv, REG_RRSR + 1,
-				       (rate_cfg >> 8) & 0xff);
-			while (rate_cfg > 0x1) {
+			rtl_write_byte( rtlpriv, REG_RRSR, rate_cfg & 0xff );
+			rtl_write_byte( rtlpriv, REG_RRSR + 1,
+				       ( rate_cfg >> 8 ) & 0xff );
+			while ( rate_cfg > 0x1 ) {
 				rate_cfg >>= 1;
 				rate_index++;
 			}
-			rtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL,
-				       rate_index);
+			rtl_write_byte( rtlpriv, REG_INIRTS_RATE_SEL,
+				       rate_index );
 			break;
 		}
 	case HW_VAR_BSSID:{
-			for (idx = 0; idx < ETH_ALEN; idx++) {
-				rtl_write_byte(rtlpriv, (REG_BSSID + idx),
-					       val[idx]);
+			for ( idx = 0; idx < ETH_ALEN; idx++ ) {
+				rtl_write_byte( rtlpriv, ( REG_BSSID + idx ),
+					       val[idx] );
 			}
 			break;
 		}
 	case HW_VAR_SIFS:{
-			rtl_write_byte(rtlpriv, REG_SIFS_CCK + 1, val[0]);
-			rtl_write_byte(rtlpriv, REG_SIFS_OFDM + 1, val[1]);
-			rtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);
-			rtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);
-			rtl_write_byte(rtlpriv, REG_R2T_SIFS+1, val[0]);
-			rtl_write_byte(rtlpriv, REG_T2T_SIFS+1, val[0]);
-			RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD, "HW_VAR_SIFS\n");
+			rtl_write_byte( rtlpriv, REG_SIFS_CCK + 1, val[0] );
+			rtl_write_byte( rtlpriv, REG_SIFS_OFDM + 1, val[1] );
+			rtl_write_byte( rtlpriv, REG_SPEC_SIFS + 1, val[0] );
+			rtl_write_byte( rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0] );
+			rtl_write_byte( rtlpriv, REG_R2T_SIFS+1, val[0] );
+			rtl_write_byte( rtlpriv, REG_T2T_SIFS+1, val[0] );
+			RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD, "HW_VAR_SIFS\n" );
 			break;
 		}
 	case HW_VAR_SLOT_TIME:{
 			u8 e_aci;
 			u8 QOS_MODE = 1;
 
-			rtl_write_byte(rtlpriv, REG_SLOT, val[0]);
-			RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
-				 "HW_VAR_SLOT_TIME %x\n", val[0]);
-			if (QOS_MODE) {
-				for (e_aci = 0; e_aci < AC_MAX; e_aci++)
-					rtlpriv->cfg->ops->set_hw_reg(hw,
+			rtl_write_byte( rtlpriv, REG_SLOT, val[0] );
+			RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD,
+				 "HW_VAR_SLOT_TIME %x\n", val[0] );
+			if ( QOS_MODE ) {
+				for ( e_aci = 0; e_aci < AC_MAX; e_aci++ )
+					rtlpriv->cfg->ops->set_hw_reg( hw,
 								HW_VAR_AC_PARAM,
-								&e_aci);
+								&e_aci );
 			} else {
 				u8 sifstime = 0;
 				u8	u1bAIFS;
 
-				if (IS_WIRELESS_MODE_A(wirelessmode) ||
-				    IS_WIRELESS_MODE_N_24G(wirelessmode) ||
-				    IS_WIRELESS_MODE_N_5G(wirelessmode))
+				if ( IS_WIRELESS_MODE_A( wirelessmode ) ||
+				    IS_WIRELESS_MODE_N_24G( wirelessmode ) ||
+				    IS_WIRELESS_MODE_N_5G( wirelessmode ) )
 					sifstime = 16;
 				else
 					sifstime = 10;
-				u1bAIFS = sifstime + (2 *  val[0]);
-				rtl_write_byte(rtlpriv, REG_EDCA_VO_PARAM,
-					       u1bAIFS);
-				rtl_write_byte(rtlpriv, REG_EDCA_VI_PARAM,
-					       u1bAIFS);
-				rtl_write_byte(rtlpriv, REG_EDCA_BE_PARAM,
-					       u1bAIFS);
-				rtl_write_byte(rtlpriv, REG_EDCA_BK_PARAM,
-					       u1bAIFS);
+				u1bAIFS = sifstime + ( 2 *  val[0] );
+				rtl_write_byte( rtlpriv, REG_EDCA_VO_PARAM,
+					       u1bAIFS );
+				rtl_write_byte( rtlpriv, REG_EDCA_VI_PARAM,
+					       u1bAIFS );
+				rtl_write_byte( rtlpriv, REG_EDCA_BE_PARAM,
+					       u1bAIFS );
+				rtl_write_byte( rtlpriv, REG_EDCA_BK_PARAM,
+					       u1bAIFS );
 			}
 			break;
 		}
 	case HW_VAR_ACK_PREAMBLE:{
 			u8 reg_tmp;
-			u8 short_preamble = (bool)*val;
+			u8 short_preamble = ( bool )*val;
 			reg_tmp = 0;
-			if (short_preamble)
+			if ( short_preamble )
 				reg_tmp |= 0x80;
-			rtl_write_byte(rtlpriv, REG_RRSR + 2, reg_tmp);
+			rtl_write_byte( rtlpriv, REG_RRSR + 2, reg_tmp );
 			break;
 		}
 	case HW_VAR_AMPDU_MIN_SPACE:{
@@ -1712,8 +1719,8 @@ void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
 			u8 sec_min_space;
 
 			min_spacing_to_set = *val;
-			if (min_spacing_to_set <= 7) {
-				switch (rtlpriv->sec.pairwise_enc_algorithm) {
+			if ( min_spacing_to_set <= 7 ) {
+				switch ( rtlpriv->sec.pairwise_enc_algorithm ) {
 				case NO_ENCRYPTION:
 				case AESCCMP_ENCRYPTION:
 					sec_min_space = 0;
@@ -1727,17 +1734,17 @@ void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
 					sec_min_space = 7;
 					break;
 				}
-				if (min_spacing_to_set < sec_min_space)
+				if ( min_spacing_to_set < sec_min_space )
 					min_spacing_to_set = sec_min_space;
-				mac->min_space_cfg = ((mac->min_space_cfg &
-						     0xf8) |
-						     min_spacing_to_set);
+				mac->min_space_cfg = ( ( mac->min_space_cfg &
+						     0xf8 ) |
+						     min_spacing_to_set );
 				*val = min_spacing_to_set;
-				RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
+				RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD,
 					 "Set HW_VAR_AMPDU_MIN_SPACE: %#x\n",
-					 mac->min_space_cfg);
-				rtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,
-					       mac->min_space_cfg);
+					 mac->min_space_cfg );
+				rtl_write_byte( rtlpriv, REG_AMPDU_MIN_SPACE,
+					       mac->min_space_cfg );
 			}
 			break;
 		}
@@ -1747,12 +1754,12 @@ void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
 			density_to_set = *val;
 			density_to_set &= 0x1f;
 			mac->min_space_cfg &= 0x07;
-			mac->min_space_cfg |= (density_to_set << 3);
-			RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
+			mac->min_space_cfg |= ( density_to_set << 3 );
+			RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD,
 				 "Set HW_VAR_SHORTGI_DENSITY: %#x\n",
-				 mac->min_space_cfg);
-			rtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,
-				       mac->min_space_cfg);
+				 mac->min_space_cfg );
+			rtl_write_byte( rtlpriv, REG_AMPDU_MIN_SPACE,
+				       mac->min_space_cfg );
 			break;
 		}
 	case HW_VAR_AMPDU_FACTOR:{
@@ -1763,86 +1770,86 @@ void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
 
 			p_regtoset = regtoset_normal;
 			factor_toset = *val;
-			if (factor_toset <= 3) {
-				factor_toset = (1 << (factor_toset + 2));
-				if (factor_toset > 0xf)
+			if ( factor_toset <= 3 ) {
+				factor_toset = ( 1 << ( factor_toset + 2 ) );
+				if ( factor_toset > 0xf )
 					factor_toset = 0xf;
-				for (index = 0; index < 4; index++) {
-					if ((p_regtoset[index] & 0xf0) >
-					    (factor_toset << 4))
+				for ( index = 0; index < 4; index++ ) {
+					if ( ( p_regtoset[index] & 0xf0 ) >
+					    ( factor_toset << 4 ) )
 						p_regtoset[index] =
-						     (p_regtoset[index] & 0x0f)
-						     | (factor_toset << 4);
-					if ((p_regtoset[index] & 0x0f) >
-					     factor_toset)
+						     ( p_regtoset[index] & 0x0f )
+						     | ( factor_toset << 4 );
+					if ( ( p_regtoset[index] & 0x0f ) >
+					     factor_toset )
 						p_regtoset[index] =
-						     (p_regtoset[index] & 0xf0)
-						     | (factor_toset);
-					rtl_write_byte(rtlpriv,
-						       (REG_AGGLEN_LMT + index),
-						       p_regtoset[index]);
+						     ( p_regtoset[index] & 0xf0 )
+						     | ( factor_toset );
+					rtl_write_byte( rtlpriv,
+						       ( REG_AGGLEN_LMT + index ),
+						       p_regtoset[index] );
 				}
-				RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
+				RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD,
 					 "Set HW_VAR_AMPDU_FACTOR: %#x\n",
-					 factor_toset);
+					 factor_toset );
 			}
 			break;
 		}
 	case HW_VAR_AC_PARAM:{
 			u8 e_aci = *val;
 			u32 u4b_ac_param;
-			u16 cw_min = le16_to_cpu(mac->ac[e_aci].cw_min);
-			u16 cw_max = le16_to_cpu(mac->ac[e_aci].cw_max);
-			u16 tx_op = le16_to_cpu(mac->ac[e_aci].tx_op);
-
-			u4b_ac_param = (u32) mac->ac[e_aci].aifs;
-			u4b_ac_param |= (u32) ((cw_min & 0xF) <<
-					 AC_PARAM_ECW_MIN_OFFSET);
-			u4b_ac_param |= (u32) ((cw_max & 0xF) <<
-					 AC_PARAM_ECW_MAX_OFFSET);
-			u4b_ac_param |= (u32) tx_op << AC_PARAM_TXOP_OFFSET;
-			RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
+			u16 cw_min = le16_to_cpu( mac->ac[e_aci].cw_min );
+			u16 cw_max = le16_to_cpu( mac->ac[e_aci].cw_max );
+			u16 tx_op = le16_to_cpu( mac->ac[e_aci].tx_op );
+
+			u4b_ac_param = ( u32 ) mac->ac[e_aci].aifs;
+			u4b_ac_param |= ( u32 ) ( ( cw_min & 0xF ) <<
+					 AC_PARAM_ECW_MIN_OFFSET );
+			u4b_ac_param |= ( u32 ) ( ( cw_max & 0xF ) <<
+					 AC_PARAM_ECW_MAX_OFFSET );
+			u4b_ac_param |= ( u32 ) tx_op << AC_PARAM_TXOP_OFFSET;
+			RT_TRACE( rtlpriv, COMP_MLME, DBG_LOUD,
 				 "queue:%x, ac_param:%x\n",
-				 e_aci, u4b_ac_param);
-			switch (e_aci) {
+				 e_aci, u4b_ac_param );
+			switch ( e_aci ) {
 			case AC1_BK:
-				rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM,
-						u4b_ac_param);
+				rtl_write_dword( rtlpriv, REG_EDCA_BK_PARAM,
+						u4b_ac_param );
 				break;
 			case AC0_BE:
-				rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM,
-						u4b_ac_param);
+				rtl_write_dword( rtlpriv, REG_EDCA_BE_PARAM,
+						u4b_ac_param );
 				break;
 			case AC2_VI:
-				rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM,
-						u4b_ac_param);
+				rtl_write_dword( rtlpriv, REG_EDCA_VI_PARAM,
+						u4b_ac_param );
 				break;
 			case AC3_VO:
-				rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM,
-						u4b_ac_param);
+				rtl_write_dword( rtlpriv, REG_EDCA_VO_PARAM,
+						u4b_ac_param );
 				break;
 			default:
-				RT_ASSERT(false,
+				RT_ASSERT( false,
 					  "SetHwReg8185(): invalid aci: %d !\n",
-					  e_aci);
+					  e_aci );
 				break;
 			}
-			if (rtlusb->acm_method != EACMWAY2_SW)
-				rtlpriv->cfg->ops->set_hw_reg(hw,
-					 HW_VAR_ACM_CTRL, &e_aci);
+			if ( rtlusb->acm_method != EACMWAY2_SW )
+				rtlpriv->cfg->ops->set_hw_reg( hw,
+					 HW_VAR_ACM_CTRL, &e_aci );
 			break;
 		}
 	case HW_VAR_ACM_CTRL:{
 			u8 e_aci = *val;
-			union aci_aifsn *p_aci_aifsn = (union aci_aifsn *)
-							(&(mac->ac[0].aifs));
+			union aci_aifsn *p_aci_aifsn = ( union aci_aifsn * )
+							( &( mac->ac[0].aifs ) );
 			u8 acm = p_aci_aifsn->f.acm;
-			u8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);
+			u8 acm_ctrl = rtl_read_byte( rtlpriv, REG_ACMHWCTRL );
 
 			acm_ctrl =
-			    acm_ctrl | ((rtlusb->acm_method == 2) ? 0x0 : 0x1);
-			if (acm) {
-				switch (e_aci) {
+			    acm_ctrl | ( ( rtlusb->acm_method == 2 ) ? 0x0 : 0x1 );
+			if ( acm ) {
+				switch ( e_aci ) {
 				case AC0_BE:
 					acm_ctrl |= AcmHw_BeqEn;
 					break;
@@ -1853,166 +1860,166 @@ void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
 					acm_ctrl |= AcmHw_VoqEn;
 					break;
 				default:
-					RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+					RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 						 "HW_VAR_ACM_CTRL acm set failed: eACI is %d\n",
-						 acm);
+						 acm );
 					break;
 				}
 			} else {
-				switch (e_aci) {
+				switch ( e_aci ) {
 				case AC0_BE:
-					acm_ctrl &= (~AcmHw_BeqEn);
+					acm_ctrl &= ( ~AcmHw_BeqEn );
 					break;
 				case AC2_VI:
-					acm_ctrl &= (~AcmHw_ViqEn);
+					acm_ctrl &= ( ~AcmHw_ViqEn );
 					break;
 				case AC3_VO:
-					acm_ctrl &= (~AcmHw_BeqEn);
+					acm_ctrl &= ( ~AcmHw_BeqEn );
 					break;
 				default:
-					RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-						 "switch case not processed\n");
+					RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+						 "switch case not processed\n" );
 					break;
 				}
 			}
-			RT_TRACE(rtlpriv, COMP_QOS, DBG_TRACE,
+			RT_TRACE( rtlpriv, COMP_QOS, DBG_TRACE,
 				 "SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\n",
-				 acm_ctrl);
-			rtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);
+				 acm_ctrl );
+			rtl_write_byte( rtlpriv, REG_ACMHWCTRL, acm_ctrl );
 			break;
 		}
 	case HW_VAR_RCR:{
-			rtl_write_dword(rtlpriv, REG_RCR, ((u32 *) (val))[0]);
-			mac->rx_conf = ((u32 *) (val))[0];
-			RT_TRACE(rtlpriv, COMP_RECV, DBG_DMESG,
-				 "### Set RCR(0x%08x) ###\n", mac->rx_conf);
+			rtl_write_dword( rtlpriv, REG_RCR, ( ( u32 * ) ( val ) )[0] );
+			mac->rx_conf = ( ( u32 * ) ( val ) )[0];
+			RT_TRACE( rtlpriv, COMP_RECV, DBG_DMESG,
+				 "### Set RCR(0x%08x) ###\n", mac->rx_conf );
 			break;
 		}
 	case HW_VAR_RETRY_LIMIT:{
 			u8 retry_limit = val[0];
 
-			rtl_write_word(rtlpriv, REG_RL,
+			rtl_write_word( rtlpriv, REG_RL,
 				       retry_limit << RETRY_LIMIT_SHORT_SHIFT |
-				       retry_limit << RETRY_LIMIT_LONG_SHIFT);
-			RT_TRACE(rtlpriv, COMP_MLME, DBG_DMESG,
+				       retry_limit << RETRY_LIMIT_LONG_SHIFT );
+			RT_TRACE( rtlpriv, COMP_MLME, DBG_DMESG,
 				 "Set HW_VAR_RETRY_LIMIT(0x%08x)\n",
-				 retry_limit);
+				 retry_limit );
 			break;
 		}
 	case HW_VAR_DUAL_TSF_RST:
-		rtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));
+		rtl_write_byte( rtlpriv, REG_DUAL_TSF_RST, ( BIT( 0 ) | BIT( 1 ) ) );
 		break;
 	case HW_VAR_EFUSE_BYTES:
-		rtlefuse->efuse_usedbytes = *((u16 *) val);
+		rtlefuse->efuse_usedbytes = *( ( u16 * ) val );
 		break;
 	case HW_VAR_EFUSE_USAGE:
 		rtlefuse->efuse_usedpercentage = *val;
 		break;
 	case HW_VAR_IO_CMD:
-		rtl92c_phy_set_io_cmd(hw, (*(enum io_type *)val));
+		rtl92c_phy_set_io_cmd( hw, ( *( enum io_type * )val ) );
 		break;
 	case HW_VAR_WPA_CONFIG:
-		rtl_write_byte(rtlpriv, REG_SECCFG, *val);
+		rtl_write_byte( rtlpriv, REG_SECCFG, *val );
 		break;
 	case HW_VAR_SET_RPWM:{
-			u8 rpwm_val = rtl_read_byte(rtlpriv, REG_USB_HRPWM);
+			u8 rpwm_val = rtl_read_byte( rtlpriv, REG_USB_HRPWM );
 
-			if (rpwm_val & BIT(7))
-				rtl_write_byte(rtlpriv, REG_USB_HRPWM, *val);
+			if ( rpwm_val & BIT( 7 ) )
+				rtl_write_byte( rtlpriv, REG_USB_HRPWM, *val );
 			else
-				rtl_write_byte(rtlpriv, REG_USB_HRPWM,
-					       *val | BIT(7));
+				rtl_write_byte( rtlpriv, REG_USB_HRPWM,
+					       *val | BIT( 7 ) );
 			break;
 		}
 	case HW_VAR_H2C_FW_PWRMODE:{
 			u8 psmode = *val;
 
-			if ((psmode != FW_PS_ACTIVE_MODE) &&
-			   (!IS_92C_SERIAL(rtlhal->version)))
-				rtl92c_dm_rf_saving(hw, true);
-			rtl92c_set_fw_pwrmode_cmd(hw, (*val));
+			if ( ( psmode != FW_PS_ACTIVE_MODE ) &&
+			   ( !IS_92C_SERIAL( rtlhal->version ) ) )
+				rtl92c_dm_rf_saving( hw, true );
+			rtl92c_set_fw_pwrmode_cmd( hw, ( *val ) );
 			break;
 		}
 	case HW_VAR_FW_PSMODE_STATUS:
-		ppsc->fw_current_inpsmode = *((bool *) val);
+		ppsc->fw_current_inpsmode = *( ( bool * ) val );
 		break;
 	case HW_VAR_H2C_FW_JOINBSSRPT:{
 			u8 mstatus = *val;
 			u8 tmp_reg422;
 			bool recover = false;
 
-			if (mstatus == RT_MEDIA_CONNECT) {
-				rtlpriv->cfg->ops->set_hw_reg(hw,
-							 HW_VAR_AID, NULL);
-				rtl_write_byte(rtlpriv, REG_CR + 1, 0x03);
-				_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(3));
-				_rtl92cu_set_bcn_ctrl_reg(hw, BIT(4), 0);
-				tmp_reg422 = rtl_read_byte(rtlpriv,
-							REG_FWHW_TXQ_CTRL + 2);
-				if (tmp_reg422 & BIT(6))
+			if ( mstatus == RT_MEDIA_CONNECT ) {
+				rtlpriv->cfg->ops->set_hw_reg( hw,
+							 HW_VAR_AID, NULL );
+				rtl_write_byte( rtlpriv, REG_CR + 1, 0x03 );
+				_rtl92cu_set_bcn_ctrl_reg( hw, 0, BIT( 3 ) );
+				_rtl92cu_set_bcn_ctrl_reg( hw, BIT( 4 ), 0 );
+				tmp_reg422 = rtl_read_byte( rtlpriv,
+							REG_FWHW_TXQ_CTRL + 2 );
+				if ( tmp_reg422 & BIT( 6 ) )
 					recover = true;
-				rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,
-					       tmp_reg422 & (~BIT(6)));
-				rtl92c_set_fw_rsvdpagepkt(hw,
-							  &usb_cmd_send_packet);
-				_rtl92cu_set_bcn_ctrl_reg(hw, BIT(3), 0);
-				_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(4));
-				if (recover)
-					rtl_write_byte(rtlpriv,
+				rtl_write_byte( rtlpriv, REG_FWHW_TXQ_CTRL + 2,
+					       tmp_reg422 & ( ~BIT( 6 ) ) );
+				rtl92c_set_fw_rsvdpagepkt( hw,
+							  &usb_cmd_send_packet );
+				_rtl92cu_set_bcn_ctrl_reg( hw, BIT( 3 ), 0 );
+				_rtl92cu_set_bcn_ctrl_reg( hw, 0, BIT( 4 ) );
+				if ( recover )
+					rtl_write_byte( rtlpriv,
 						 REG_FWHW_TXQ_CTRL + 2,
-						tmp_reg422 | BIT(6));
-				rtl_write_byte(rtlpriv, REG_CR + 1, 0x02);
+						tmp_reg422 | BIT( 6 ) );
+				rtl_write_byte( rtlpriv, REG_CR + 1, 0x02 );
 			}
-			rtl92c_set_fw_joinbss_report_cmd(hw, (*val));
+			rtl92c_set_fw_joinbss_report_cmd( hw, ( *val ) );
 			break;
 		}
 	case HW_VAR_AID:{
 			u16 u2btmp;
 
-			u2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);
+			u2btmp = rtl_read_word( rtlpriv, REG_BCN_PSR_RPT );
 			u2btmp &= 0xC000;
-			rtl_write_word(rtlpriv, REG_BCN_PSR_RPT,
-				       (u2btmp | mac->assoc_id));
+			rtl_write_word( rtlpriv, REG_BCN_PSR_RPT,
+				       ( u2btmp | mac->assoc_id ) );
 			break;
 		}
 	case HW_VAR_CORRECT_TSF:{
 			u8 btype_ibss = val[0];
 
-			if (btype_ibss)
-				_rtl92cu_stop_tx_beacon(hw);
-			_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(3));
-			rtl_write_dword(rtlpriv, REG_TSFTR, (u32)(mac->tsf &
-					0xffffffff));
-			rtl_write_dword(rtlpriv, REG_TSFTR + 4,
-					(u32)((mac->tsf >> 32) & 0xffffffff));
-			_rtl92cu_set_bcn_ctrl_reg(hw, BIT(3), 0);
-			if (btype_ibss)
-				_rtl92cu_resume_tx_beacon(hw);
+			if ( btype_ibss )
+				_rtl92cu_stop_tx_beacon( hw );
+			_rtl92cu_set_bcn_ctrl_reg( hw, 0, BIT( 3 ) );
+			rtl_write_dword( rtlpriv, REG_TSFTR, ( u32 )( mac->tsf &
+					0xffffffff ) );
+			rtl_write_dword( rtlpriv, REG_TSFTR + 4,
+					( u32 )( ( mac->tsf >> 32 ) & 0xffffffff ) );
+			_rtl92cu_set_bcn_ctrl_reg( hw, BIT( 3 ), 0 );
+			if ( btype_ibss )
+				_rtl92cu_resume_tx_beacon( hw );
 			break;
 		}
 	case HW_VAR_MGT_FILTER:
-		rtl_write_word(rtlpriv, REG_RXFLTMAP0, *(u16 *)val);
+		rtl_write_word( rtlpriv, REG_RXFLTMAP0, *( u16 * )val );
 		break;
 	case HW_VAR_CTRL_FILTER:
-		rtl_write_word(rtlpriv, REG_RXFLTMAP1, *(u16 *)val);
+		rtl_write_word( rtlpriv, REG_RXFLTMAP1, *( u16 * )val );
 		break;
 	case HW_VAR_DATA_FILTER:
-		rtl_write_word(rtlpriv, REG_RXFLTMAP2, *(u16 *)val);
+		rtl_write_word( rtlpriv, REG_RXFLTMAP2, *( u16 * )val );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	}
 }
 
-static void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,
-					  struct ieee80211_sta *sta)
+static void rtl92cu_update_hal_rate_table( struct ieee80211_hw *hw,
+					  struct ieee80211_sta *sta )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u32 ratr_value;
 	u8 ratr_index = 0;
 	u8 nmode = mac->ht_enable;
@@ -2020,24 +2027,24 @@ static void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,
 	u16 shortgi_rate;
 	u32 tmp_ratr_value;
 	u8 curtxbw_40mhz = mac->bw_40;
-	u8 curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?
+	u8 curshortgi_40mhz = ( sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40 ) ?
 			       1 : 0;
-	u8 curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?
+	u8 curshortgi_20mhz = ( sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20 ) ?
 			       1 : 0;
 	enum wireless_mode wirelessmode = mac->mode;
 
-	if (rtlhal->current_bandtype == BAND_ON_5G)
+	if ( rtlhal->current_bandtype == BAND_ON_5G )
 		ratr_value = sta->supp_rates[1] << 4;
 	else
 		ratr_value = sta->supp_rates[0];
-	if (mac->opmode == NL80211_IFTYPE_ADHOC)
+	if ( mac->opmode == NL80211_IFTYPE_ADHOC )
 		ratr_value = 0xfff;
 
-	ratr_value |= (sta->ht_cap.mcs.rx_mask[1] << 20 |
-			sta->ht_cap.mcs.rx_mask[0] << 12);
-	switch (wirelessmode) {
+	ratr_value |= ( sta->ht_cap.mcs.rx_mask[1] << 20 |
+			sta->ht_cap.mcs.rx_mask[0] << 12 );
+	switch ( wirelessmode ) {
 	case WIRELESS_MODE_B:
-		if (ratr_value & 0x0000000c)
+		if ( ratr_value & 0x0000000c )
 			ratr_value &= 0x0000000d;
 		else
 			ratr_value &= 0x0000000f;
@@ -2048,13 +2055,13 @@ static void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,
 	case WIRELESS_MODE_N_24G:
 	case WIRELESS_MODE_N_5G:
 		nmode = 1;
-		if (mimo_ps == IEEE80211_SMPS_STATIC) {
+		if ( mimo_ps == IEEE80211_SMPS_STATIC ) {
 			ratr_value &= 0x0007F005;
 		} else {
 			u32 ratr_mask;
 
-			if (get_rf_type(rtlphy) == RF_1T2R ||
-			    get_rf_type(rtlphy) == RF_1T1R)
+			if ( get_rf_type( rtlphy ) == RF_1T2R ||
+			    get_rf_type( rtlphy ) == RF_1T1R )
 				ratr_mask = 0x000ff005;
 			else
 				ratr_mask = 0x0f0ff005;
@@ -2063,7 +2070,7 @@ static void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,
 		}
 		break;
 	default:
-		if (rtlphy->rf_type == RF_1T2R)
+		if ( rtlphy->rf_type == RF_1T2R )
 			ratr_value &= 0x000ff0ff;
 		else
 			ratr_value &= 0x0f0ff0ff;
@@ -2073,44 +2080,44 @@ static void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,
 
 	ratr_value &= 0x0FFFFFFF;
 
-	if (nmode && ((curtxbw_40mhz &&
-			 curshortgi_40mhz) || (!curtxbw_40mhz &&
-					       curshortgi_20mhz))) {
+	if ( nmode && ( ( curtxbw_40mhz &&
+			 curshortgi_40mhz ) || ( !curtxbw_40mhz &&
+					       curshortgi_20mhz ) ) ) {
 
 		ratr_value |= 0x10000000;
-		tmp_ratr_value = (ratr_value >> 12);
+		tmp_ratr_value = ( ratr_value >> 12 );
 
-		for (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {
-			if ((1 << shortgi_rate) & tmp_ratr_value)
+		for ( shortgi_rate = 15; shortgi_rate > 0; shortgi_rate-- ) {
+			if ( ( 1 << shortgi_rate ) & tmp_ratr_value )
 				break;
 		}
 
-		shortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |
-		    (shortgi_rate << 4) | (shortgi_rate);
+		shortgi_rate = ( shortgi_rate << 12 ) | ( shortgi_rate << 8 ) |
+		    ( shortgi_rate << 4 ) | ( shortgi_rate );
 	}
 
-	rtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);
+	rtl_write_dword( rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value );
 
-	RT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG, "%x\n",
-		 rtl_read_dword(rtlpriv, REG_ARFR0));
+	RT_TRACE( rtlpriv, COMP_RATR, DBG_DMESG, "%x\n",
+		 rtl_read_dword( rtlpriv, REG_ARFR0 ) );
 }
 
-static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
+static void rtl92cu_update_hal_rate_mask( struct ieee80211_hw *hw,
 					 struct ieee80211_sta *sta,
-					 u8 rssi_level)
+					 u8 rssi_level )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	struct rtl_sta_info *sta_entry = NULL;
 	u32 ratr_bitmap;
 	u8 ratr_index;
-	u8 curtxbw_40mhz = (sta->bandwidth >= IEEE80211_STA_RX_BW_40) ? 1 : 0;
+	u8 curtxbw_40mhz = ( sta->bandwidth >= IEEE80211_STA_RX_BW_40 ) ? 1 : 0;
 	u8 curshortgi_40mhz = curtxbw_40mhz &&
-			      (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?
+			      ( sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40 ) ?
 				1 : 0;
-	u8 curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?
+	u8 curshortgi_20mhz = ( sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20 ) ?
 				1 : 0;
 	enum wireless_mode wirelessmode = 0;
 	bool shortgi = false;
@@ -2118,27 +2125,27 @@ static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
 	u8 macid = 0;
 	u8 mimo_ps = IEEE80211_SMPS_OFF;
 
-	sta_entry = (struct rtl_sta_info *) sta->drv_priv;
+	sta_entry = ( struct rtl_sta_info * ) sta->drv_priv;
 	wirelessmode = sta_entry->wireless_mode;
-	if (mac->opmode == NL80211_IFTYPE_STATION ||
-	    mac->opmode == NL80211_IFTYPE_MESH_POINT)
+	if ( mac->opmode == NL80211_IFTYPE_STATION ||
+	    mac->opmode == NL80211_IFTYPE_MESH_POINT )
 		curtxbw_40mhz = mac->bw_40;
-	else if (mac->opmode == NL80211_IFTYPE_AP ||
-		mac->opmode == NL80211_IFTYPE_ADHOC)
+	else if ( mac->opmode == NL80211_IFTYPE_AP ||
+		mac->opmode == NL80211_IFTYPE_ADHOC )
 		macid = sta->aid + 1;
 
-	if (rtlhal->current_bandtype == BAND_ON_5G)
+	if ( rtlhal->current_bandtype == BAND_ON_5G )
 		ratr_bitmap = sta->supp_rates[1] << 4;
 	else
 		ratr_bitmap = sta->supp_rates[0];
-	if (mac->opmode == NL80211_IFTYPE_ADHOC)
+	if ( mac->opmode == NL80211_IFTYPE_ADHOC )
 		ratr_bitmap = 0xfff;
-	ratr_bitmap |= (sta->ht_cap.mcs.rx_mask[1] << 20 |
-			sta->ht_cap.mcs.rx_mask[0] << 12);
-	switch (wirelessmode) {
+	ratr_bitmap |= ( sta->ht_cap.mcs.rx_mask[1] << 20 |
+			sta->ht_cap.mcs.rx_mask[0] << 12 );
+	switch ( wirelessmode ) {
 	case WIRELESS_MODE_B:
 		ratr_index = RATR_INX_WIRELESS_B;
-		if (ratr_bitmap & 0x0000000c)
+		if ( ratr_bitmap & 0x0000000c )
 			ratr_bitmap &= 0x0000000d;
 		else
 			ratr_bitmap &= 0x0000000f;
@@ -2146,9 +2153,9 @@ static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
 	case WIRELESS_MODE_G:
 		ratr_index = RATR_INX_WIRELESS_GB;
 
-		if (rssi_level == 1)
+		if ( rssi_level == 1 )
 			ratr_bitmap &= 0x00000f00;
-		else if (rssi_level == 2)
+		else if ( rssi_level == 2 )
 			ratr_bitmap &= 0x00000ff0;
 		else
 			ratr_bitmap &= 0x00000ff5;
@@ -2161,43 +2168,43 @@ static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
 	case WIRELESS_MODE_N_5G:
 		ratr_index = RATR_INX_WIRELESS_NGB;
 
-		if (mimo_ps == IEEE80211_SMPS_STATIC) {
-			if (rssi_level == 1)
+		if ( mimo_ps == IEEE80211_SMPS_STATIC ) {
+			if ( rssi_level == 1 )
 				ratr_bitmap &= 0x00070000;
-			else if (rssi_level == 2)
+			else if ( rssi_level == 2 )
 				ratr_bitmap &= 0x0007f000;
 			else
 				ratr_bitmap &= 0x0007f005;
 		} else {
-			if (rtlphy->rf_type == RF_1T2R ||
-			    rtlphy->rf_type == RF_1T1R) {
-				if (curtxbw_40mhz) {
-					if (rssi_level == 1)
+			if ( rtlphy->rf_type == RF_1T2R ||
+			    rtlphy->rf_type == RF_1T1R ) {
+				if ( curtxbw_40mhz ) {
+					if ( rssi_level == 1 )
 						ratr_bitmap &= 0x000f0000;
-					else if (rssi_level == 2)
+					else if ( rssi_level == 2 )
 						ratr_bitmap &= 0x000ff000;
 					else
 						ratr_bitmap &= 0x000ff015;
 				} else {
-					if (rssi_level == 1)
+					if ( rssi_level == 1 )
 						ratr_bitmap &= 0x000f0000;
-					else if (rssi_level == 2)
+					else if ( rssi_level == 2 )
 						ratr_bitmap &= 0x000ff000;
 					else
 						ratr_bitmap &= 0x000ff005;
 				}
 			} else {
-				if (curtxbw_40mhz) {
-					if (rssi_level == 1)
+				if ( curtxbw_40mhz ) {
+					if ( rssi_level == 1 )
 						ratr_bitmap &= 0x0f0f0000;
-					else if (rssi_level == 2)
+					else if ( rssi_level == 2 )
 						ratr_bitmap &= 0x0f0ff000;
 					else
 						ratr_bitmap &= 0x0f0ff015;
 				} else {
-					if (rssi_level == 1)
+					if ( rssi_level == 1 )
 						ratr_bitmap &= 0x0f0f0000;
-					else if (rssi_level == 2)
+					else if ( rssi_level == 2 )
 						ratr_bitmap &= 0x0f0ff000;
 					else
 						ratr_bitmap &= 0x0f0ff005;
@@ -2205,19 +2212,19 @@ static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
 			}
 		}
 
-		if ((curtxbw_40mhz && curshortgi_40mhz) ||
-		    (!curtxbw_40mhz && curshortgi_20mhz)) {
+		if ( ( curtxbw_40mhz && curshortgi_40mhz ) ||
+		    ( !curtxbw_40mhz && curshortgi_20mhz ) ) {
 
-			if (macid == 0)
+			if ( macid == 0 )
 				shortgi = true;
-			else if (macid == 1)
+			else if ( macid == 1 )
 				shortgi = false;
 		}
 		break;
 	default:
 		ratr_index = RATR_INX_WIRELESS_NGB;
 
-		if (rtlphy->rf_type == RF_1T2R)
+		if ( rtlphy->rf_type == RF_1T2R )
 			ratr_bitmap &= 0x000ff0ff;
 		else
 			ratr_bitmap &= 0x0f0ff0ff;
@@ -2225,55 +2232,55 @@ static void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,
 	}
 	sta_entry->ratr_index = ratr_index;
 
-	RT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,
-		 "ratr_bitmap :%x\n", ratr_bitmap);
-	*(u32 *)&rate_mask = (ratr_bitmap & 0x0fffffff) |
-				     (ratr_index << 28);
-	rate_mask[4] = macid | (shortgi ? 0x20 : 0x00) | 0x80;
-	RT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,
+	RT_TRACE( rtlpriv, COMP_RATR, DBG_DMESG,
+		 "ratr_bitmap :%x\n", ratr_bitmap );
+	*( u32 * )&rate_mask = ( ratr_bitmap & 0x0fffffff ) |
+				     ( ratr_index << 28 );
+	rate_mask[4] = macid | ( shortgi ? 0x20 : 0x00 ) | 0x80;
+	RT_TRACE( rtlpriv, COMP_RATR, DBG_DMESG,
 		 "Rate_index:%x, ratr_val:%x, %5phC\n",
-		 ratr_index, ratr_bitmap, rate_mask);
-	memcpy(rtlpriv->rate_mask, rate_mask, 5);
+		 ratr_index, ratr_bitmap, rate_mask );
+	memcpy( rtlpriv->rate_mask, rate_mask, 5 );
 	/* rtl92c_fill_h2c_cmd() does USB I/O and will result in a
 	 * "scheduled while atomic" if called directly */
-	schedule_work(&rtlpriv->works.fill_h2c_cmd);
+	schedule_work( &rtlpriv->works.fill_h2c_cmd );
 
-	if (macid != 0)
+	if ( macid != 0 )
 		sta_entry->ratr_index = ratr_index;
 }
 
-void rtl92cu_update_hal_rate_tbl(struct ieee80211_hw *hw,
+void rtl92cu_update_hal_rate_tbl( struct ieee80211_hw *hw,
 				 struct ieee80211_sta *sta,
-				 u8 rssi_level)
+				 u8 rssi_level )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (rtlpriv->dm.useramask)
-		rtl92cu_update_hal_rate_mask(hw, sta, rssi_level);
+	if ( rtlpriv->dm.useramask )
+		rtl92cu_update_hal_rate_mask( hw, sta, rssi_level );
 	else
-		rtl92cu_update_hal_rate_table(hw, sta);
+		rtl92cu_update_hal_rate_table( hw, sta );
 }
 
-void rtl92cu_update_channel_access_setting(struct ieee80211_hw *hw)
+void rtl92cu_update_channel_access_setting( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	u16 sifs_timer;
 
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,
-				      &mac->slot_time);
-	if (!mac->ht_enable)
+	rtlpriv->cfg->ops->set_hw_reg( hw, HW_VAR_SLOT_TIME,
+				      &mac->slot_time );
+	if ( !mac->ht_enable )
 		sifs_timer = 0x0a0a;
 	else
 		sifs_timer = 0x0e0e;
-	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);
+	rtlpriv->cfg->ops->set_hw_reg( hw, HW_VAR_SIFS, ( u8 * )&sifs_timer );
 }
 
-bool rtl92cu_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 * valid)
+bool rtl92cu_gpio_radio_on_off_checking( struct ieee80211_hw *hw, u8 * valid )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	enum rf_pwrstate e_rfpowerstate_toset, cur_rfstate;
 	u8 u1tmp = 0;
 	bool actuallyset = false;
@@ -2281,109 +2288,109 @@ bool rtl92cu_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 * valid)
 	/* to do - usb autosuspend */
 	u8 usb_autosuspend = 0;
 
-	if (ppsc->swrf_processing)
+	if ( ppsc->swrf_processing )
 		return false;
-	spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);
-	if (ppsc->rfchange_inprogress) {
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);
+	spin_lock_irqsave( &rtlpriv->locks.rf_ps_lock, flag );
+	if ( ppsc->rfchange_inprogress ) {
+		spin_unlock_irqrestore( &rtlpriv->locks.rf_ps_lock, flag );
 		return false;
 	} else {
 		ppsc->rfchange_inprogress = true;
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_unlock_irqrestore( &rtlpriv->locks.rf_ps_lock, flag );
 	}
 	cur_rfstate = ppsc->rfpwr_state;
-	if (usb_autosuspend) {
+	if ( usb_autosuspend ) {
 		/* to do................... */
 	} else {
-		if (ppsc->pwrdown_mode) {
-			u1tmp = rtl_read_byte(rtlpriv, REG_HSISR);
-			e_rfpowerstate_toset = (u1tmp & BIT(7)) ?
+		if ( ppsc->pwrdown_mode ) {
+			u1tmp = rtl_read_byte( rtlpriv, REG_HSISR );
+			e_rfpowerstate_toset = ( u1tmp & BIT( 7 ) ) ?
 					       ERFOFF : ERFON;
-			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
-				 "pwrdown, 0x5c(BIT7)=%02x\n", u1tmp);
+			RT_TRACE( rtlpriv, COMP_POWER, DBG_DMESG,
+				 "pwrdown, 0x5c(BIT7)=%02x\n", u1tmp );
 		} else {
-			rtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG,
-				       rtl_read_byte(rtlpriv,
-				       REG_MAC_PINMUX_CFG) & ~(BIT(3)));
-			u1tmp = rtl_read_byte(rtlpriv, REG_GPIO_IO_SEL);
-			e_rfpowerstate_toset  = (u1tmp & BIT(3)) ?
+			rtl_write_byte( rtlpriv, REG_MAC_PINMUX_CFG,
+				       rtl_read_byte( rtlpriv,
+				       REG_MAC_PINMUX_CFG ) & ~( BIT( 3 ) ) );
+			u1tmp = rtl_read_byte( rtlpriv, REG_GPIO_IO_SEL );
+			e_rfpowerstate_toset  = ( u1tmp & BIT( 3 ) ) ?
 						 ERFON : ERFOFF;
-			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
-				 "GPIO_IN=%02x\n", u1tmp);
+			RT_TRACE( rtlpriv, COMP_POWER, DBG_DMESG,
+				 "GPIO_IN=%02x\n", u1tmp );
 		}
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "N-SS RF =%x\n",
-			 e_rfpowerstate_toset);
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD, "N-SS RF =%x\n",
+			 e_rfpowerstate_toset );
 	}
-	if ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "GPIOChangeRF  - HW Radio ON, RF ON\n");
+	if ( ( ppsc->hwradiooff ) && ( e_rfpowerstate_toset == ERFON ) ) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
+			 "GPIOChangeRF  - HW Radio ON, RF ON\n" );
 		ppsc->hwradiooff = false;
 		actuallyset = true;
-	} else if ((!ppsc->hwradiooff) && (e_rfpowerstate_toset  ==
-		    ERFOFF)) {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
-			 "GPIOChangeRF  - HW Radio OFF\n");
+	} else if ( ( !ppsc->hwradiooff ) && ( e_rfpowerstate_toset  ==
+		    ERFOFF ) ) {
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
+			 "GPIOChangeRF  - HW Radio OFF\n" );
 		ppsc->hwradiooff = true;
 		actuallyset = true;
 	} else {
-		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+		RT_TRACE( rtlpriv, COMP_POWER, DBG_LOUD,
 			 "pHalData->bHwRadioOff and eRfPowerStateToSet do not match: pHalData->bHwRadioOff %x, eRfPowerStateToSet %x\n",
-			 ppsc->hwradiooff, e_rfpowerstate_toset);
+			 ppsc->hwradiooff, e_rfpowerstate_toset );
 	}
-	if (actuallyset) {
+	if ( actuallyset ) {
 		ppsc->hwradiooff = true;
-		if (e_rfpowerstate_toset == ERFON) {
-			if ((ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM) &&
-			     RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM))
-				RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);
-			else if ((ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3)
-				 && RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3))
-				RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);
+		if ( e_rfpowerstate_toset == ERFON ) {
+			if ( ( ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM ) &&
+			     RT_IN_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_ASPM ) )
+				RT_CLEAR_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_ASPM );
+			else if ( ( ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3 )
+				 && RT_IN_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_PCI_D3 ) )
+				RT_CLEAR_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_PCI_D3 );
 		}
-		spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_lock_irqsave( &rtlpriv->locks.rf_ps_lock, flag );
 		ppsc->rfchange_inprogress = false;
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_unlock_irqrestore( &rtlpriv->locks.rf_ps_lock, flag );
 		/* For power down module, we need to enable register block
 		 * contrl reg at 0x1c. Then enable power down control bit
 		 * of register 0x04 BIT4 and BIT15 as 1.
 		 */
-		if (ppsc->pwrdown_mode && e_rfpowerstate_toset == ERFOFF) {
+		if ( ppsc->pwrdown_mode && e_rfpowerstate_toset == ERFOFF ) {
 			/* Enable register area 0x0-0xc. */
-			rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0);
-			if (IS_HARDWARE_TYPE_8723U(rtlhal)) {
+			rtl_write_byte( rtlpriv, REG_RSV_CTRL, 0x0 );
+			if ( IS_HARDWARE_TYPE_8723U( rtlhal ) ) {
 				/*
 				 * We should configure HW PDn source for WiFi
 				 * ONLY, and then our HW will be set in
 				 * power-down mode if PDn source from all
 				 * functions are configured.
 				 */
-				u1tmp = rtl_read_byte(rtlpriv,
-						      REG_MULTI_FUNC_CTRL);
-				rtl_write_byte(rtlpriv, REG_MULTI_FUNC_CTRL,
-					       (u1tmp|WL_HWPDN_EN));
+				u1tmp = rtl_read_byte( rtlpriv,
+						      REG_MULTI_FUNC_CTRL );
+				rtl_write_byte( rtlpriv, REG_MULTI_FUNC_CTRL,
+					       ( u1tmp|WL_HWPDN_EN ) );
 			} else {
-				rtl_write_word(rtlpriv, REG_APS_FSMCO, 0x8812);
+				rtl_write_word( rtlpriv, REG_APS_FSMCO, 0x8812 );
 			}
 		}
-		if (e_rfpowerstate_toset == ERFOFF) {
-			if (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM)
-				RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);
-			else if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_PCI_D3)
-				RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);
+		if ( e_rfpowerstate_toset == ERFOFF ) {
+			if ( ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM )
+				RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_ASPM );
+			else if ( ppsc->reg_rfps_level & RT_RF_OFF_LEVL_PCI_D3 )
+				RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_PCI_D3 );
 		}
-	} else if (e_rfpowerstate_toset == ERFOFF || cur_rfstate == ERFOFF) {
+	} else if ( e_rfpowerstate_toset == ERFOFF || cur_rfstate == ERFOFF ) {
 		/* Enter D3 or ASPM after GPIO had been done. */
-		if (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM)
-			RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);
-		else if (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3)
-			RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);
-		spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);
+		if ( ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM )
+			RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_ASPM );
+		else if ( ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3 )
+			RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_PCI_D3 );
+		spin_lock_irqsave( &rtlpriv->locks.rf_ps_lock, flag );
 		ppsc->rfchange_inprogress = false;
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_unlock_irqrestore( &rtlpriv->locks.rf_ps_lock, flag );
 	} else {
-		spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_lock_irqsave( &rtlpriv->locks.rf_ps_lock, flag );
 		ppsc->rfchange_inprogress = false;
-		spin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);
+		spin_unlock_irqrestore( &rtlpriv->locks.rf_ps_lock, flag );
 	}
 	*valid = 1;
 	return !ppsc->hwradiooff;
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/hw.h b/drivers/net/wireless/rtlwifi/rtl8192cu/hw.h
index c1e33b0..ee54fb7 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/hw.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/hw.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -40,20 +47,20 @@
 /* Note: We will divide number of page equally for each queue
  * other than public queue! */
 #define TX_TOTAL_PAGE_NUMBER			0xF8
-#define TX_PAGE_BOUNDARY			(TX_TOTAL_PAGE_NUMBER + 1)
+#define TX_PAGE_BOUNDARY			( TX_TOTAL_PAGE_NUMBER + 1 )
 
 
 #define CHIP_B_PAGE_NUM_PUBQ			0xE7
 
 /* For Test Chip Setting
- * (HPQ + LPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
+ * ( HPQ + LPQ + PUBQ ) shall be TX_TOTAL_PAGE_NUMBER */
 #define CHIP_A_PAGE_NUM_PUBQ			0x7E
 
 
 /* For Chip A Setting */
 #define WMM_CHIP_A_TX_TOTAL_PAGE_NUMBER		0xF5
 #define WMM_CHIP_A_TX_PAGE_BOUNDARY		\
-	(WMM_CHIP_A_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
+	( WMM_CHIP_A_TX_TOTAL_PAGE_NUMBER + 1 ) /* F6 */
 
 #define WMM_CHIP_A_PAGE_NUM_PUBQ		0xA3
 #define WMM_CHIP_A_PAGE_NUM_HPQ			0x29
@@ -64,7 +71,7 @@
 /* Note: For Chip B Setting ,modify later */
 #define WMM_CHIP_B_TX_TOTAL_PAGE_NUMBER		0xF5
 #define WMM_CHIP_B_TX_PAGE_BOUNDARY		\
-	(WMM_CHIP_B_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
+	( WMM_CHIP_B_TX_TOTAL_PAGE_NUMBER + 1 ) /* F6 */
 
 #define WMM_CHIP_B_PAGE_NUM_PUBQ		0xB0
 #define WMM_CHIP_B_PAGE_NUM_HPQ			0x29
@@ -83,33 +90,33 @@ enum _BOARD_TYPE_8192CUSB {
 	BOARD_USB_COMBO			= 4,	/* USB Combo-Slim module */
 };
 
-#define IS_HIGHT_PA(boardtype)		\
-	((boardtype == BOARD_USB_High_PA) ? true : false)
+#define IS_HIGHT_PA( boardtype )		\
+	( ( boardtype == BOARD_USB_High_PA ) ? true : false )
 
 #define RTL92C_DRIVER_INFO_SIZE				4
-void rtl92cu_read_eeprom_info(struct ieee80211_hw *hw);
-void rtl92cu_enable_hw_security_config(struct ieee80211_hw *hw);
-int rtl92cu_hw_init(struct ieee80211_hw *hw);
-void rtl92cu_card_disable(struct ieee80211_hw *hw);
-int rtl92cu_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type);
-void rtl92cu_set_beacon_related_registers(struct ieee80211_hw *hw);
-void rtl92cu_set_beacon_interval(struct ieee80211_hw *hw);
-void rtl92cu_update_interrupt_mask(struct ieee80211_hw *hw,
-				   u32 add_msr, u32 rm_msr);
-void rtl92cu_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val);
-void rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val);
-
-void rtl92cu_update_channel_access_setting(struct ieee80211_hw *hw);
-bool rtl92cu_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 * valid);
-void rtl92cu_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid);
-int rtl92c_download_fw(struct ieee80211_hw *hw);
-void rtl92c_set_fw_pwrmode_cmd(struct ieee80211_hw *hw, u8 mode);
-void rtl92c_set_fw_joinbss_report_cmd(struct ieee80211_hw *hw, u8 mstatus);
-void rtl92c_fill_h2c_cmd(struct ieee80211_hw *hw,
-			 u8 element_id, u32 cmd_len, u8 *p_cmdbuffer);
-bool rtl92cu_phy_mac_config(struct ieee80211_hw *hw);
-void rtl92cu_update_hal_rate_tbl(struct ieee80211_hw *hw,
+void rtl92cu_read_eeprom_info( struct ieee80211_hw *hw );
+void rtl92cu_enable_hw_security_config( struct ieee80211_hw *hw );
+int rtl92cu_hw_init( struct ieee80211_hw *hw );
+void rtl92cu_card_disable( struct ieee80211_hw *hw );
+int rtl92cu_set_network_type( struct ieee80211_hw *hw, enum nl80211_iftype type );
+void rtl92cu_set_beacon_related_registers( struct ieee80211_hw *hw );
+void rtl92cu_set_beacon_interval( struct ieee80211_hw *hw );
+void rtl92cu_update_interrupt_mask( struct ieee80211_hw *hw,
+				   u32 add_msr, u32 rm_msr );
+void rtl92cu_get_hw_reg( struct ieee80211_hw *hw, u8 variable, u8 *val );
+void rtl92cu_set_hw_reg( struct ieee80211_hw *hw, u8 variable, u8 *val );
+
+void rtl92cu_update_channel_access_setting( struct ieee80211_hw *hw );
+bool rtl92cu_gpio_radio_on_off_checking( struct ieee80211_hw *hw, u8 * valid );
+void rtl92cu_set_check_bssid( struct ieee80211_hw *hw, bool check_bssid );
+int rtl92c_download_fw( struct ieee80211_hw *hw );
+void rtl92c_set_fw_pwrmode_cmd( struct ieee80211_hw *hw, u8 mode );
+void rtl92c_set_fw_joinbss_report_cmd( struct ieee80211_hw *hw, u8 mstatus );
+void rtl92c_fill_h2c_cmd( struct ieee80211_hw *hw,
+			 u8 element_id, u32 cmd_len, u8 *p_cmdbuffer );
+bool rtl92cu_phy_mac_config( struct ieee80211_hw *hw );
+void rtl92cu_update_hal_rate_tbl( struct ieee80211_hw *hw,
 				 struct ieee80211_sta *sta,
-				 u8 rssi_level);
+				 u8 rssi_level );
 
 #endif
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/led.c b/drivers/net/wireless/rtlwifi/rtl8192cu/led.c
index 75a2deb..7712174 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/led.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/led.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  *****************************************************************************/
 
 #include "../wifi.h"
@@ -30,112 +37,112 @@
 #include "reg.h"
 #include "led.h"
 
-static void _rtl92cu_init_led(struct ieee80211_hw *hw,
-			      struct rtl_led *pled, enum rtl_led_pin ledpin)
+static void _rtl92cu_init_led( struct ieee80211_hw *hw,
+			      struct rtl_led *pled, enum rtl_led_pin ledpin )
 {
 	pled->hw = hw;
 	pled->ledpin = ledpin;
 	pled->ledon = false;
 }
 
-static void _rtl92cu_deInit_led(struct rtl_led *pled)
+static void _rtl92cu_deInit_led( struct rtl_led *pled )
 {
 }
 
-void rtl92cu_sw_led_on(struct ieee80211_hw *hw, struct rtl_led *pled)
+void rtl92cu_sw_led_on( struct ieee80211_hw *hw, struct rtl_led *pled )
 {
 	u8 ledcfg;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	RT_TRACE(rtlpriv, COMP_LED, DBG_LOUD, "LedAddr:%X ledpin=%d\n",
-		 REG_LEDCFG2, pled->ledpin);
-	ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
-	switch (pled->ledpin) {
+	RT_TRACE( rtlpriv, COMP_LED, DBG_LOUD, "LedAddr:%X ledpin=%d\n",
+		 REG_LEDCFG2, pled->ledpin );
+	ledcfg = rtl_read_byte( rtlpriv, REG_LEDCFG2 );
+	switch ( pled->ledpin ) {
 	case LED_PIN_GPIO0:
 		break;
 	case LED_PIN_LED0:
-		rtl_write_byte(rtlpriv,
-			       REG_LEDCFG2, (ledcfg & 0xf0) | BIT(5) | BIT(6));
+		rtl_write_byte( rtlpriv,
+			       REG_LEDCFG2, ( ledcfg & 0xf0 ) | BIT( 5 ) | BIT( 6 ) );
 		break;
 	case LED_PIN_LED1:
-		rtl_write_byte(rtlpriv, REG_LEDCFG2, (ledcfg & 0x0f) | BIT(5));
+		rtl_write_byte( rtlpriv, REG_LEDCFG2, ( ledcfg & 0x0f ) | BIT( 5 ) );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	}
 	pled->ledon = true;
 }
 
-void rtl92cu_sw_led_off(struct ieee80211_hw *hw, struct rtl_led *pled)
+void rtl92cu_sw_led_off( struct ieee80211_hw *hw, struct rtl_led *pled )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb_priv *usbpriv = rtl_usbpriv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv( hw );
 	u8 ledcfg;
 
-	RT_TRACE(rtlpriv, COMP_LED, DBG_LOUD, "LedAddr:%X ledpin=%d\n",
-		 REG_LEDCFG2, pled->ledpin);
-	ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
-	switch (pled->ledpin) {
+	RT_TRACE( rtlpriv, COMP_LED, DBG_LOUD, "LedAddr:%X ledpin=%d\n",
+		 REG_LEDCFG2, pled->ledpin );
+	ledcfg = rtl_read_byte( rtlpriv, REG_LEDCFG2 );
+	switch ( pled->ledpin ) {
 	case LED_PIN_GPIO0:
 		break;
 	case LED_PIN_LED0:
 		ledcfg &= 0xf0;
-		if (usbpriv->ledctl.led_opendrain)
-			rtl_write_byte(rtlpriv, REG_LEDCFG2,
-				       (ledcfg | BIT(1) | BIT(5) | BIT(6)));
+		if ( usbpriv->ledctl.led_opendrain )
+			rtl_write_byte( rtlpriv, REG_LEDCFG2,
+				       ( ledcfg | BIT( 1 ) | BIT( 5 ) | BIT( 6 ) ) );
 		else
-			rtl_write_byte(rtlpriv, REG_LEDCFG2,
-				       (ledcfg | BIT(3) | BIT(5) | BIT(6)));
+			rtl_write_byte( rtlpriv, REG_LEDCFG2,
+				       ( ledcfg | BIT( 3 ) | BIT( 5 ) | BIT( 6 ) ) );
 		break;
 	case LED_PIN_LED1:
 		ledcfg &= 0x0f;
-		rtl_write_byte(rtlpriv, REG_LEDCFG2, (ledcfg | BIT(3)));
+		rtl_write_byte( rtlpriv, REG_LEDCFG2, ( ledcfg | BIT( 3 ) ) );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	}
 	pled->ledon = false;
 }
 
-void rtl92cu_init_sw_leds(struct ieee80211_hw *hw)
+void rtl92cu_init_sw_leds( struct ieee80211_hw *hw )
 {
-	struct rtl_usb_priv *usbpriv = rtl_usbpriv(hw);
-	_rtl92cu_init_led(hw, &(usbpriv->ledctl.sw_led0), LED_PIN_LED0);
-	_rtl92cu_init_led(hw, &(usbpriv->ledctl.sw_led1), LED_PIN_LED1);
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv( hw );
+	_rtl92cu_init_led( hw, &( usbpriv->ledctl.sw_led0 ), LED_PIN_LED0 );
+	_rtl92cu_init_led( hw, &( usbpriv->ledctl.sw_led1 ), LED_PIN_LED1 );
 }
 
-void rtl92cu_deinit_sw_leds(struct ieee80211_hw *hw)
+void rtl92cu_deinit_sw_leds( struct ieee80211_hw *hw )
 {
-	struct rtl_usb_priv *usbpriv = rtl_usbpriv(hw);
-	_rtl92cu_deInit_led(&(usbpriv->ledctl.sw_led0));
-	_rtl92cu_deInit_led(&(usbpriv->ledctl.sw_led1));
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv( hw );
+	_rtl92cu_deInit_led( &( usbpriv->ledctl.sw_led0 ) );
+	_rtl92cu_deInit_led( &( usbpriv->ledctl.sw_led1 ) );
 }
 
-static void _rtl92cu_sw_led_control(struct ieee80211_hw *hw,
-				    enum led_ctl_mode ledaction)
+static void _rtl92cu_sw_led_control( struct ieee80211_hw *hw,
+				    enum led_ctl_mode ledaction )
 {
 }
 
-void rtl92cu_led_control(struct ieee80211_hw *hw,
-			enum led_ctl_mode ledaction)
+void rtl92cu_led_control( struct ieee80211_hw *hw,
+			enum led_ctl_mode ledaction )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
 
-	if ((ppsc->rfoff_reason > RF_CHANGE_BY_PS) &&
-	    (ledaction == LED_CTL_TX ||
+	if ( ( ppsc->rfoff_reason > RF_CHANGE_BY_PS ) &&
+	    ( ledaction == LED_CTL_TX ||
 	     ledaction == LED_CTL_RX ||
 	     ledaction == LED_CTL_SITE_SURVEY ||
 	     ledaction == LED_CTL_LINK ||
 	     ledaction == LED_CTL_NO_LINK ||
 	     ledaction == LED_CTL_START_TO_LINK ||
-	     ledaction == LED_CTL_POWER_ON)) {
+	     ledaction == LED_CTL_POWER_ON ) ) {
 		return;
 	}
-	RT_TRACE(rtlpriv, COMP_LED, DBG_LOUD, "ledaction %d\n", ledaction);
-	_rtl92cu_sw_led_control(hw, ledaction);
+	RT_TRACE( rtlpriv, COMP_LED, DBG_LOUD, "ledaction %d\n", ledaction );
+	_rtl92cu_sw_led_control( hw, ledaction );
 }
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/led.h b/drivers/net/wireless/rtlwifi/rtl8192cu/led.h
index 0f37227..9705e02 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/led.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/led.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,15 +23,22 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  *****************************************************************************/
 
 #ifndef __RTL92CU_LED_H__
 #define __RTL92CU_LED_H__
 
-void rtl92cu_init_sw_leds(struct ieee80211_hw *hw);
-void rtl92cu_deinit_sw_leds(struct ieee80211_hw *hw);
-void rtl92cu_sw_led_on(struct ieee80211_hw *hw, struct rtl_led *pled);
-void rtl92cu_sw_led_off(struct ieee80211_hw *hw, struct rtl_led *pled);
-void rtl92cu_led_control(struct ieee80211_hw *hw, enum led_ctl_mode ledaction);
+void rtl92cu_init_sw_leds( struct ieee80211_hw *hw );
+void rtl92cu_deinit_sw_leds( struct ieee80211_hw *hw );
+void rtl92cu_sw_led_on( struct ieee80211_hw *hw, struct rtl_led *pled );
+void rtl92cu_sw_led_off( struct ieee80211_hw *hw, struct rtl_led *pled );
+void rtl92cu_led_control( struct ieee80211_hw *hw, enum led_ctl_mode ledaction );
 
 #endif
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/mac.c b/drivers/net/wireless/rtlwifi/rtl8192cu/mac.c
index c2d8ec6..4d3e6ac 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/mac.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/mac.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
 ****************************************************************************/
@@ -51,42 +58,42 @@
 #define RX_SIGQ	rx_mimo_sig_qual
 
 
-void rtl92c_read_chip_version(struct ieee80211_hw *hw)
+void rtl92c_read_chip_version( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 	enum version_8192c chip_version = VERSION_UNKNOWN;
 	const char *versionid;
 	u32 value32;
 
-	value32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);
-	if (value32 & TRP_VAUX_EN) {
-		chip_version = (value32 & TYPE_ID) ? VERSION_TEST_CHIP_92C :
+	value32 = rtl_read_dword( rtlpriv, REG_SYS_CFG );
+	if ( value32 & TRP_VAUX_EN ) {
+		chip_version = ( value32 & TYPE_ID ) ? VERSION_TEST_CHIP_92C :
 			       VERSION_TEST_CHIP_88C;
 	} else {
 		/* Normal mass production chip. */
 		chip_version = NORMAL_CHIP;
-		chip_version |= ((value32 & TYPE_ID) ? CHIP_92C : 0);
-		chip_version |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);
+		chip_version |= ( ( value32 & TYPE_ID ) ? CHIP_92C : 0 );
+		chip_version |= ( ( value32 & VENDOR_ID ) ? CHIP_VENDOR_UMC : 0 );
 		/* RTL8723 with BT function. */
-		chip_version |= ((value32 & BT_FUNC) ? CHIP_8723 : 0);
-		if (IS_VENDOR_UMC(chip_version))
-			chip_version |= ((value32 & CHIP_VER_RTL_MASK) ?
-					 CHIP_VENDOR_UMC_B_CUT : 0);
-		if (IS_92C_SERIAL(chip_version)) {
-			value32 = rtl_read_dword(rtlpriv, REG_HPON_FSM);
-			chip_version |= ((CHIP_BONDING_IDENTIFIER(value32) ==
-				 CHIP_BONDING_92C_1T2R) ? CHIP_92C_1T2R : 0);
-		} else if (IS_8723_SERIES(chip_version)) {
-			value32 = rtl_read_dword(rtlpriv, REG_GPIO_OUTSTS);
-			chip_version |= ((value32 & RF_RL_ID) ?
-					  CHIP_8723_DRV_REV : 0);
+		chip_version |= ( ( value32 & BT_FUNC ) ? CHIP_8723 : 0 );
+		if ( IS_VENDOR_UMC( chip_version ) )
+			chip_version |= ( ( value32 & CHIP_VER_RTL_MASK ) ?
+					 CHIP_VENDOR_UMC_B_CUT : 0 );
+		if ( IS_92C_SERIAL( chip_version ) ) {
+			value32 = rtl_read_dword( rtlpriv, REG_HPON_FSM );
+			chip_version |= ( ( CHIP_BONDING_IDENTIFIER( value32 ) ==
+				 CHIP_BONDING_92C_1T2R ) ? CHIP_92C_1T2R : 0 );
+		} else if ( IS_8723_SERIES( chip_version ) ) {
+			value32 = rtl_read_dword( rtlpriv, REG_GPIO_OUTSTS );
+			chip_version |= ( ( value32 & RF_RL_ID ) ?
+					  CHIP_8723_DRV_REV : 0 );
 		}
 	}
-	rtlhal->version  = (enum version_8192c)chip_version;
-	pr_info("Chip version 0x%x\n", chip_version);
-	switch (rtlhal->version) {
+	rtlhal->version  = ( enum version_8192c )chip_version;
+	pr_info( "Chip version 0x%x\n", chip_version );
+	switch ( rtlhal->version ) {
 	case VERSION_NORMAL_TSMC_CHIP_92C_1T2R:
 		versionid = "NORMAL_B_CHIP_92C";
 		break;
@@ -130,24 +137,24 @@ void rtl92c_read_chip_version(struct ieee80211_hw *hw)
 		versionid = "UNKNOWN";
 		break;
 	}
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-		 "Chip Version ID: %s\n", versionid);
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+		 "Chip Version ID: %s\n", versionid );
 
-	if (IS_92C_SERIAL(rtlhal->version))
+	if ( IS_92C_SERIAL( rtlhal->version ) )
 		rtlphy->rf_type =
-			 (IS_92C_1T2R(rtlhal->version)) ? RF_1T2R : RF_2T2R;
+			 ( IS_92C_1T2R( rtlhal->version ) ) ? RF_1T2R : RF_2T2R;
 	else
 		rtlphy->rf_type = RF_1T1R;
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD,
 		 "Chip RF Type: %s\n",
-		 rtlphy->rf_type == RF_2T2R ? "RF_2T2R" : "RF_1T1R");
-	if (get_rf_type(rtlphy) == RF_1T1R)
+		 rtlphy->rf_type == RF_2T2R ? "RF_2T2R" : "RF_1T1R" );
+	if ( get_rf_type( rtlphy ) == RF_1T1R )
 		rtlpriv->dm.rfpath_rxenable[0] = true;
 	else
 		rtlpriv->dm.rfpath_rxenable[0] =
 		    rtlpriv->dm.rfpath_rxenable[1] = true;
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "VersionID = 0x%4x\n",
-		 rtlhal->version);
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_LOUD, "VersionID = 0x%4x\n",
+		 rtlhal->version );
 }
 
 /**
@@ -159,27 +166,27 @@ void rtl92c_read_chip_version(struct ieee80211_hw *hw)
  * Realtek hardware access function.
  *
  */
-bool rtl92c_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)
+bool rtl92c_llt_write( struct ieee80211_hw *hw, u32 address, u32 data )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	bool status = true;
 	long count = 0;
-	u32 value = _LLT_INIT_ADDR(address) |
-	    _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
+	u32 value = _LLT_INIT_ADDR( address ) |
+	    _LLT_INIT_DATA( data ) | _LLT_OP( _LLT_WRITE_ACCESS );
 
-	rtl_write_dword(rtlpriv, REG_LLT_INIT, value);
+	rtl_write_dword( rtlpriv, REG_LLT_INIT, value );
 	do {
-		value = rtl_read_dword(rtlpriv, REG_LLT_INIT);
-		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))
+		value = rtl_read_dword( rtlpriv, REG_LLT_INIT );
+		if ( _LLT_NO_ACTIVE == _LLT_OP_VALUE( value ) )
 			break;
-		if (count > POLLING_LLT_THRESHOLD) {
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
+		if ( count > POLLING_LLT_THRESHOLD ) {
+			RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
 				 "Failed to polling write LLT done at address %d! _LLT_OP_VALUE(%x)\n",
-				 address, _LLT_OP_VALUE(value));
+				 address, _LLT_OP_VALUE( value ) );
 			status = false;
 			break;
 		}
-	} while (++count);
+	} while ( ++count );
 	return status;
 }
 /**
@@ -190,22 +197,22 @@ bool rtl92c_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)
  * Realtek hardware access function.
  *
  */
-bool rtl92c_init_llt_table(struct ieee80211_hw *hw, u32 boundary)
+bool rtl92c_init_llt_table( struct ieee80211_hw *hw, u32 boundary )
 {
 	bool rst = true;
 	u32	i;
 
-	for (i = 0; i < (boundary - 1); i++) {
-		rst = rtl92c_llt_write(hw, i , i + 1);
-		if (true != rst) {
-			pr_err("===> %s #1 fail\n", __func__);
+	for ( i = 0; i < ( boundary - 1 ); i++ ) {
+		rst = rtl92c_llt_write( hw, i , i + 1 );
+		if ( true != rst ) {
+			pr_err( "===> %s #1 fail\n", __func__ );
 			return rst;
 		}
 	}
 	/* end of list */
-	rst = rtl92c_llt_write(hw, (boundary - 1), 0xFF);
-	if (true != rst) {
-		pr_err("===> %s #2 fail\n", __func__);
+	rst = rtl92c_llt_write( hw, ( boundary - 1 ), 0xFF );
+	if ( true != rst ) {
+		pr_err( "===> %s #2 fail\n", __func__ );
 		return rst;
 	}
 	/* Make the other pages as ring buffer
@@ -213,28 +220,28 @@ bool rtl92c_init_llt_table(struct ieee80211_hw *hw, u32 boundary)
 	 *  as two MAC transfer.
 	 * Otherwise used as local loopback buffer.
 	 */
-	for (i = boundary; i < LLT_LAST_ENTRY_OF_TX_PKT_BUFFER; i++) {
-		rst = rtl92c_llt_write(hw, i, (i + 1));
-		if (true != rst) {
-			pr_err("===> %s #3 fail\n", __func__);
+	for ( i = boundary; i < LLT_LAST_ENTRY_OF_TX_PKT_BUFFER; i++ ) {
+		rst = rtl92c_llt_write( hw, i, ( i + 1 ) );
+		if ( true != rst ) {
+			pr_err( "===> %s #3 fail\n", __func__ );
 			return rst;
 		}
 	}
 	/* Let last entry point to the start entry of ring buffer */
-	rst = rtl92c_llt_write(hw, LLT_LAST_ENTRY_OF_TX_PKT_BUFFER, boundary);
-	if (true != rst) {
-		pr_err("===> %s #4 fail\n", __func__);
+	rst = rtl92c_llt_write( hw, LLT_LAST_ENTRY_OF_TX_PKT_BUFFER, boundary );
+	if ( true != rst ) {
+		pr_err( "===> %s #4 fail\n", __func__ );
 		return rst;
 	}
 	return rst;
 }
-void rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,
+void rtl92c_set_key( struct ieee80211_hw *hw, u32 key_index,
 		     u8 *p_macaddr, bool is_group, u8 enc_algo,
-		     bool is_wepkey, bool clear_all)
+		     bool is_wepkey, bool clear_all )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	u8 *macaddr = p_macaddr;
 	u32 entry_id = 0;
 	bool is_pairwise = false;
@@ -248,23 +255,23 @@ void rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,
 		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 	};
 
-	if (clear_all) {
+	if ( clear_all ) {
 		u8 idx = 0;
 		u8 cam_offset = 0;
 		u8 clear_number = 5;
 
-		RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "clear_all\n");
-		for (idx = 0; idx < clear_number; idx++) {
-			rtl_cam_mark_invalid(hw, cam_offset + idx);
-			rtl_cam_empty_entry(hw, cam_offset + idx);
-			if (idx < 5) {
-				memset(rtlpriv->sec.key_buf[idx], 0,
-				       MAX_KEY_LEN);
+		RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG, "clear_all\n" );
+		for ( idx = 0; idx < clear_number; idx++ ) {
+			rtl_cam_mark_invalid( hw, cam_offset + idx );
+			rtl_cam_empty_entry( hw, cam_offset + idx );
+			if ( idx < 5 ) {
+				memset( rtlpriv->sec.key_buf[idx], 0,
+				       MAX_KEY_LEN );
 				rtlpriv->sec.key_len[idx] = 0;
 			}
 		}
 	} else {
-		switch (enc_algo) {
+		switch ( enc_algo ) {
 		case WEP40_ENCRYPTION:
 			enc_algo = CAM_WEP40;
 			break;
@@ -278,27 +285,27 @@ void rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,
 			enc_algo = CAM_AES;
 			break;
 		default:
-			RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-				 "illegal switch case\n");
+			RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+				 "illegal switch case\n" );
 			enc_algo = CAM_TKIP;
 			break;
 		}
-		if (is_wepkey || rtlpriv->sec.use_defaultkey) {
+		if ( is_wepkey || rtlpriv->sec.use_defaultkey ) {
 			macaddr = cam_const_addr[key_index];
 			entry_id = key_index;
 		} else {
-			if (is_group) {
+			if ( is_group ) {
 				macaddr = cam_const_broad;
 				entry_id = key_index;
 			} else {
-				if (mac->opmode == NL80211_IFTYPE_AP ||
-				    mac->opmode == NL80211_IFTYPE_MESH_POINT) {
-					entry_id = rtl_cam_get_free_entry(hw,
-								 p_macaddr);
-					if (entry_id >=  TOTAL_CAM_ENTRY) {
-						RT_TRACE(rtlpriv, COMP_SEC,
+				if ( mac->opmode == NL80211_IFTYPE_AP ||
+				    mac->opmode == NL80211_IFTYPE_MESH_POINT ) {
+					entry_id = rtl_cam_get_free_entry( hw,
+								 p_macaddr );
+					if ( entry_id >=  TOTAL_CAM_ENTRY ) {
+						RT_TRACE( rtlpriv, COMP_SEC,
 							 DBG_EMERG,
-							 "Can not find free hw security cam entry\n");
+							 "Can not find free hw security cam entry\n" );
 						return;
 					}
 				} else {
@@ -309,132 +316,132 @@ void rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,
 				is_pairwise = true;
 			}
 		}
-		if (rtlpriv->sec.key_len[key_index] == 0) {
-			RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
-				 "delete one entry\n");
-			if (mac->opmode == NL80211_IFTYPE_AP ||
-			    mac->opmode == NL80211_IFTYPE_MESH_POINT)
-				rtl_cam_del_entry(hw, p_macaddr);
-			rtl_cam_delete_one_entry(hw, p_macaddr, entry_id);
+		if ( rtlpriv->sec.key_len[key_index] == 0 ) {
+			RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG,
+				 "delete one entry\n" );
+			if ( mac->opmode == NL80211_IFTYPE_AP ||
+			    mac->opmode == NL80211_IFTYPE_MESH_POINT )
+				rtl_cam_del_entry( hw, p_macaddr );
+			rtl_cam_delete_one_entry( hw, p_macaddr, entry_id );
 		} else {
-			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+			RT_TRACE( rtlpriv, COMP_SEC, DBG_LOUD,
 				 "The insert KEY length is %d\n",
-				 rtlpriv->sec.key_len[PAIRWISE_KEYIDX]);
-			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 rtlpriv->sec.key_len[PAIRWISE_KEYIDX] );
+			RT_TRACE( rtlpriv, COMP_SEC, DBG_LOUD,
 				 "The insert KEY is %x %x\n",
 				 rtlpriv->sec.key_buf[0][0],
-				 rtlpriv->sec.key_buf[0][1]);
-			RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
-				 "add one entry\n");
-			if (is_pairwise) {
-				RT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_LOUD,
+				 rtlpriv->sec.key_buf[0][1] );
+			RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG,
+				 "add one entry\n" );
+			if ( is_pairwise ) {
+				RT_PRINT_DATA( rtlpriv, COMP_SEC, DBG_LOUD,
 					      "Pairwise Key content",
 					      rtlpriv->sec.pairwise_key,
 					      rtlpriv->sec.
-					      key_len[PAIRWISE_KEYIDX]);
-				RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
-					 "set Pairwise key\n");
+					      key_len[PAIRWISE_KEYIDX] );
+				RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG,
+					 "set Pairwise key\n" );
 
-				rtl_cam_add_one_entry(hw, macaddr, key_index,
+				rtl_cam_add_one_entry( hw, macaddr, key_index,
 						entry_id, enc_algo,
 						CAM_CONFIG_NO_USEDK,
 						rtlpriv->sec.
-						key_buf[key_index]);
+						key_buf[key_index] );
 			} else {
-				RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
-					 "set group key\n");
-				if (mac->opmode == NL80211_IFTYPE_ADHOC) {
-					rtl_cam_add_one_entry(hw,
+				RT_TRACE( rtlpriv, COMP_SEC, DBG_DMESG,
+					 "set group key\n" );
+				if ( mac->opmode == NL80211_IFTYPE_ADHOC ) {
+					rtl_cam_add_one_entry( hw,
 						rtlefuse->dev_addr,
 						PAIRWISE_KEYIDX,
 						CAM_PAIRWISE_KEY_POSITION,
 						enc_algo,
 						CAM_CONFIG_NO_USEDK,
 						rtlpriv->sec.key_buf
-						[entry_id]);
+						[entry_id] );
 				}
-				rtl_cam_add_one_entry(hw, macaddr, key_index,
+				rtl_cam_add_one_entry( hw, macaddr, key_index,
 						entry_id, enc_algo,
 						CAM_CONFIG_NO_USEDK,
-						rtlpriv->sec.key_buf[entry_id]);
+						rtlpriv->sec.key_buf[entry_id] );
 			}
 		}
 	}
 }
 
-u32 rtl92c_get_txdma_status(struct ieee80211_hw *hw)
+u32 rtl92c_get_txdma_status( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	return rtl_read_dword(rtlpriv, REG_TXDMA_STATUS);
+	return rtl_read_dword( rtlpriv, REG_TXDMA_STATUS );
 }
 
-void rtl92c_enable_interrupt(struct ieee80211_hw *hw)
+void rtl92c_enable_interrupt( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	struct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_pci *rtlpci = rtl_pcidev( rtl_pcipriv( hw ) );
+	struct rtl_usb *rtlusb = rtl_usbdev( rtl_usbpriv( hw ) );
 
-	if (IS_HARDWARE_TYPE_8192CE(rtlhal)) {
-		rtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] &
-				0xFFFFFFFF);
-		rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] &
-				0xFFFFFFFF);
+	if ( IS_HARDWARE_TYPE_8192CE( rtlhal ) ) {
+		rtl_write_dword( rtlpriv, REG_HIMR, rtlpci->irq_mask[0] &
+				0xFFFFFFFF );
+		rtl_write_dword( rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] &
+				0xFFFFFFFF );
 	} else {
-		rtl_write_dword(rtlpriv, REG_HIMR, rtlusb->irq_mask[0] &
-				0xFFFFFFFF);
-		rtl_write_dword(rtlpriv, REG_HIMRE, rtlusb->irq_mask[1] &
-				0xFFFFFFFF);
+		rtl_write_dword( rtlpriv, REG_HIMR, rtlusb->irq_mask[0] &
+				0xFFFFFFFF );
+		rtl_write_dword( rtlpriv, REG_HIMRE, rtlusb->irq_mask[1] &
+				0xFFFFFFFF );
 	}
 }
 
-void rtl92c_init_interrupt(struct ieee80211_hw *hw)
+void rtl92c_init_interrupt( struct ieee80211_hw *hw )
 {
-	 rtl92c_enable_interrupt(hw);
+	 rtl92c_enable_interrupt( hw );
 }
 
-void rtl92c_disable_interrupt(struct ieee80211_hw *hw)
+void rtl92c_disable_interrupt( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_dword(rtlpriv, REG_HIMR, IMR8190_DISABLED);
-	rtl_write_dword(rtlpriv, REG_HIMRE, IMR8190_DISABLED);
+	rtl_write_dword( rtlpriv, REG_HIMR, IMR8190_DISABLED );
+	rtl_write_dword( rtlpriv, REG_HIMRE, IMR8190_DISABLED );
 }
 
-void rtl92c_set_qos(struct ieee80211_hw *hw, int aci)
+void rtl92c_set_qos( struct ieee80211_hw *hw, int aci )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	u32 u4b_ac_param;
 
-	rtl92c_dm_init_edca_turbo(hw);
-	u4b_ac_param = (u32) mac->ac[aci].aifs;
+	rtl92c_dm_init_edca_turbo( hw );
+	u4b_ac_param = ( u32 ) mac->ac[aci].aifs;
 	u4b_ac_param |=
-	    ((u32) le16_to_cpu(mac->ac[aci].cw_min) & 0xF) <<
+	    ( ( u32 ) le16_to_cpu( mac->ac[aci].cw_min ) & 0xF ) <<
 	    AC_PARAM_ECW_MIN_OFFSET;
 	u4b_ac_param |=
-	    ((u32) le16_to_cpu(mac->ac[aci].cw_max) & 0xF) <<
+	    ( ( u32 ) le16_to_cpu( mac->ac[aci].cw_max ) & 0xF ) <<
 	    AC_PARAM_ECW_MAX_OFFSET;
-	u4b_ac_param |= (u32) le16_to_cpu(mac->ac[aci].tx_op) <<
+	u4b_ac_param |= ( u32 ) le16_to_cpu( mac->ac[aci].tx_op ) <<
 			 AC_PARAM_TXOP_OFFSET;
-	RT_TRACE(rtlpriv, COMP_QOS, DBG_LOUD, "queue:%x, ac_param:%x\n",
-		 aci, u4b_ac_param);
-	switch (aci) {
+	RT_TRACE( rtlpriv, COMP_QOS, DBG_LOUD, "queue:%x, ac_param:%x\n",
+		 aci, u4b_ac_param );
+	switch ( aci ) {
 	case AC1_BK:
-		rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, u4b_ac_param);
+		rtl_write_dword( rtlpriv, REG_EDCA_BK_PARAM, u4b_ac_param );
 		break;
 	case AC0_BE:
-		rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, u4b_ac_param);
+		rtl_write_dword( rtlpriv, REG_EDCA_BE_PARAM, u4b_ac_param );
 		break;
 	case AC2_VI:
-		rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, u4b_ac_param);
+		rtl_write_dword( rtlpriv, REG_EDCA_VI_PARAM, u4b_ac_param );
 		break;
 	case AC3_VO:
-		rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, u4b_ac_param);
+		rtl_write_dword( rtlpriv, REG_EDCA_VO_PARAM, u4b_ac_param );
 		break;
 	default:
-		RT_ASSERT(false, "invalid aci: %d !\n", aci);
+		RT_ASSERT( false, "invalid aci: %d !\n", aci );
 		break;
 	}
 }
@@ -442,342 +449,342 @@ void rtl92c_set_qos(struct ieee80211_hw *hw, int aci)
 /*-------------------------------------------------------------------------
  * HW MAC Address
  *-------------------------------------------------------------------------*/
-void rtl92c_set_mac_addr(struct ieee80211_hw *hw, const u8 *addr)
+void rtl92c_set_mac_addr( struct ieee80211_hw *hw, const u8 *addr )
 {
 	u32 i;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	for (i = 0 ; i < ETH_ALEN ; i++)
-		rtl_write_byte(rtlpriv, (REG_MACID + i), *(addr+i));
+	for ( i = 0 ; i < ETH_ALEN ; i++ )
+		rtl_write_byte( rtlpriv, ( REG_MACID + i ), *( addr+i ) );
 
-	RT_TRACE(rtlpriv, COMP_CMD, DBG_DMESG,
+	RT_TRACE( rtlpriv, COMP_CMD, DBG_DMESG,
 		 "MAC Address: %02X-%02X-%02X-%02X-%02X-%02X\n",
-		 rtl_read_byte(rtlpriv, REG_MACID),
-		 rtl_read_byte(rtlpriv, REG_MACID+1),
-		 rtl_read_byte(rtlpriv, REG_MACID+2),
-		 rtl_read_byte(rtlpriv, REG_MACID+3),
-		 rtl_read_byte(rtlpriv, REG_MACID+4),
-		 rtl_read_byte(rtlpriv, REG_MACID+5));
+		 rtl_read_byte( rtlpriv, REG_MACID ),
+		 rtl_read_byte( rtlpriv, REG_MACID+1 ),
+		 rtl_read_byte( rtlpriv, REG_MACID+2 ),
+		 rtl_read_byte( rtlpriv, REG_MACID+3 ),
+		 rtl_read_byte( rtlpriv, REG_MACID+4 ),
+		 rtl_read_byte( rtlpriv, REG_MACID+5 ) );
 }
 
-void rtl92c_init_driver_info_size(struct ieee80211_hw *hw, u8 size)
+void rtl92c_init_driver_info_size( struct ieee80211_hw *hw, u8 size )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	rtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, size);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	rtl_write_byte( rtlpriv, REG_RX_DRVINFO_SZ, size );
 }
 
-int rtl92c_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)
+int rtl92c_set_network_type( struct ieee80211_hw *hw, enum nl80211_iftype type )
 {
 	u8 value;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	switch (type) {
+	switch ( type ) {
 	case NL80211_IFTYPE_UNSPECIFIED:
 		value = NT_NO_LINK;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Set Network type to NO LINK!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Set Network type to NO LINK!\n" );
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		value = NT_LINK_AD_HOC;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Set Network type to Ad Hoc!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Set Network type to Ad Hoc!\n" );
 		break;
 	case NL80211_IFTYPE_STATION:
 		value = NT_LINK_AP;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Set Network type to STA!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Set Network type to STA!\n" );
 		break;
 	case NL80211_IFTYPE_AP:
 		value = NT_AS_AP;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Set Network type to AP!\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Set Network type to AP!\n" );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Network type %d not supported!\n", type);
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Network type %d not supported!\n", type );
 		return -EOPNOTSUPP;
 	}
-	rtl_write_byte(rtlpriv, (REG_CR + 2), value);
+	rtl_write_byte( rtlpriv, ( REG_CR + 2 ), value );
 	return 0;
 }
 
-void rtl92c_init_network_type(struct ieee80211_hw *hw)
+void rtl92c_init_network_type( struct ieee80211_hw *hw )
 {
-	rtl92c_set_network_type(hw, NL80211_IFTYPE_UNSPECIFIED);
+	rtl92c_set_network_type( hw, NL80211_IFTYPE_UNSPECIFIED );
 }
 
-void rtl92c_init_adaptive_ctrl(struct ieee80211_hw *hw)
+void rtl92c_init_adaptive_ctrl( struct ieee80211_hw *hw )
 {
 	u16	value16;
 	u32	value32;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
 	/* Response Rate Set */
-	value32 = rtl_read_dword(rtlpriv, REG_RRSR);
+	value32 = rtl_read_dword( rtlpriv, REG_RRSR );
 	value32 &= ~RATE_BITMAP_ALL;
 	value32 |= RATE_RRSR_CCK_ONLY_1M;
-	rtl_write_dword(rtlpriv, REG_RRSR, value32);
-	/* SIFS (used in NAV) */
-	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
-	rtl_write_word(rtlpriv,  REG_SPEC_SIFS, value16);
+	rtl_write_dword( rtlpriv, REG_RRSR, value32 );
+	/* SIFS ( used in NAV ) */
+	value16 = _SPEC_SIFS_CCK( 0x10 ) | _SPEC_SIFS_OFDM( 0x10 );
+	rtl_write_word( rtlpriv,  REG_SPEC_SIFS, value16 );
 	/* Retry Limit */
-	value16 = _LRL(0x30) | _SRL(0x30);
-	rtl_write_dword(rtlpriv,  REG_RL, value16);
+	value16 = _LRL( 0x30 ) | _SRL( 0x30 );
+	rtl_write_dword( rtlpriv,  REG_RL, value16 );
 }
 
-void rtl92c_init_rate_fallback(struct ieee80211_hw *hw)
+void rtl92c_init_rate_fallback( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
 	/* Set Data Auto Rate Fallback Retry Count register. */
-	rtl_write_dword(rtlpriv,  REG_DARFRC, 0x00000000);
-	rtl_write_dword(rtlpriv,  REG_DARFRC+4, 0x10080404);
-	rtl_write_dword(rtlpriv,  REG_RARFRC, 0x04030201);
-	rtl_write_dword(rtlpriv,  REG_RARFRC+4, 0x08070605);
+	rtl_write_dword( rtlpriv,  REG_DARFRC, 0x00000000 );
+	rtl_write_dword( rtlpriv,  REG_DARFRC+4, 0x10080404 );
+	rtl_write_dword( rtlpriv,  REG_RARFRC, 0x04030201 );
+	rtl_write_dword( rtlpriv,  REG_RARFRC+4, 0x08070605 );
 }
 
-static void rtl92c_set_cck_sifs(struct ieee80211_hw *hw, u8 trx_sifs,
-				u8 ctx_sifs)
+static void rtl92c_set_cck_sifs( struct ieee80211_hw *hw, u8 trx_sifs,
+				u8 ctx_sifs )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_byte(rtlpriv, REG_SIFS_CCK, trx_sifs);
-	rtl_write_byte(rtlpriv, (REG_SIFS_CCK + 1), ctx_sifs);
+	rtl_write_byte( rtlpriv, REG_SIFS_CCK, trx_sifs );
+	rtl_write_byte( rtlpriv, ( REG_SIFS_CCK + 1 ), ctx_sifs );
 }
 
-static void rtl92c_set_ofdm_sifs(struct ieee80211_hw *hw, u8 trx_sifs,
-				 u8 ctx_sifs)
+static void rtl92c_set_ofdm_sifs( struct ieee80211_hw *hw, u8 trx_sifs,
+				 u8 ctx_sifs )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_byte(rtlpriv, REG_SIFS_OFDM, trx_sifs);
-	rtl_write_byte(rtlpriv, (REG_SIFS_OFDM + 1), ctx_sifs);
+	rtl_write_byte( rtlpriv, REG_SIFS_OFDM, trx_sifs );
+	rtl_write_byte( rtlpriv, ( REG_SIFS_OFDM + 1 ), ctx_sifs );
 }
 
-void rtl92c_init_edca_param(struct ieee80211_hw *hw,
-			    u16 queue, u16 txop, u8 cw_min, u8 cw_max, u8 aifs)
+void rtl92c_init_edca_param( struct ieee80211_hw *hw,
+			    u16 queue, u16 txop, u8 cw_min, u8 cw_max, u8 aifs )
 {
 	/* sequence: VO, VI, BE, BK ==> the same as 92C hardware design.
 	 * referenc : enum nl80211_txq_q or ieee80211_set_wmm_default function.
 	 */
 	u32 value;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	value = (u32)aifs;
-	value |= ((u32)cw_min & 0xF) << 8;
-	value |= ((u32)cw_max & 0xF) << 12;
-	value |= (u32)txop << 16;
+	value = ( u32 )aifs;
+	value |= ( ( u32 )cw_min & 0xF ) << 8;
+	value |= ( ( u32 )cw_max & 0xF ) << 12;
+	value |= ( u32 )txop << 16;
 	/* 92C hardware register sequence is the same as queue number. */
-	rtl_write_dword(rtlpriv, (REG_EDCA_VO_PARAM + (queue * 4)), value);
+	rtl_write_dword( rtlpriv, ( REG_EDCA_VO_PARAM + ( queue * 4 ) ), value );
 }
 
-void rtl92c_init_edca(struct ieee80211_hw *hw)
+void rtl92c_init_edca( struct ieee80211_hw *hw )
 {
 	u16 value16;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
 	/* disable EDCCA count down, to reduce collison and retry */
-	value16 = rtl_read_word(rtlpriv, REG_RD_CTRL);
+	value16 = rtl_read_word( rtlpriv, REG_RD_CTRL );
 	value16 |= DIS_EDCA_CNT_DWN;
-	rtl_write_word(rtlpriv, REG_RD_CTRL, value16);
+	rtl_write_word( rtlpriv, REG_RD_CTRL, value16 );
 	/* Update SIFS timing.  ??????????
 	 * pHalData->SifsTime = 0x0e0e0a0a; */
-	rtl92c_set_cck_sifs(hw, 0xa, 0xa);
-	rtl92c_set_ofdm_sifs(hw, 0xe, 0xe);
+	rtl92c_set_cck_sifs( hw, 0xa, 0xa );
+	rtl92c_set_ofdm_sifs( hw, 0xe, 0xe );
 	/* Set CCK/OFDM SIFS to be 10us. */
-	rtl_write_word(rtlpriv, REG_SIFS_CCK, 0x0a0a);
-	rtl_write_word(rtlpriv, REG_SIFS_OFDM, 0x1010);
-	rtl_write_word(rtlpriv, REG_PROT_MODE_CTRL, 0x0204);
-	rtl_write_dword(rtlpriv, REG_BAR_MODE_CTRL, 0x014004);
+	rtl_write_word( rtlpriv, REG_SIFS_CCK, 0x0a0a );
+	rtl_write_word( rtlpriv, REG_SIFS_OFDM, 0x1010 );
+	rtl_write_word( rtlpriv, REG_PROT_MODE_CTRL, 0x0204 );
+	rtl_write_dword( rtlpriv, REG_BAR_MODE_CTRL, 0x014004 );
 	/* TXOP */
-	rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, 0x005EA42B);
-	rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0x0000A44F);
-	rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x005EA324);
-	rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x002FA226);
+	rtl_write_dword( rtlpriv, REG_EDCA_BE_PARAM, 0x005EA42B );
+	rtl_write_dword( rtlpriv, REG_EDCA_BK_PARAM, 0x0000A44F );
+	rtl_write_dword( rtlpriv, REG_EDCA_VI_PARAM, 0x005EA324 );
+	rtl_write_dword( rtlpriv, REG_EDCA_VO_PARAM, 0x002FA226 );
 	/* PIFS */
-	rtl_write_byte(rtlpriv, REG_PIFS, 0x1C);
+	rtl_write_byte( rtlpriv, REG_PIFS, 0x1C );
 	/* AGGR BREAK TIME Register */
-	rtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);
-	rtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0040);
-	rtl_write_byte(rtlpriv, REG_BCNDMATIM, 0x02);
-	rtl_write_byte(rtlpriv, REG_ATIMWND, 0x02);
+	rtl_write_byte( rtlpriv, REG_AGGR_BREAK_TIME, 0x16 );
+	rtl_write_word( rtlpriv, REG_NAV_PROT_LEN, 0x0040 );
+	rtl_write_byte( rtlpriv, REG_BCNDMATIM, 0x02 );
+	rtl_write_byte( rtlpriv, REG_ATIMWND, 0x02 );
 }
 
-void rtl92c_init_ampdu_aggregation(struct ieee80211_hw *hw)
+void rtl92c_init_ampdu_aggregation( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0x99997631);
-	rtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);
+	rtl_write_dword( rtlpriv, REG_AGGLEN_LMT, 0x99997631 );
+	rtl_write_byte( rtlpriv, REG_AGGR_BREAK_TIME, 0x16 );
 	/* init AMPDU aggregation number, tuning for Tx's TP, */
-	rtl_write_word(rtlpriv, 0x4CA, 0x0708);
+	rtl_write_word( rtlpriv, 0x4CA, 0x0708 );
 }
 
-void rtl92c_init_beacon_max_error(struct ieee80211_hw *hw, bool infra_mode)
+void rtl92c_init_beacon_max_error( struct ieee80211_hw *hw, bool infra_mode )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xFF);
+	rtl_write_byte( rtlpriv, REG_BCN_MAX_ERR, 0xFF );
 }
 
-void rtl92c_init_rdg_setting(struct ieee80211_hw *hw)
+void rtl92c_init_rdg_setting( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_byte(rtlpriv, REG_RD_CTRL, 0xFF);
-	rtl_write_word(rtlpriv, REG_RD_NAV_NXT, 0x200);
-	rtl_write_byte(rtlpriv, REG_RD_RESP_PKT_TH, 0x05);
+	rtl_write_byte( rtlpriv, REG_RD_CTRL, 0xFF );
+	rtl_write_word( rtlpriv, REG_RD_NAV_NXT, 0x200 );
+	rtl_write_byte( rtlpriv, REG_RD_RESP_PKT_TH, 0x05 );
 }
 
-void rtl92c_init_retry_function(struct ieee80211_hw *hw)
+void rtl92c_init_retry_function( struct ieee80211_hw *hw )
 {
 	u8	value8;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	value8 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL);
+	value8 = rtl_read_byte( rtlpriv, REG_FWHW_TXQ_CTRL );
 	value8 |= EN_AMPDU_RTY_NEW;
-	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL, value8);
+	rtl_write_byte( rtlpriv, REG_FWHW_TXQ_CTRL, value8 );
 	/* Set ACK timeout */
-	rtl_write_byte(rtlpriv, REG_ACKTO, 0x40);
+	rtl_write_byte( rtlpriv, REG_ACKTO, 0x40 );
 }
 
-void rtl92c_init_beacon_parameters(struct ieee80211_hw *hw,
-				   enum version_8192c version)
+void rtl92c_init_beacon_parameters( struct ieee80211_hw *hw,
+				   enum version_8192c version )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
 
-	rtl_write_word(rtlpriv, REG_TBTT_PROHIBIT, 0x6404);/* ms */
-	rtl_write_byte(rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);/*ms*/
-	rtl_write_byte(rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);
-	if (IS_NORMAL_CHIP(rtlhal->version))
-		rtl_write_word(rtlpriv, REG_BCNTCFG, 0x660F);
+	rtl_write_word( rtlpriv, REG_TBTT_PROHIBIT, 0x6404 );/* ms */
+	rtl_write_byte( rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME );/*ms*/
+	rtl_write_byte( rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME );
+	if ( IS_NORMAL_CHIP( rtlhal->version ) )
+		rtl_write_word( rtlpriv, REG_BCNTCFG, 0x660F );
 	else
-		rtl_write_word(rtlpriv, REG_BCNTCFG, 0x66FF);
+		rtl_write_word( rtlpriv, REG_BCNTCFG, 0x66FF );
 }
 
-void rtl92c_disable_fast_edca(struct ieee80211_hw *hw)
+void rtl92c_disable_fast_edca( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_word(rtlpriv, REG_FAST_EDCA_CTRL, 0);
+	rtl_write_word( rtlpriv, REG_FAST_EDCA_CTRL, 0 );
 }
 
-void rtl92c_set_min_space(struct ieee80211_hw *hw, bool is2T)
+void rtl92c_set_min_space( struct ieee80211_hw *hw, bool is2T )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u8 value = is2T ? MAX_MSS_DENSITY_2T : MAX_MSS_DENSITY_1T;
 
-	rtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE, value);
+	rtl_write_byte( rtlpriv, REG_AMPDU_MIN_SPACE, value );
 }
 
-u16 rtl92c_get_mgt_filter(struct ieee80211_hw *hw)
+u16 rtl92c_get_mgt_filter( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	return rtl_read_word(rtlpriv, REG_RXFLTMAP0);
+	return rtl_read_word( rtlpriv, REG_RXFLTMAP0 );
 }
 
-void rtl92c_set_mgt_filter(struct ieee80211_hw *hw, u16 filter)
+void rtl92c_set_mgt_filter( struct ieee80211_hw *hw, u16 filter )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_word(rtlpriv, REG_RXFLTMAP0, filter);
+	rtl_write_word( rtlpriv, REG_RXFLTMAP0, filter );
 }
 
-u16 rtl92c_get_ctrl_filter(struct ieee80211_hw *hw)
+u16 rtl92c_get_ctrl_filter( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	return rtl_read_word(rtlpriv, REG_RXFLTMAP1);
+	return rtl_read_word( rtlpriv, REG_RXFLTMAP1 );
 }
 
-void rtl92c_set_ctrl_filter(struct ieee80211_hw *hw, u16 filter)
+void rtl92c_set_ctrl_filter( struct ieee80211_hw *hw, u16 filter )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_word(rtlpriv, REG_RXFLTMAP1, filter);
+	rtl_write_word( rtlpriv, REG_RXFLTMAP1, filter );
 }
 
-u16 rtl92c_get_data_filter(struct ieee80211_hw *hw)
+u16 rtl92c_get_data_filter( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	return rtl_read_word(rtlpriv,  REG_RXFLTMAP2);
+	return rtl_read_word( rtlpriv,  REG_RXFLTMAP2 );
 }
 
-void rtl92c_set_data_filter(struct ieee80211_hw *hw, u16 filter)
+void rtl92c_set_data_filter( struct ieee80211_hw *hw, u16 filter )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	rtl_write_word(rtlpriv, REG_RXFLTMAP2, filter);
+	rtl_write_word( rtlpriv, REG_RXFLTMAP2, filter );
 }
 /*==============================================================*/
 
-static u8 _rtl92c_query_rxpwrpercentage(char antpower)
+static u8 _rtl92c_query_rxpwrpercentage( char antpower )
 {
-	if ((antpower <= -100) || (antpower >= 20))
+	if ( ( antpower <= -100 ) || ( antpower >= 20 ) )
 		return 0;
-	else if (antpower >= 0)
+	else if ( antpower >= 0 )
 		return 100;
 	else
 		return 100 + antpower;
 }
 
-static u8 _rtl92c_evm_db_to_percentage(char value)
+static u8 _rtl92c_evm_db_to_percentage( char value )
 {
 	char ret_val;
 
 	ret_val = value;
-	if (ret_val >= 0)
+	if ( ret_val >= 0 )
 		ret_val = 0;
-	if (ret_val <= -33)
+	if ( ret_val <= -33 )
 		ret_val = -33;
 	ret_val = 0 - ret_val;
 	ret_val *= 3;
-	if (ret_val == 99)
+	if ( ret_val == 99 )
 		ret_val = 100;
 	return ret_val;
 }
 
-static long _rtl92c_signal_scale_mapping(struct ieee80211_hw *hw,
-		long currsig)
+static long _rtl92c_signal_scale_mapping( struct ieee80211_hw *hw,
+		long currsig )
 {
 	long retsig;
 
-	if (currsig >= 61 && currsig <= 100)
-		retsig = 90 + ((currsig - 60) / 4);
-	else if (currsig >= 41 && currsig <= 60)
-		retsig = 78 + ((currsig - 40) / 2);
-	else if (currsig >= 31 && currsig <= 40)
-		retsig = 66 + (currsig - 30);
-	else if (currsig >= 21 && currsig <= 30)
-		retsig = 54 + (currsig - 20);
-	else if (currsig >= 5 && currsig <= 20)
-		retsig = 42 + (((currsig - 5) * 2) / 3);
-	else if (currsig == 4)
+	if ( currsig >= 61 && currsig <= 100 )
+		retsig = 90 + ( ( currsig - 60 ) / 4 );
+	else if ( currsig >= 41 && currsig <= 60 )
+		retsig = 78 + ( ( currsig - 40 ) / 2 );
+	else if ( currsig >= 31 && currsig <= 40 )
+		retsig = 66 + ( currsig - 30 );
+	else if ( currsig >= 21 && currsig <= 30 )
+		retsig = 54 + ( currsig - 20 );
+	else if ( currsig >= 5 && currsig <= 20 )
+		retsig = 42 + ( ( ( currsig - 5 ) * 2 ) / 3 );
+	else if ( currsig == 4 )
 		retsig = 36;
-	else if (currsig == 3)
+	else if ( currsig == 3 )
 		retsig = 27;
-	else if (currsig == 2)
+	else if ( currsig == 2 )
 		retsig = 18;
-	else if (currsig == 1)
+	else if ( currsig == 1 )
 		retsig = 9;
 	else
 		retsig = currsig;
 	return retsig;
 }
 
-static void _rtl92c_query_rxphystatus(struct ieee80211_hw *hw,
+static void _rtl92c_query_rxphystatus( struct ieee80211_hw *hw,
 				      struct rtl_stats *pstats,
 				      struct rx_desc_92c *p_desc,
 				      struct rx_fwinfo_92c *p_drvinfo,
 				      bool packet_match_bssid,
 				      bool packet_toself,
-				      bool packet_beacon)
+				      bool packet_beacon )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	struct phy_sts_cck_8192s_t *cck_buf;
 	s8 rx_pwr_all = 0, rx_pwr[4];
 	u8 rf_rx_num = 0, evm, pwdb_all;
@@ -785,74 +792,74 @@ static void _rtl92c_query_rxphystatus(struct ieee80211_hw *hw,
 	u32 rssi, total_rssi = 0;
 	bool in_powersavemode = false;
 	bool is_cck_rate;
-	u8 *pdesc = (u8 *)p_desc;
+	u8 *pdesc = ( u8 * )p_desc;
 
-	is_cck_rate = RX_HAL_IS_CCK_RATE(p_desc->rxmcs);
+	is_cck_rate = RX_HAL_IS_CCK_RATE( p_desc->rxmcs );
 	pstats->packet_matchbssid = packet_match_bssid;
 	pstats->packet_toself = packet_toself;
 	pstats->packet_beacon = packet_beacon;
 	pstats->is_cck = is_cck_rate;
 	pstats->RX_SIGQ[0] = -1;
 	pstats->RX_SIGQ[1] = -1;
-	if (is_cck_rate) {
+	if ( is_cck_rate ) {
 		u8 report, cck_highpwr;
-		cck_buf = (struct phy_sts_cck_8192s_t *)p_drvinfo;
-		if (!in_powersavemode)
+		cck_buf = ( struct phy_sts_cck_8192s_t * )p_drvinfo;
+		if ( !in_powersavemode )
 			cck_highpwr = rtlphy->cck_high_power;
 		else
 			cck_highpwr = false;
-		if (!cck_highpwr) {
+		if ( !cck_highpwr ) {
 			u8 cck_agc_rpt = cck_buf->cck_agc_rpt;
 			report = cck_buf->cck_agc_rpt & 0xc0;
 			report = report >> 6;
-			switch (report) {
+			switch ( report ) {
 			case 0x3:
-				rx_pwr_all = -46 - (cck_agc_rpt & 0x3e);
+				rx_pwr_all = -46 - ( cck_agc_rpt & 0x3e );
 				break;
 			case 0x2:
-				rx_pwr_all = -26 - (cck_agc_rpt & 0x3e);
+				rx_pwr_all = -26 - ( cck_agc_rpt & 0x3e );
 				break;
 			case 0x1:
-				rx_pwr_all = -12 - (cck_agc_rpt & 0x3e);
+				rx_pwr_all = -12 - ( cck_agc_rpt & 0x3e );
 				break;
 			case 0x0:
-				rx_pwr_all = 16 - (cck_agc_rpt & 0x3e);
+				rx_pwr_all = 16 - ( cck_agc_rpt & 0x3e );
 				break;
 			}
 		} else {
 			u8 cck_agc_rpt = cck_buf->cck_agc_rpt;
 			report = p_drvinfo->cfosho[0] & 0x60;
 			report = report >> 5;
-			switch (report) {
+			switch ( report ) {
 			case 0x3:
-				rx_pwr_all = -46 - ((cck_agc_rpt & 0x1f) << 1);
+				rx_pwr_all = -46 - ( ( cck_agc_rpt & 0x1f ) << 1 );
 				break;
 			case 0x2:
-				rx_pwr_all = -26 - ((cck_agc_rpt & 0x1f) << 1);
+				rx_pwr_all = -26 - ( ( cck_agc_rpt & 0x1f ) << 1 );
 				break;
 			case 0x1:
-				rx_pwr_all = -12 - ((cck_agc_rpt & 0x1f) << 1);
+				rx_pwr_all = -12 - ( ( cck_agc_rpt & 0x1f ) << 1 );
 				break;
 			case 0x0:
-				rx_pwr_all = 16 - ((cck_agc_rpt & 0x1f) << 1);
+				rx_pwr_all = 16 - ( ( cck_agc_rpt & 0x1f ) << 1 );
 				break;
 			}
 		}
-		pwdb_all = _rtl92c_query_rxpwrpercentage(rx_pwr_all);
+		pwdb_all = _rtl92c_query_rxpwrpercentage( rx_pwr_all );
 		pstats->rx_pwdb_all = pwdb_all;
 		pstats->recvsignalpower = rx_pwr_all;
-		if (packet_match_bssid) {
+		if ( packet_match_bssid ) {
 			u8 sq;
-			if (pstats->rx_pwdb_all > 40)
+			if ( pstats->rx_pwdb_all > 40 )
 				sq = 100;
 			else {
 				sq = cck_buf->sq_rpt;
-				if (sq > 64)
+				if ( sq > 64 )
 					sq = 0;
-				else if (sq < 20)
+				else if ( sq < 20 )
 					sq = 100;
 				else
-					sq = ((64 - sq) * 100) / 44;
+					sq = ( ( 64 - sq ) * 100 ) / 44;
 			}
 			pstats->signalquality = sq;
 			pstats->RX_SIGQ[0] = sq;
@@ -861,58 +868,58 @@ static void _rtl92c_query_rxphystatus(struct ieee80211_hw *hw,
 	} else {
 		rtlpriv->dm.rfpath_rxenable[0] =
 		    rtlpriv->dm.rfpath_rxenable[1] = true;
-		for (i = RF90_PATH_A; i < RF90_PATH_MAX; i++) {
-			if (rtlpriv->dm.rfpath_rxenable[i])
+		for ( i = RF90_PATH_A; i < RF90_PATH_MAX; i++ ) {
+			if ( rtlpriv->dm.rfpath_rxenable[i] )
 				rf_rx_num++;
 			rx_pwr[i] =
-			    ((p_drvinfo->gain_trsw[i] & 0x3f) * 2) - 110;
-			rssi = _rtl92c_query_rxpwrpercentage(rx_pwr[i]);
+			    ( ( p_drvinfo->gain_trsw[i] & 0x3f ) * 2 ) - 110;
+			rssi = _rtl92c_query_rxpwrpercentage( rx_pwr[i] );
 			total_rssi += rssi;
 			rtlpriv->stats.rx_snr_db[i] =
-			    (long)(p_drvinfo->rxsnr[i] / 2);
+			    ( long )( p_drvinfo->rxsnr[i] / 2 );
 
-			if (packet_match_bssid)
-				pstats->rx_mimo_signalstrength[i] = (u8) rssi;
+			if ( packet_match_bssid )
+				pstats->rx_mimo_signalstrength[i] = ( u8 ) rssi;
 		}
-		rx_pwr_all = ((p_drvinfo->pwdb_all >> 1) & 0x7f) - 110;
-		pwdb_all = _rtl92c_query_rxpwrpercentage(rx_pwr_all);
+		rx_pwr_all = ( ( p_drvinfo->pwdb_all >> 1 ) & 0x7f ) - 110;
+		pwdb_all = _rtl92c_query_rxpwrpercentage( rx_pwr_all );
 		pstats->rx_pwdb_all = pwdb_all;
 		pstats->rxpower = rx_pwr_all;
 		pstats->recvsignalpower = rx_pwr_all;
-		if (GET_RX_DESC_RX_MCS(pdesc) &&
-		    GET_RX_DESC_RX_MCS(pdesc) >= DESC92_RATEMCS8 &&
-		    GET_RX_DESC_RX_MCS(pdesc) <= DESC92_RATEMCS15)
+		if ( GET_RX_DESC_RX_MCS( pdesc ) &&
+		    GET_RX_DESC_RX_MCS( pdesc ) >= DESC92_RATEMCS8 &&
+		    GET_RX_DESC_RX_MCS( pdesc ) <= DESC92_RATEMCS15 )
 			max_spatial_stream = 2;
 		else
 			max_spatial_stream = 1;
-		for (i = 0; i < max_spatial_stream; i++) {
-			evm = _rtl92c_evm_db_to_percentage(p_drvinfo->rxevm[i]);
-			if (packet_match_bssid) {
-				if (i == 0)
+		for ( i = 0; i < max_spatial_stream; i++ ) {
+			evm = _rtl92c_evm_db_to_percentage( p_drvinfo->rxevm[i] );
+			if ( packet_match_bssid ) {
+				if ( i == 0 )
 					pstats->signalquality =
-					    (u8) (evm & 0xff);
+					    ( u8 ) ( evm & 0xff );
 				pstats->RX_SIGQ[i] =
-				    (u8) (evm & 0xff);
+				    ( u8 ) ( evm & 0xff );
 			}
 		}
 	}
-	if (is_cck_rate)
+	if ( is_cck_rate )
 		pstats->signalstrength =
-		    (u8) (_rtl92c_signal_scale_mapping(hw, pwdb_all));
-	else if (rf_rx_num != 0)
+		    ( u8 ) ( _rtl92c_signal_scale_mapping( hw, pwdb_all ) );
+	else if ( rf_rx_num != 0 )
 		pstats->signalstrength =
-		    (u8) (_rtl92c_signal_scale_mapping
-			  (hw, total_rssi /= rf_rx_num));
+		    ( u8 ) ( _rtl92c_signal_scale_mapping
+			  ( hw, total_rssi /= rf_rx_num ) );
 }
 
-void rtl92c_translate_rx_signal_stuff(struct ieee80211_hw *hw,
+void rtl92c_translate_rx_signal_stuff( struct ieee80211_hw *hw,
 					       struct sk_buff *skb,
 					       struct rtl_stats *pstats,
 					       struct rx_desc_92c *pdesc,
-					       struct rx_fwinfo_92c *p_drvinfo)
+					       struct rx_fwinfo_92c *p_drvinfo )
 {
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	struct ieee80211_hdr *hdr;
 	u8 *tmp_buf;
 	u8 *praddr;
@@ -921,25 +928,25 @@ void rtl92c_translate_rx_signal_stuff(struct ieee80211_hw *hw,
 	bool packet_matchbssid, packet_toself, packet_beacon = false;
 
 	tmp_buf = skb->data + pstats->rx_drvinfo_size + pstats->rx_bufshift;
-	hdr = (struct ieee80211_hdr *)tmp_buf;
+	hdr = ( struct ieee80211_hdr * )tmp_buf;
 	fc = hdr->frame_control;
-	cpu_fc = le16_to_cpu(fc);
-	type = WLAN_FC_GET_TYPE(fc);
+	cpu_fc = le16_to_cpu( fc );
+	type = WLAN_FC_GET_TYPE( fc );
 	praddr = hdr->addr1;
 	packet_matchbssid =
-	    ((IEEE80211_FTYPE_CTL != type) &&
-	     ether_addr_equal(mac->bssid,
-			      (cpu_fc & IEEE80211_FCTL_TODS) ? hdr->addr1 :
-			      (cpu_fc & IEEE80211_FCTL_FROMDS) ? hdr->addr2 :
-			      hdr->addr3) &&
-	     (!pstats->hwerror) && (!pstats->crc) && (!pstats->icv));
+	    ( ( IEEE80211_FTYPE_CTL != type ) &&
+	     ether_addr_equal( mac->bssid,
+			      ( cpu_fc & IEEE80211_FCTL_TODS ) ? hdr->addr1 :
+			      ( cpu_fc & IEEE80211_FCTL_FROMDS ) ? hdr->addr2 :
+			      hdr->addr3 ) &&
+	     ( !pstats->hwerror ) && ( !pstats->crc ) && ( !pstats->icv ) );
 
 	packet_toself = packet_matchbssid &&
-	    ether_addr_equal(praddr, rtlefuse->dev_addr);
-	if (ieee80211_is_beacon(fc))
+	    ether_addr_equal( praddr, rtlefuse->dev_addr );
+	if ( ieee80211_is_beacon( fc ) )
 		packet_beacon = true;
-	_rtl92c_query_rxphystatus(hw, pstats, pdesc, p_drvinfo,
+	_rtl92c_query_rxphystatus( hw, pstats, pdesc, p_drvinfo,
 				   packet_matchbssid, packet_toself,
-				   packet_beacon);
-	rtl_process_phyinfo(hw, tmp_buf, pstats);
+				   packet_beacon );
+	rtl_process_phyinfo( hw, tmp_buf, pstats );
 }
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/mac.h b/drivers/net/wireless/rtlwifi/rtl8192cu/mac.h
index bf53652..fa82a40 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/mac.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/mac.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -34,58 +41,58 @@
 #define DRIVER_EARLY_INT_TIME					0x05
 #define BCN_DMA_ATIME_INT_TIME				0x02
 
-void rtl92c_read_chip_version(struct ieee80211_hw *hw);
-bool rtl92c_llt_write(struct ieee80211_hw *hw, u32 address, u32 data);
-bool rtl92c_init_llt_table(struct ieee80211_hw *hw, u32 boundary);
-void rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,
+void rtl92c_read_chip_version( struct ieee80211_hw *hw );
+bool rtl92c_llt_write( struct ieee80211_hw *hw, u32 address, u32 data );
+bool rtl92c_init_llt_table( struct ieee80211_hw *hw, u32 boundary );
+void rtl92c_set_key( struct ieee80211_hw *hw, u32 key_index,
 		     u8 *p_macaddr, bool is_group, u8 enc_algo,
-		     bool is_wepkey, bool clear_all);
-void rtl92c_enable_interrupt(struct ieee80211_hw *hw);
-void rtl92c_disable_interrupt(struct ieee80211_hw *hw);
-void rtl92c_set_qos(struct ieee80211_hw *hw, int aci);
+		     bool is_wepkey, bool clear_all );
+void rtl92c_enable_interrupt( struct ieee80211_hw *hw );
+void rtl92c_disable_interrupt( struct ieee80211_hw *hw );
+void rtl92c_set_qos( struct ieee80211_hw *hw, int aci );
 
 
 /*---------------------------------------------------------------
  *	Hardware init functions
  *---------------------------------------------------------------*/
-void rtl92c_set_mac_addr(struct ieee80211_hw *hw, const u8 *addr);
-void rtl92c_init_interrupt(struct ieee80211_hw *hw);
-void rtl92c_init_driver_info_size(struct ieee80211_hw *hw, u8 size);
+void rtl92c_set_mac_addr( struct ieee80211_hw *hw, const u8 *addr );
+void rtl92c_init_interrupt( struct ieee80211_hw *hw );
+void rtl92c_init_driver_info_size( struct ieee80211_hw *hw, u8 size );
 
-int rtl92c_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type);
-void rtl92c_init_network_type(struct ieee80211_hw *hw);
-void rtl92c_init_adaptive_ctrl(struct ieee80211_hw *hw);
-void rtl92c_init_rate_fallback(struct ieee80211_hw *hw);
+int rtl92c_set_network_type( struct ieee80211_hw *hw, enum nl80211_iftype type );
+void rtl92c_init_network_type( struct ieee80211_hw *hw );
+void rtl92c_init_adaptive_ctrl( struct ieee80211_hw *hw );
+void rtl92c_init_rate_fallback( struct ieee80211_hw *hw );
 
-void rtl92c_init_edca_param(struct ieee80211_hw *hw,
+void rtl92c_init_edca_param( struct ieee80211_hw *hw,
 							u16 queue,
 							u16 txop,
 							u8 ecwmax,
 							u8 ecwmin,
-							u8 aifs);
+							u8 aifs );
 
-void rtl92c_init_edca(struct ieee80211_hw *hw);
-void rtl92c_init_ampdu_aggregation(struct ieee80211_hw *hw);
-void rtl92c_init_beacon_max_error(struct ieee80211_hw *hw, bool infra_mode);
-void rtl92c_init_rdg_setting(struct ieee80211_hw *hw);
-void rtl92c_init_retry_function(struct ieee80211_hw *hw);
+void rtl92c_init_edca( struct ieee80211_hw *hw );
+void rtl92c_init_ampdu_aggregation( struct ieee80211_hw *hw );
+void rtl92c_init_beacon_max_error( struct ieee80211_hw *hw, bool infra_mode );
+void rtl92c_init_rdg_setting( struct ieee80211_hw *hw );
+void rtl92c_init_retry_function( struct ieee80211_hw *hw );
 
-void rtl92c_init_beacon_parameters(struct ieee80211_hw *hw,
-				   enum version_8192c version);
+void rtl92c_init_beacon_parameters( struct ieee80211_hw *hw,
+				   enum version_8192c version );
 
-void rtl92c_disable_fast_edca(struct ieee80211_hw *hw);
-void rtl92c_set_min_space(struct ieee80211_hw *hw, bool is2T);
+void rtl92c_disable_fast_edca( struct ieee80211_hw *hw );
+void rtl92c_set_min_space( struct ieee80211_hw *hw, bool is2T );
 
 /* For filter */
-u16 rtl92c_get_mgt_filter(struct ieee80211_hw *hw);
-void rtl92c_set_mgt_filter(struct ieee80211_hw *hw, u16 filter);
-u16 rtl92c_get_ctrl_filter(struct ieee80211_hw *hw);
-void rtl92c_set_ctrl_filter(struct ieee80211_hw *hw, u16 filter);
-u16 rtl92c_get_data_filter(struct ieee80211_hw *hw);
-void rtl92c_set_data_filter(struct ieee80211_hw *hw, u16 filter);
+u16 rtl92c_get_mgt_filter( struct ieee80211_hw *hw );
+void rtl92c_set_mgt_filter( struct ieee80211_hw *hw, u16 filter );
+u16 rtl92c_get_ctrl_filter( struct ieee80211_hw *hw );
+void rtl92c_set_ctrl_filter( struct ieee80211_hw *hw, u16 filter );
+u16 rtl92c_get_data_filter( struct ieee80211_hw *hw );
+void rtl92c_set_data_filter( struct ieee80211_hw *hw, u16 filter );
 
 
-u32 rtl92c_get_txdma_status(struct ieee80211_hw *hw);
+u32 rtl92c_get_txdma_status( struct ieee80211_hw *hw );
 
 struct rx_fwinfo_92c {
 	u8 gain_trsw[4];
@@ -156,14 +163,14 @@ struct rx_desc_92c {
 	u32 bufferaddress64;	/* word 7 */
 } __packed;
 
-enum rtl_desc_qsel rtl92c_map_hwqueue_to_fwqueue(u16 fc,
+enum rtl_desc_qsel rtl92c_map_hwqueue_to_fwqueue( u16 fc,
 							  unsigned int
-							  skb_queue);
-void rtl92c_translate_rx_signal_stuff(struct ieee80211_hw *hw,
+							  skb_queue );
+void rtl92c_translate_rx_signal_stuff( struct ieee80211_hw *hw,
 				      struct sk_buff *skb,
 				      struct rtl_stats *pstats,
 				      struct rx_desc_92c *pdesc,
-				      struct rx_fwinfo_92c *p_drvinfo);
+				      struct rx_fwinfo_92c *p_drvinfo );
 
 /*---------------------------------------------------------------
  *	Card disable functions
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/phy.c b/drivers/net/wireless/rtlwifi/rtl8192cu/phy.c
index 12f6d47..ce5a2e2 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/phy.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/phy.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -41,145 +48,145 @@
 #include "../rtl8192c/fw_common.h"
 #include "table.h"
 
-u32 rtl92cu_phy_query_rf_reg(struct ieee80211_hw *hw,
-			     enum radio_path rfpath, u32 regaddr, u32 bitmask)
+u32 rtl92cu_phy_query_rf_reg( struct ieee80211_hw *hw,
+			     enum radio_path rfpath, u32 regaddr, u32 bitmask )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u32 original_value, readback_value, bitshift;
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 
-	RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
+	RT_TRACE( rtlpriv, COMP_RF, DBG_TRACE,
 		 "regaddr(%#x), rfpath(%#x), bitmask(%#x)\n",
-		 regaddr, rfpath, bitmask);
-	if (rtlphy->rf_mode != RF_OP_BY_FW) {
-		original_value = _rtl92c_phy_rf_serial_read(hw,
-							    rfpath, regaddr);
+		 regaddr, rfpath, bitmask );
+	if ( rtlphy->rf_mode != RF_OP_BY_FW ) {
+		original_value = _rtl92c_phy_rf_serial_read( hw,
+							    rfpath, regaddr );
 	} else {
-		original_value = _rtl92c_phy_fw_rf_serial_read(hw,
-							       rfpath, regaddr);
+		original_value = _rtl92c_phy_fw_rf_serial_read( hw,
+							       rfpath, regaddr );
 	}
-	bitshift = _rtl92c_phy_calculate_bit_shift(bitmask);
-	readback_value = (original_value & bitmask) >> bitshift;
-	RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
+	bitshift = _rtl92c_phy_calculate_bit_shift( bitmask );
+	readback_value = ( original_value & bitmask ) >> bitshift;
+	RT_TRACE( rtlpriv, COMP_RF, DBG_TRACE,
 		 "regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\n",
-		 regaddr, rfpath, bitmask, original_value);
+		 regaddr, rfpath, bitmask, original_value );
 	return readback_value;
 }
 
-void rtl92cu_phy_set_rf_reg(struct ieee80211_hw *hw,
+void rtl92cu_phy_set_rf_reg( struct ieee80211_hw *hw,
 			    enum radio_path rfpath,
-			    u32 regaddr, u32 bitmask, u32 data)
+			    u32 regaddr, u32 bitmask, u32 data )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	u32 original_value, bitshift;
 
-	RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
+	RT_TRACE( rtlpriv, COMP_RF, DBG_TRACE,
 		 "regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\n",
-		 regaddr, bitmask, data, rfpath);
-	if (rtlphy->rf_mode != RF_OP_BY_FW) {
-		if (bitmask != RFREG_OFFSET_MASK) {
-			original_value = _rtl92c_phy_rf_serial_read(hw,
+		 regaddr, bitmask, data, rfpath );
+	if ( rtlphy->rf_mode != RF_OP_BY_FW ) {
+		if ( bitmask != RFREG_OFFSET_MASK ) {
+			original_value = _rtl92c_phy_rf_serial_read( hw,
 								    rfpath,
-								    regaddr);
-			bitshift = _rtl92c_phy_calculate_bit_shift(bitmask);
+								    regaddr );
+			bitshift = _rtl92c_phy_calculate_bit_shift( bitmask );
 			data =
-			    ((original_value & (~bitmask)) |
-			     (data << bitshift));
+			    ( ( original_value & ( ~bitmask ) ) |
+			     ( data << bitshift ) );
 		}
-		_rtl92c_phy_rf_serial_write(hw, rfpath, regaddr, data);
+		_rtl92c_phy_rf_serial_write( hw, rfpath, regaddr, data );
 	} else {
-		if (bitmask != RFREG_OFFSET_MASK) {
-			original_value = _rtl92c_phy_fw_rf_serial_read(hw,
+		if ( bitmask != RFREG_OFFSET_MASK ) {
+			original_value = _rtl92c_phy_fw_rf_serial_read( hw,
 								       rfpath,
-								       regaddr);
-			bitshift = _rtl92c_phy_calculate_bit_shift(bitmask);
+								       regaddr );
+			bitshift = _rtl92c_phy_calculate_bit_shift( bitmask );
 			data =
-			    ((original_value & (~bitmask)) |
-			     (data << bitshift));
+			    ( ( original_value & ( ~bitmask ) ) |
+			     ( data << bitshift ) );
 		}
-		_rtl92c_phy_fw_rf_serial_write(hw, rfpath, regaddr, data);
+		_rtl92c_phy_fw_rf_serial_write( hw, rfpath, regaddr, data );
 	}
-	RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
+	RT_TRACE( rtlpriv, COMP_RF, DBG_TRACE,
 		 "regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\n",
-		 regaddr, bitmask, data, rfpath);
+		 regaddr, bitmask, data, rfpath );
 }
 
-bool rtl92cu_phy_mac_config(struct ieee80211_hw *hw)
+bool rtl92cu_phy_mac_config( struct ieee80211_hw *hw )
 {
 	bool rtstatus;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	bool is92c = IS_92C_SERIAL(rtlhal->version);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	bool is92c = IS_92C_SERIAL( rtlhal->version );
 
-	rtstatus = _rtl92cu_phy_config_mac_with_headerfile(hw);
-	if (is92c && IS_HARDWARE_TYPE_8192CE(rtlhal))
-		rtl_write_byte(rtlpriv, 0x14, 0x71);
+	rtstatus = _rtl92cu_phy_config_mac_with_headerfile( hw );
+	if ( is92c && IS_HARDWARE_TYPE_8192CE( rtlhal ) )
+		rtl_write_byte( rtlpriv, 0x14, 0x71 );
 	return rtstatus;
 }
 
-bool rtl92cu_phy_bb_config(struct ieee80211_hw *hw)
+bool rtl92cu_phy_bb_config( struct ieee80211_hw *hw )
 {
 	bool rtstatus = true;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	u16 regval;
 	u32 regval32;
 	u8 b_reg_hwparafile = 1;
 
-	_rtl92c_phy_init_bb_rf_register_definition(hw);
-	regval = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);
-	rtl_write_word(rtlpriv, REG_SYS_FUNC_EN, regval | BIT(13) |
-		       BIT(0) | BIT(1));
-	rtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x83);
-	rtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL + 1, 0xdb);
-	rtl_write_byte(rtlpriv, REG_RF_CTRL, RF_EN | RF_RSTB | RF_SDMRSTB);
-	if (IS_HARDWARE_TYPE_8192CE(rtlhal)) {
-		rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, FEN_PPLL | FEN_PCIEA |
-			       FEN_DIO_PCIE |	FEN_BB_GLB_RSTn | FEN_BBRSTB);
-	} else if (IS_HARDWARE_TYPE_8192CU(rtlhal)) {
-		rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD |
-			       FEN_BB_GLB_RSTn | FEN_BBRSTB);
+	_rtl92c_phy_init_bb_rf_register_definition( hw );
+	regval = rtl_read_word( rtlpriv, REG_SYS_FUNC_EN );
+	rtl_write_word( rtlpriv, REG_SYS_FUNC_EN, regval | BIT( 13 ) |
+		       BIT( 0 ) | BIT( 1 ) );
+	rtl_write_byte( rtlpriv, REG_AFE_PLL_CTRL, 0x83 );
+	rtl_write_byte( rtlpriv, REG_AFE_PLL_CTRL + 1, 0xdb );
+	rtl_write_byte( rtlpriv, REG_RF_CTRL, RF_EN | RF_RSTB | RF_SDMRSTB );
+	if ( IS_HARDWARE_TYPE_8192CE( rtlhal ) ) {
+		rtl_write_byte( rtlpriv, REG_SYS_FUNC_EN, FEN_PPLL | FEN_PCIEA |
+			       FEN_DIO_PCIE |	FEN_BB_GLB_RSTn | FEN_BBRSTB );
+	} else if ( IS_HARDWARE_TYPE_8192CU( rtlhal ) ) {
+		rtl_write_byte( rtlpriv, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD |
+			       FEN_BB_GLB_RSTn | FEN_BBRSTB );
 	}
-	regval32 = rtl_read_dword(rtlpriv, 0x87c);
-	rtl_write_dword(rtlpriv, 0x87c, regval32 & (~BIT(31)));
-	if (IS_HARDWARE_TYPE_8192CU(rtlhal))
-		rtl_write_byte(rtlpriv, REG_LDOHCI12_CTRL, 0x0f);
-	rtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL + 1, 0x80);
-	if (b_reg_hwparafile == 1)
-		rtstatus = _rtl92c_phy_bb8192c_config_parafile(hw);
+	regval32 = rtl_read_dword( rtlpriv, 0x87c );
+	rtl_write_dword( rtlpriv, 0x87c, regval32 & ( ~BIT( 31 ) ) );
+	if ( IS_HARDWARE_TYPE_8192CU( rtlhal ) )
+		rtl_write_byte( rtlpriv, REG_LDOHCI12_CTRL, 0x0f );
+	rtl_write_byte( rtlpriv, REG_AFE_XTAL_CTRL + 1, 0x80 );
+	if ( b_reg_hwparafile == 1 )
+		rtstatus = _rtl92c_phy_bb8192c_config_parafile( hw );
 	return rtstatus;
 }
 
-bool _rtl92cu_phy_config_mac_with_headerfile(struct ieee80211_hw *hw)
+bool _rtl92cu_phy_config_mac_with_headerfile( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	u32 i;
 	u32 arraylength;
 	u32 *ptrarray;
 
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Read Rtl819XMACPHY_Array\n");
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE, "Read Rtl819XMACPHY_Array\n" );
 	arraylength =  rtlphy->hwparam_tables[MAC_REG].length ;
 	ptrarray = rtlphy->hwparam_tables[MAC_REG].pdata;
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Img:RTL8192CEMAC_2T_ARRAY\n");
-	for (i = 0; i < arraylength; i = i + 2)
-		rtl_write_byte(rtlpriv, ptrarray[i], (u8) ptrarray[i + 1]);
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE, "Img:RTL8192CEMAC_2T_ARRAY\n" );
+	for ( i = 0; i < arraylength; i = i + 2 )
+		rtl_write_byte( rtlpriv, ptrarray[i], ( u8 ) ptrarray[i + 1] );
 	return true;
 }
 
-bool _rtl92cu_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,
-					    u8 configtype)
+bool _rtl92cu_phy_config_bb_with_headerfile( struct ieee80211_hw *hw,
+					    u8 configtype )
 {
 	int i;
 	u32 *phy_regarray_table;
 	u32 *agctab_array_table;
 	u16 phy_reg_arraylen, agctab_arraylen;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 
-	if (IS_92C_SERIAL(rtlhal->version)) {
+	if ( IS_92C_SERIAL( rtlhal->version ) ) {
 		agctab_arraylen = rtlphy->hwparam_tables[AGCTAB_2T].length;
 		agctab_array_table =  rtlphy->hwparam_tables[AGCTAB_2T].pdata;
 		phy_reg_arraylen = rtlphy->hwparam_tables[PHY_REG_2T].length;
@@ -190,36 +197,36 @@ bool _rtl92cu_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,
 		phy_reg_arraylen = rtlphy->hwparam_tables[PHY_REG_1T].length;
 		phy_regarray_table = rtlphy->hwparam_tables[PHY_REG_1T].pdata;
 	}
-	if (configtype == BASEBAND_CONFIG_PHY_REG) {
-		for (i = 0; i < phy_reg_arraylen; i = i + 2) {
-			rtl_addr_delay(phy_regarray_table[i]);
-			rtl_set_bbreg(hw, phy_regarray_table[i], MASKDWORD,
-				      phy_regarray_table[i + 1]);
-			udelay(1);
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
+	if ( configtype == BASEBAND_CONFIG_PHY_REG ) {
+		for ( i = 0; i < phy_reg_arraylen; i = i + 2 ) {
+			rtl_addr_delay( phy_regarray_table[i] );
+			rtl_set_bbreg( hw, phy_regarray_table[i], MASKDWORD,
+				      phy_regarray_table[i + 1] );
+			udelay( 1 );
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
 				 "The phy_regarray_table[0] is %x Rtl819XPHY_REGArray[1] is %x\n",
 				 phy_regarray_table[i],
-				 phy_regarray_table[i + 1]);
+				 phy_regarray_table[i + 1] );
 		}
-	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
-		for (i = 0; i < agctab_arraylen; i = i + 2) {
-			rtl_set_bbreg(hw, agctab_array_table[i], MASKDWORD,
-				      agctab_array_table[i + 1]);
-			udelay(1);
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
+	} else if ( configtype == BASEBAND_CONFIG_AGC_TAB ) {
+		for ( i = 0; i < agctab_arraylen; i = i + 2 ) {
+			rtl_set_bbreg( hw, agctab_array_table[i], MASKDWORD,
+				      agctab_array_table[i + 1] );
+			udelay( 1 );
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
 				 "The agctab_array_table[0] is %x Rtl819XPHY_REGArray[1] is %x\n",
 				 agctab_array_table[i],
-				 agctab_array_table[i + 1]);
+				 agctab_array_table[i + 1] );
 		}
 	}
 	return true;
 }
 
-bool _rtl92cu_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,
-					      u8 configtype)
+bool _rtl92cu_phy_config_bb_with_pgheaderfile( struct ieee80211_hw *hw,
+					      u8 configtype )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	int i;
 	u32 *phy_regarray_table_pg;
 	u16 phy_regarray_pg_len;
@@ -227,74 +234,74 @@ bool _rtl92cu_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,
 	rtlphy->pwrgroup_cnt = 0;
 	phy_regarray_pg_len = rtlphy->hwparam_tables[PHY_REG_PG].length;
 	phy_regarray_table_pg = rtlphy->hwparam_tables[PHY_REG_PG].pdata;
-	if (configtype == BASEBAND_CONFIG_PHY_REG) {
-		for (i = 0; i < phy_regarray_pg_len; i = i + 3) {
-			rtl_addr_delay(phy_regarray_table_pg[i]);
-			_rtl92c_store_pwrIndex_diffrate_offset(hw,
+	if ( configtype == BASEBAND_CONFIG_PHY_REG ) {
+		for ( i = 0; i < phy_regarray_pg_len; i = i + 3 ) {
+			rtl_addr_delay( phy_regarray_table_pg[i] );
+			_rtl92c_store_pwrIndex_diffrate_offset( hw,
 						  phy_regarray_table_pg[i],
 						  phy_regarray_table_pg[i + 1],
-						  phy_regarray_table_pg[i + 2]);
+						  phy_regarray_table_pg[i + 2] );
 		}
 	} else {
-		RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,
-			 "configtype != BaseBand_Config_PHY_REG\n");
+		RT_TRACE( rtlpriv, COMP_SEND, DBG_TRACE,
+			 "configtype != BaseBand_Config_PHY_REG\n" );
 	}
 	return true;
 }
 
-bool rtl92cu_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,
-					  enum radio_path rfpath)
+bool rtl92cu_phy_config_rf_with_headerfile( struct ieee80211_hw *hw,
+					  enum radio_path rfpath )
 {
 	int i;
 	u32 *radioa_array_table;
 	u32 *radiob_array_table;
 	u16 radioa_arraylen, radiob_arraylen;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 
-	if (IS_92C_SERIAL(rtlhal->version)) {
+	if ( IS_92C_SERIAL( rtlhal->version ) ) {
 		radioa_arraylen = rtlphy->hwparam_tables[RADIOA_2T].length;
 		radioa_array_table = rtlphy->hwparam_tables[RADIOA_2T].pdata;
 		radiob_arraylen = rtlphy->hwparam_tables[RADIOB_2T].length;
 		radiob_array_table = rtlphy->hwparam_tables[RADIOB_2T].pdata;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Radio_A:RTL8192CERADIOA_2TARRAY\n");
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Radio_B:RTL8192CE_RADIOB_2TARRAY\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Radio_A:RTL8192CERADIOA_2TARRAY\n" );
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Radio_B:RTL8192CE_RADIOB_2TARRAY\n" );
 	} else {
 		radioa_arraylen = rtlphy->hwparam_tables[RADIOA_1T].length;
 		radioa_array_table = rtlphy->hwparam_tables[RADIOA_1T].pdata;
 		radiob_arraylen = rtlphy->hwparam_tables[RADIOB_1T].length;
 		radiob_array_table = rtlphy->hwparam_tables[RADIOB_1T].pdata;
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Radio_A:RTL8192CE_RADIOA_1TARRAY\n");
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-			 "Radio_B:RTL8192CE_RADIOB_1TARRAY\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Radio_A:RTL8192CE_RADIOA_1TARRAY\n" );
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+			 "Radio_B:RTL8192CE_RADIOB_1TARRAY\n" );
 	}
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Radio No %x\n", rfpath);
-	switch (rfpath) {
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE, "Radio No %x\n", rfpath );
+	switch ( rfpath ) {
 	case RF90_PATH_A:
-		for (i = 0; i < radioa_arraylen; i = i + 2) {
-			rtl_rfreg_delay(hw, rfpath, radioa_array_table[i],
+		for ( i = 0; i < radioa_arraylen; i = i + 2 ) {
+			rtl_rfreg_delay( hw, rfpath, radioa_array_table[i],
 					RFREG_OFFSET_MASK,
-					radioa_array_table[i + 1]);
+					radioa_array_table[i + 1] );
 		}
 		break;
 	case RF90_PATH_B:
-		for (i = 0; i < radiob_arraylen; i = i + 2) {
-			rtl_rfreg_delay(hw, rfpath, radiob_array_table[i],
+		for ( i = 0; i < radiob_arraylen; i = i + 2 ) {
+			rtl_rfreg_delay( hw, rfpath, radiob_array_table[i],
 					RFREG_OFFSET_MASK,
-					radiob_array_table[i + 1]);
+					radiob_array_table[i + 1] );
 		}
 		break;
 	case RF90_PATH_C:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	case RF90_PATH_D:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		break;
 	default:
 		break;
@@ -302,250 +309,250 @@ bool rtl92cu_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,
 	return true;
 }
 
-void rtl92cu_phy_set_bw_mode_callback(struct ieee80211_hw *hw)
+void rtl92cu_phy_set_bw_mode_callback( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
 	u8 reg_bw_opmode;
 	u8 reg_prsr_rsc;
 
-	RT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE, "Switch to %s bandwidth\n",
+	RT_TRACE( rtlpriv, COMP_SCAN, DBG_TRACE, "Switch to %s bandwidth\n",
 		 rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?
-		 "20MHz" : "40MHz");
-	if (is_hal_stop(rtlhal)) {
+		 "20MHz" : "40MHz" );
+	if ( is_hal_stop( rtlhal ) ) {
 		rtlphy->set_bwmode_inprogress = false;
 		return;
 	}
-	reg_bw_opmode = rtl_read_byte(rtlpriv, REG_BWOPMODE);
-	reg_prsr_rsc = rtl_read_byte(rtlpriv, REG_RRSR + 2);
-	switch (rtlphy->current_chan_bw) {
+	reg_bw_opmode = rtl_read_byte( rtlpriv, REG_BWOPMODE );
+	reg_prsr_rsc = rtl_read_byte( rtlpriv, REG_RRSR + 2 );
+	switch ( rtlphy->current_chan_bw ) {
 	case HT_CHANNEL_WIDTH_20:
 		reg_bw_opmode |= BW_OPMODE_20MHZ;
-		rtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);
+		rtl_write_byte( rtlpriv, REG_BWOPMODE, reg_bw_opmode );
 		break;
 	case HT_CHANNEL_WIDTH_20_40:
 		reg_bw_opmode &= ~BW_OPMODE_20MHZ;
-		rtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);
+		rtl_write_byte( rtlpriv, REG_BWOPMODE, reg_bw_opmode );
 		reg_prsr_rsc =
-		    (reg_prsr_rsc & 0x90) | (mac->cur_40_prime_sc << 5);
-		rtl_write_byte(rtlpriv, REG_RRSR + 2, reg_prsr_rsc);
+		    ( reg_prsr_rsc & 0x90 ) | ( mac->cur_40_prime_sc << 5 );
+		rtl_write_byte( rtlpriv, REG_RRSR + 2, reg_prsr_rsc );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "unknown bandwidth: %#X\n", rtlphy->current_chan_bw);
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "unknown bandwidth: %#X\n", rtlphy->current_chan_bw );
 		break;
 	}
-	switch (rtlphy->current_chan_bw) {
+	switch ( rtlphy->current_chan_bw ) {
 	case HT_CHANNEL_WIDTH_20:
-		rtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);
-		rtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);
-		rtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10), 1);
+		rtl_set_bbreg( hw, RFPGA0_RFMOD, BRFMOD, 0x0 );
+		rtl_set_bbreg( hw, RFPGA1_RFMOD, BRFMOD, 0x0 );
+		rtl_set_bbreg( hw, RFPGA0_ANALOGPARAMETER2, BIT( 10 ), 1 );
 		break;
 	case HT_CHANNEL_WIDTH_20_40:
-		rtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);
-		rtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);
-		rtl_set_bbreg(hw, RCCK0_SYSTEM, BCCK_SIDEBAND,
-			      (mac->cur_40_prime_sc >> 1));
-		rtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);
-		rtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10), 0);
-		rtl_set_bbreg(hw, 0x818, (BIT(26) | BIT(27)),
-			      (mac->cur_40_prime_sc ==
-			       HAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);
+		rtl_set_bbreg( hw, RFPGA0_RFMOD, BRFMOD, 0x1 );
+		rtl_set_bbreg( hw, RFPGA1_RFMOD, BRFMOD, 0x1 );
+		rtl_set_bbreg( hw, RCCK0_SYSTEM, BCCK_SIDEBAND,
+			      ( mac->cur_40_prime_sc >> 1 ) );
+		rtl_set_bbreg( hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc );
+		rtl_set_bbreg( hw, RFPGA0_ANALOGPARAMETER2, BIT( 10 ), 0 );
+		rtl_set_bbreg( hw, 0x818, ( BIT( 26 ) | BIT( 27 ) ),
+			      ( mac->cur_40_prime_sc ==
+			       HAL_PRIME_CHNL_OFFSET_LOWER ) ? 2 : 1 );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "unknown bandwidth: %#X\n", rtlphy->current_chan_bw);
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "unknown bandwidth: %#X\n", rtlphy->current_chan_bw );
 		break;
 	}
-	rtl92cu_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);
+	rtl92cu_phy_rf6052_set_bandwidth( hw, rtlphy->current_chan_bw );
 	rtlphy->set_bwmode_inprogress = false;
-	RT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE, "<==\n");
+	RT_TRACE( rtlpriv, COMP_SCAN, DBG_TRACE, "<==\n" );
 }
 
-void rtl92cu_bb_block_on(struct ieee80211_hw *hw)
+void rtl92cu_bb_block_on( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	mutex_lock(&rtlpriv->io.bb_mutex);
-	rtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);
-	rtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);
-	mutex_unlock(&rtlpriv->io.bb_mutex);
+	mutex_lock( &rtlpriv->io.bb_mutex );
+	rtl_set_bbreg( hw, RFPGA0_RFMOD, BCCKEN, 0x1 );
+	rtl_set_bbreg( hw, RFPGA0_RFMOD, BOFDMEN, 0x1 );
+	mutex_unlock( &rtlpriv->io.bb_mutex );
 }
 
-void _rtl92cu_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t)
+void _rtl92cu_phy_lc_calibrate( struct ieee80211_hw *hw, bool is2t )
 {
 	u8 tmpreg;
 	u32 rf_a_mode = 0, rf_b_mode = 0, lc_cal;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	tmpreg = rtl_read_byte(rtlpriv, 0xd03);
+	tmpreg = rtl_read_byte( rtlpriv, 0xd03 );
 
-	if ((tmpreg & 0x70) != 0)
-		rtl_write_byte(rtlpriv, 0xd03, tmpreg & 0x8F);
+	if ( ( tmpreg & 0x70 ) != 0 )
+		rtl_write_byte( rtlpriv, 0xd03, tmpreg & 0x8F );
 	else
-		rtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);
+		rtl_write_byte( rtlpriv, REG_TXPAUSE, 0xFF );
 
-	if ((tmpreg & 0x70) != 0) {
-		rf_a_mode = rtl_get_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS);
-		if (is2t)
-			rf_b_mode = rtl_get_rfreg(hw, RF90_PATH_B, 0x00,
-						  MASK12BITS);
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS,
-			      (rf_a_mode & 0x8FFFF) | 0x10000);
-		if (is2t)
-			rtl_set_rfreg(hw, RF90_PATH_B, 0x00, MASK12BITS,
-				      (rf_b_mode & 0x8FFFF) | 0x10000);
+	if ( ( tmpreg & 0x70 ) != 0 ) {
+		rf_a_mode = rtl_get_rfreg( hw, RF90_PATH_A, 0x00, MASK12BITS );
+		if ( is2t )
+			rf_b_mode = rtl_get_rfreg( hw, RF90_PATH_B, 0x00,
+						  MASK12BITS );
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x00, MASK12BITS,
+			      ( rf_a_mode & 0x8FFFF ) | 0x10000 );
+		if ( is2t )
+			rtl_set_rfreg( hw, RF90_PATH_B, 0x00, MASK12BITS,
+				      ( rf_b_mode & 0x8FFFF ) | 0x10000 );
 	}
-	lc_cal = rtl_get_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS);
-	rtl_set_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS, lc_cal | 0x08000);
-	mdelay(100);
-	if ((tmpreg & 0x70) != 0) {
-		rtl_write_byte(rtlpriv, 0xd03, tmpreg);
-		rtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS, rf_a_mode);
-		if (is2t)
-			rtl_set_rfreg(hw, RF90_PATH_B, 0x00, MASK12BITS,
-				      rf_b_mode);
+	lc_cal = rtl_get_rfreg( hw, RF90_PATH_A, 0x18, MASK12BITS );
+	rtl_set_rfreg( hw, RF90_PATH_A, 0x18, MASK12BITS, lc_cal | 0x08000 );
+	mdelay( 100 );
+	if ( ( tmpreg & 0x70 ) != 0 ) {
+		rtl_write_byte( rtlpriv, 0xd03, tmpreg );
+		rtl_set_rfreg( hw, RF90_PATH_A, 0x00, MASK12BITS, rf_a_mode );
+		if ( is2t )
+			rtl_set_rfreg( hw, RF90_PATH_B, 0x00, MASK12BITS,
+				      rf_b_mode );
 	} else {
-		rtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);
+		rtl_write_byte( rtlpriv, REG_TXPAUSE, 0x00 );
 	}
 }
 
-static bool _rtl92cu_phy_set_rf_power_state(struct ieee80211_hw *hw,
-					    enum rf_pwrstate rfpwr_state)
+static bool _rtl92cu_phy_set_rf_power_state( struct ieee80211_hw *hw,
+					    enum rf_pwrstate rfpwr_state )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_pci_priv *pcipriv = rtl_pcipriv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
 	bool bresult = true;
 	u8 i, queue_id;
 	struct rtl8192_tx_ring *ring = NULL;
 
-	switch (rfpwr_state) {
+	switch ( rfpwr_state ) {
 	case ERFON:
-		if ((ppsc->rfpwr_state == ERFOFF) &&
-		    RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {
+		if ( ( ppsc->rfpwr_state == ERFOFF ) &&
+		    RT_IN_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_HALT_NIC ) ) {
 			bool rtstatus;
 			u32 InitializeCount = 0;
 
 			do {
 				InitializeCount++;
-				RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
-					 "IPS Set eRf nic enable\n");
-				rtstatus = rtl_ps_enable_nic(hw);
-			} while (!rtstatus && (InitializeCount < 10));
-			RT_CLEAR_PS_LEVEL(ppsc,
-					  RT_RF_OFF_LEVL_HALT_NIC);
+				RT_TRACE( rtlpriv, COMP_RF, DBG_DMESG,
+					 "IPS Set eRf nic enable\n" );
+				rtstatus = rtl_ps_enable_nic( hw );
+			} while ( !rtstatus && ( InitializeCount < 10 ) );
+			RT_CLEAR_PS_LEVEL( ppsc,
+					  RT_RF_OFF_LEVL_HALT_NIC );
 		} else {
-			RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
+			RT_TRACE( rtlpriv, COMP_RF, DBG_DMESG,
 				 "Set ERFON sleeped:%d ms\n",
-				 jiffies_to_msecs(jiffies -
-						  ppsc->last_sleep_jiffies));
+				 jiffies_to_msecs( jiffies -
+						  ppsc->last_sleep_jiffies ) );
 			ppsc->last_awake_jiffies = jiffies;
-			rtl92ce_phy_set_rf_on(hw);
+			rtl92ce_phy_set_rf_on( hw );
 		}
-		if (mac->link_state == MAC80211_LINKED) {
-			rtlpriv->cfg->ops->led_control(hw,
-						       LED_CTL_LINK);
+		if ( mac->link_state == MAC80211_LINKED ) {
+			rtlpriv->cfg->ops->led_control( hw,
+						       LED_CTL_LINK );
 		} else {
-			rtlpriv->cfg->ops->led_control(hw,
-						       LED_CTL_NO_LINK);
+			rtlpriv->cfg->ops->led_control( hw,
+						       LED_CTL_NO_LINK );
 		}
 		break;
 	case ERFOFF:
-		for (queue_id = 0, i = 0;
-		     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {
+		for ( queue_id = 0, i = 0;
+		     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT; ) {
 			ring = &pcipriv->dev.tx_ring[queue_id];
-			if (skb_queue_len(&ring->queue) == 0 ||
-				queue_id == BEACON_QUEUE) {
+			if ( skb_queue_len( &ring->queue ) == 0 ||
+				queue_id == BEACON_QUEUE ) {
 				queue_id++;
 				continue;
 			} else {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+				RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 					 "eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\n",
 					 i + 1,
 					 queue_id,
-					 skb_queue_len(&ring->queue));
-				udelay(10);
+					 skb_queue_len( &ring->queue ) );
+				udelay( 10 );
 				i++;
 			}
-			if (i >= MAX_DOZE_WAITING_TIMES_9x) {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+			if ( i >= MAX_DOZE_WAITING_TIMES_9x ) {
+				RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 					 "ERFOFF: %d times TcbBusyQueue[%d] = %d !\n",
 					 MAX_DOZE_WAITING_TIMES_9x,
 					 queue_id,
-					 skb_queue_len(&ring->queue));
+					 skb_queue_len( &ring->queue ) );
 				break;
 			}
 		}
-		if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {
-			RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
-				 "IPS Set eRf nic disable\n");
-			rtl_ps_disable_nic(hw);
-			RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
+		if ( ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC ) {
+			RT_TRACE( rtlpriv, COMP_RF, DBG_DMESG,
+				 "IPS Set eRf nic disable\n" );
+			rtl_ps_disable_nic( hw );
+			RT_SET_PS_LEVEL( ppsc, RT_RF_OFF_LEVL_HALT_NIC );
 		} else {
-			if (ppsc->rfoff_reason == RF_CHANGE_BY_IPS) {
-				rtlpriv->cfg->ops->led_control(hw,
-							 LED_CTL_NO_LINK);
+			if ( ppsc->rfoff_reason == RF_CHANGE_BY_IPS ) {
+				rtlpriv->cfg->ops->led_control( hw,
+							 LED_CTL_NO_LINK );
 			} else {
-				rtlpriv->cfg->ops->led_control(hw,
-							 LED_CTL_POWER_OFF);
+				rtlpriv->cfg->ops->led_control( hw,
+							 LED_CTL_POWER_OFF );
 			}
 		}
 		break;
 	case ERFSLEEP:
-		if (ppsc->rfpwr_state == ERFOFF)
+		if ( ppsc->rfpwr_state == ERFOFF )
 			return false;
-		for (queue_id = 0, i = 0;
-		     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {
+		for ( queue_id = 0, i = 0;
+		     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT; ) {
 			ring = &pcipriv->dev.tx_ring[queue_id];
-			if (skb_queue_len(&ring->queue) == 0) {
+			if ( skb_queue_len( &ring->queue ) == 0 ) {
 				queue_id++;
 				continue;
 			} else {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+				RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 					 "eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\n",
 					 i + 1, queue_id,
-					 skb_queue_len(&ring->queue));
-				udelay(10);
+					 skb_queue_len( &ring->queue ) );
+				udelay( 10 );
 				i++;
 			}
-			if (i >= MAX_DOZE_WAITING_TIMES_9x) {
-				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+			if ( i >= MAX_DOZE_WAITING_TIMES_9x ) {
+				RT_TRACE( rtlpriv, COMP_ERR, DBG_WARNING,
 					 "ERFSLEEP: %d times TcbBusyQueue[%d] = %d !\n",
 					 MAX_DOZE_WAITING_TIMES_9x,
 					 queue_id,
-					 skb_queue_len(&ring->queue));
+					 skb_queue_len( &ring->queue ) );
 				break;
 			}
 		}
-		RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
+		RT_TRACE( rtlpriv, COMP_RF, DBG_DMESG,
 			 "Set ERFSLEEP awaked:%d ms\n",
-			 jiffies_to_msecs(jiffies - ppsc->last_awake_jiffies));
+			 jiffies_to_msecs( jiffies - ppsc->last_awake_jiffies ) );
 		ppsc->last_sleep_jiffies = jiffies;
-		_rtl92c_phy_set_rf_sleep(hw);
+		_rtl92c_phy_set_rf_sleep( hw );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "switch case not processed\n");
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n" );
 		bresult = false;
 		break;
 	}
-	if (bresult)
+	if ( bresult )
 		ppsc->rfpwr_state = rfpwr_state;
 	return bresult;
 }
 
-bool rtl92cu_phy_set_rf_power_state(struct ieee80211_hw *hw,
-				    enum rf_pwrstate rfpwr_state)
+bool rtl92cu_phy_set_rf_power_state( struct ieee80211_hw *hw,
+				    enum rf_pwrstate rfpwr_state )
 {
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
 	bool bresult = false;
 
-	if (rfpwr_state == ppsc->rfpwr_state)
+	if ( rfpwr_state == ppsc->rfpwr_state )
 		return bresult;
-	bresult = _rtl92cu_phy_set_rf_power_state(hw, rfpwr_state);
+	bresult = _rtl92cu_phy_set_rf_power_state( hw, rfpwr_state );
 	return bresult;
 }
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/phy.h b/drivers/net/wireless/rtlwifi/rtl8192cu/phy.h
index 42b0686..23bee3e 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/phy.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/phy.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,28 +23,35 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
 
 #include "../rtl8192ce/phy.h"
 
-void rtl92cu_bb_block_on(struct ieee80211_hw *hw);
-bool rtl8192_phy_check_is_legal_rfpath(struct ieee80211_hw *hw, u32 rfpath);
-void rtl92c_phy_set_io(struct ieee80211_hw *hw);
-bool _rtl92cu_phy_config_mac_with_headerfile(struct ieee80211_hw *hw);
-bool rtl92cu_phy_bb_config(struct ieee80211_hw *hw);
-u32 rtl92cu_phy_query_rf_reg(struct ieee80211_hw *hw,
-			     enum radio_path rfpath, u32 regaddr, u32 bitmask);
-void rtl92cu_phy_set_rf_reg(struct ieee80211_hw *hw,
+void rtl92cu_bb_block_on( struct ieee80211_hw *hw );
+bool rtl8192_phy_check_is_legal_rfpath( struct ieee80211_hw *hw, u32 rfpath );
+void rtl92c_phy_set_io( struct ieee80211_hw *hw );
+bool _rtl92cu_phy_config_mac_with_headerfile( struct ieee80211_hw *hw );
+bool rtl92cu_phy_bb_config( struct ieee80211_hw *hw );
+u32 rtl92cu_phy_query_rf_reg( struct ieee80211_hw *hw,
+			     enum radio_path rfpath, u32 regaddr, u32 bitmask );
+void rtl92cu_phy_set_rf_reg( struct ieee80211_hw *hw,
 			    enum radio_path rfpath,
-			    u32 regaddr, u32 bitmask, u32 data);
-bool rtl92cu_phy_mac_config(struct ieee80211_hw *hw);
-bool _rtl92cu_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,
-					      u8 configtype);
-void _rtl92cu_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t);
-bool _rtl92cu_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,
-					    u8 configtype);
-void rtl92cu_phy_set_bw_mode_callback(struct ieee80211_hw *hw);
-bool rtl92cu_phy_set_rf_power_state(struct ieee80211_hw *hw,
-				    enum rf_pwrstate rfpwr_state);
+			    u32 regaddr, u32 bitmask, u32 data );
+bool rtl92cu_phy_mac_config( struct ieee80211_hw *hw );
+bool _rtl92cu_phy_config_bb_with_pgheaderfile( struct ieee80211_hw *hw,
+					      u8 configtype );
+void _rtl92cu_phy_lc_calibrate( struct ieee80211_hw *hw, bool is2t );
+bool _rtl92cu_phy_config_bb_with_headerfile( struct ieee80211_hw *hw,
+					    u8 configtype );
+void rtl92cu_phy_set_bw_mode_callback( struct ieee80211_hw *hw );
+bool rtl92cu_phy_set_rf_power_state( struct ieee80211_hw *hw,
+				    enum rf_pwrstate rfpwr_state );
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/reg.h b/drivers/net/wireless/rtlwifi/rtl8192cu/reg.h
index 8b81465..f3d4f5b 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/reg.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/reg.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/rf.c b/drivers/net/wireless/rtlwifi/rtl8192cu/rf.c
index b878d56..523f30c 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/rf.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/rf.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -34,298 +41,298 @@
 #include "rf.h"
 #include "dm.h"
 
-static bool _rtl92c_phy_rf6052_config_parafile(struct ieee80211_hw *hw);
+static bool _rtl92c_phy_rf6052_config_parafile( struct ieee80211_hw *hw );
 
-void rtl92cu_phy_rf6052_set_bandwidth(struct ieee80211_hw *hw, u8 bandwidth)
+void rtl92cu_phy_rf6052_set_bandwidth( struct ieee80211_hw *hw, u8 bandwidth )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 
-	switch (bandwidth) {
+	switch ( bandwidth ) {
 	case HT_CHANNEL_WIDTH_20:
-		rtlphy->rfreg_chnlval[0] = ((rtlphy->rfreg_chnlval[0] &
-					     0xfffff3ff) | 0x0400);
-		rtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,
-			      rtlphy->rfreg_chnlval[0]);
+		rtlphy->rfreg_chnlval[0] = ( ( rtlphy->rfreg_chnlval[0] &
+					     0xfffff3ff ) | 0x0400 );
+		rtl_set_rfreg( hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,
+			      rtlphy->rfreg_chnlval[0] );
 		break;
 	case HT_CHANNEL_WIDTH_20_40:
-		rtlphy->rfreg_chnlval[0] = ((rtlphy->rfreg_chnlval[0] &
-					     0xfffff3ff));
-		rtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,
-			      rtlphy->rfreg_chnlval[0]);
+		rtlphy->rfreg_chnlval[0] = ( ( rtlphy->rfreg_chnlval[0] &
+					     0xfffff3ff ) );
+		rtl_set_rfreg( hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,
+			      rtlphy->rfreg_chnlval[0] );
 		break;
 	default:
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "unknown bandwidth: %#X\n", bandwidth);
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "unknown bandwidth: %#X\n", bandwidth );
 		break;
 	}
 }
 
-void rtl92cu_phy_rf6052_set_cck_txpower(struct ieee80211_hw *hw,
-					u8 *ppowerlevel)
+void rtl92cu_phy_rf6052_set_cck_txpower( struct ieee80211_hw *hw,
+					u8 *ppowerlevel )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_hal *rtlhal = rtl_hal( rtlpriv );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	u32 tx_agc[2] = { 0, 0 }, tmpval = 0;
 	bool turbo_scanoff = false;
 	u8 idx1, idx2;
 	u8 *ptr;
 
-	if (rtlhal->interface == INTF_PCI) {
-		if (rtlefuse->eeprom_regulatory != 0)
+	if ( rtlhal->interface == INTF_PCI ) {
+		if ( rtlefuse->eeprom_regulatory != 0 )
 			turbo_scanoff = true;
 	} else {
-		if ((rtlefuse->eeprom_regulatory != 0) ||
-		    (rtlefuse->external_pa))
+		if ( ( rtlefuse->eeprom_regulatory != 0 ) ||
+		    ( rtlefuse->external_pa ) )
 			turbo_scanoff = true;
 	}
-	if (mac->act_scanning) {
+	if ( mac->act_scanning ) {
 		tx_agc[RF90_PATH_A] = 0x3f3f3f3f;
 		tx_agc[RF90_PATH_B] = 0x3f3f3f3f;
-		for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
+		for ( idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++ ) {
 			tx_agc[idx1] = ppowerlevel[idx1] |
-			    (ppowerlevel[idx1] << 8) |
-			    (ppowerlevel[idx1] << 16) |
-			    (ppowerlevel[idx1] << 24);
-			if (rtlhal->interface == INTF_USB) {
-				if (tx_agc[idx1] > 0x20 &&
-				    rtlefuse->external_pa)
+			    ( ppowerlevel[idx1] << 8 ) |
+			    ( ppowerlevel[idx1] << 16 ) |
+			    ( ppowerlevel[idx1] << 24 );
+			if ( rtlhal->interface == INTF_USB ) {
+				if ( tx_agc[idx1] > 0x20 &&
+				    rtlefuse->external_pa )
 					tx_agc[idx1] = 0x20;
 			}
 		}
 	} else {
-		if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-		    TXHIGHPWRLEVEL_LEVEL1) {
+		if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+		    TXHIGHPWRLEVEL_LEVEL1 ) {
 			tx_agc[RF90_PATH_A] = 0x10101010;
 			tx_agc[RF90_PATH_B] = 0x10101010;
-		} else if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-			   TXHIGHPWRLEVEL_LEVEL2) {
+		} else if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+			   TXHIGHPWRLEVEL_LEVEL2 ) {
 			tx_agc[RF90_PATH_A] = 0x00000000;
 			tx_agc[RF90_PATH_B] = 0x00000000;
 		} else {
-			for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
+			for ( idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++ ) {
 				tx_agc[idx1] = ppowerlevel[idx1] |
-				    (ppowerlevel[idx1] << 8) |
-				    (ppowerlevel[idx1] << 16) |
-				    (ppowerlevel[idx1] << 24);
+				    ( ppowerlevel[idx1] << 8 ) |
+				    ( ppowerlevel[idx1] << 16 ) |
+				    ( ppowerlevel[idx1] << 24 );
 			}
-			if (rtlefuse->eeprom_regulatory == 0) {
-				tmpval = (rtlphy->mcs_offset[0][6]) +
-					(rtlphy->mcs_offset[0][7] <<  8);
+			if ( rtlefuse->eeprom_regulatory == 0 ) {
+				tmpval = ( rtlphy->mcs_offset[0][6] ) +
+					( rtlphy->mcs_offset[0][7] <<  8 );
 				tx_agc[RF90_PATH_A] += tmpval;
-				tmpval = (rtlphy->mcs_offset[0][14]) +
-					(rtlphy->mcs_offset[0][15] << 24);
+				tmpval = ( rtlphy->mcs_offset[0][14] ) +
+					( rtlphy->mcs_offset[0][15] << 24 );
 				tx_agc[RF90_PATH_B] += tmpval;
 			}
 		}
 	}
-	for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
-		ptr = (u8 *) (&(tx_agc[idx1]));
-		for (idx2 = 0; idx2 < 4; idx2++) {
-			if (*ptr > RF6052_MAX_TX_PWR)
+	for ( idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++ ) {
+		ptr = ( u8 * ) ( &( tx_agc[idx1] ) );
+		for ( idx2 = 0; idx2 < 4; idx2++ ) {
+			if ( *ptr > RF6052_MAX_TX_PWR )
 				*ptr = RF6052_MAX_TX_PWR;
 			ptr++;
 		}
 	}
 	tmpval = tx_agc[RF90_PATH_A] & 0xff;
-	rtl_set_bbreg(hw, RTXAGC_A_CCK1_MCS32, MASKBYTE1, tmpval);
+	rtl_set_bbreg( hw, RTXAGC_A_CCK1_MCS32, MASKBYTE1, tmpval );
 
-	RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+	RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 		"CCK PWR 1M (rf-A) = 0x%x (reg 0x%x)\n",
-		tmpval, RTXAGC_A_CCK1_MCS32);
+		tmpval, RTXAGC_A_CCK1_MCS32 );
 
 	tmpval = tx_agc[RF90_PATH_A] >> 8;
-	if (mac->mode == WIRELESS_MODE_B)
+	if ( mac->mode == WIRELESS_MODE_B )
 		tmpval = tmpval & 0xff00ffff;
-	rtl_set_bbreg(hw, RTXAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
-	RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+	rtl_set_bbreg( hw, RTXAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval );
+	RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 		"CCK PWR 2~11M (rf-A) = 0x%x (reg 0x%x)\n",
-		tmpval, RTXAGC_B_CCK11_A_CCK2_11);
+		tmpval, RTXAGC_B_CCK11_A_CCK2_11 );
 	tmpval = tx_agc[RF90_PATH_B] >> 24;
-	rtl_set_bbreg(hw, RTXAGC_B_CCK11_A_CCK2_11, MASKBYTE0, tmpval);
-	RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+	rtl_set_bbreg( hw, RTXAGC_B_CCK11_A_CCK2_11, MASKBYTE0, tmpval );
+	RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 		"CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n",
-		tmpval, RTXAGC_B_CCK11_A_CCK2_11);
+		tmpval, RTXAGC_B_CCK11_A_CCK2_11 );
 	tmpval = tx_agc[RF90_PATH_B] & 0x00ffffff;
-	rtl_set_bbreg(hw, RTXAGC_B_CCK1_55_MCS32, 0xffffff00, tmpval);
-	RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+	rtl_set_bbreg( hw, RTXAGC_B_CCK1_55_MCS32, 0xffffff00, tmpval );
+	RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 		"CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n",
-		tmpval, RTXAGC_B_CCK1_55_MCS32);
+		tmpval, RTXAGC_B_CCK1_55_MCS32 );
 }
 
-static void rtl92c_phy_get_power_base(struct ieee80211_hw *hw,
+static void rtl92c_phy_get_power_base( struct ieee80211_hw *hw,
 				      u8 *ppowerlevel, u8 channel,
-				      u32 *ofdmbase, u32 *mcsbase)
+				      u32 *ofdmbase, u32 *mcsbase )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	u32 powerBase0, powerBase1;
 	u8 legacy_pwrdiff = 0, ht20_pwrdiff = 0;
 	u8 i, powerlevel[2];
 
-	for (i = 0; i < 2; i++) {
+	for ( i = 0; i < 2; i++ ) {
 		powerlevel[i] = ppowerlevel[i];
 		legacy_pwrdiff = rtlefuse->txpwr_legacyhtdiff[i][channel - 1];
 		powerBase0 = powerlevel[i] + legacy_pwrdiff;
-		powerBase0 = (powerBase0 << 24) | (powerBase0 << 16) |
-		    (powerBase0 << 8) | powerBase0;
-		*(ofdmbase + i) = powerBase0;
-		RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+		powerBase0 = ( powerBase0 << 24 ) | ( powerBase0 << 16 ) |
+		    ( powerBase0 << 8 ) | powerBase0;
+		*( ofdmbase + i ) = powerBase0;
+		RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 			" [OFDM power base index rf(%c) = 0x%x]\n",
-			i == 0 ? 'A' : 'B', *(ofdmbase + i));
+			i == 0 ? 'A' : 'B', *( ofdmbase + i ) );
 	}
-	for (i = 0; i < 2; i++) {
-		if (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20) {
+	for ( i = 0; i < 2; i++ ) {
+		if ( rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ) {
 			ht20_pwrdiff = rtlefuse->txpwr_ht20diff[i][channel - 1];
 			powerlevel[i] += ht20_pwrdiff;
 		}
 		powerBase1 = powerlevel[i];
-		powerBase1 = (powerBase1 << 24) |
-		    (powerBase1 << 16) | (powerBase1 << 8) | powerBase1;
-		*(mcsbase + i) = powerBase1;
-		RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+		powerBase1 = ( powerBase1 << 24 ) |
+		    ( powerBase1 << 16 ) | ( powerBase1 << 8 ) | powerBase1;
+		*( mcsbase + i ) = powerBase1;
+		RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 			" [MCS power base index rf(%c) = 0x%x]\n",
-			i == 0 ? 'A' : 'B', *(mcsbase + i));
+			i == 0 ? 'A' : 'B', *( mcsbase + i ) );
 	}
 }
 
-static void _rtl92c_get_txpower_writeval_by_regulatory(struct ieee80211_hw *hw,
+static void _rtl92c_get_txpower_writeval_by_regulatory( struct ieee80211_hw *hw,
 						       u8 channel, u8 index,
 						       u32 *powerBase0,
 						       u32 *powerBase1,
-						       u32 *p_outwriteval)
+						       u32 *p_outwriteval )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
-	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
+	struct rtl_efuse *rtlefuse = rtl_efuse( rtl_priv( hw ) );
 	u8 i, chnlgroup = 0, pwr_diff_limit[4];
 	u32 writeVal, customer_limit, rf;
 
-	for (rf = 0; rf < 2; rf++) {
-		switch (rtlefuse->eeprom_regulatory) {
+	for ( rf = 0; rf < 2; rf++ ) {
+		switch ( rtlefuse->eeprom_regulatory ) {
 		case 0:
 			chnlgroup = 0;
 			writeVal = rtlphy->mcs_offset
-			    [chnlgroup][index + (rf ? 8 : 0)]
-			    + ((index < 2) ? powerBase0[rf] : powerBase1[rf]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+			    [chnlgroup][index + ( rf ? 8 : 0 )]
+			    + ( ( index < 2 ) ? powerBase0[rf] : powerBase1[rf] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"RTK better performance,writeVal(%c) = 0x%x\n",
-				rf == 0 ? 'A' : 'B', writeVal);
+				rf == 0 ? 'A' : 'B', writeVal );
 			break;
 		case 1:
-			if (rtlphy->pwrgroup_cnt == 1)
+			if ( rtlphy->pwrgroup_cnt == 1 )
 				chnlgroup = 0;
-			if (rtlphy->pwrgroup_cnt >= 3) {
-				if (channel <= 3)
+			if ( rtlphy->pwrgroup_cnt >= 3 ) {
+				if ( channel <= 3 )
 					chnlgroup = 0;
-				else if (channel >= 4 && channel <= 9)
+				else if ( channel >= 4 && channel <= 9 )
 					chnlgroup = 1;
-				else if (channel > 9)
+				else if ( channel > 9 )
 					chnlgroup = 2;
-				if (rtlphy->current_chan_bw ==
-				    HT_CHANNEL_WIDTH_20)
+				if ( rtlphy->current_chan_bw ==
+				    HT_CHANNEL_WIDTH_20 )
 					chnlgroup++;
 				else
 					chnlgroup += 4;
 			}
 			writeVal = rtlphy->mcs_offset[chnlgroup][index +
-					(rf ? 8 : 0)] +
-					((index < 2) ? powerBase0[rf] :
-					powerBase1[rf]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+					( rf ? 8 : 0 )] +
+					( ( index < 2 ) ? powerBase0[rf] :
+					powerBase1[rf] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"Realtek regulatory, 20MHz, writeVal(%c) = 0x%x\n",
-				rf == 0 ? 'A' : 'B', writeVal);
+				rf == 0 ? 'A' : 'B', writeVal );
 			break;
 		case 2:
-			writeVal = ((index < 2) ? powerBase0[rf] :
-				   powerBase1[rf]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+			writeVal = ( ( index < 2 ) ? powerBase0[rf] :
+				   powerBase1[rf] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"Better regulatory,writeVal(%c) = 0x%x\n",
-				rf == 0 ? 'A' : 'B', writeVal);
+				rf == 0 ? 'A' : 'B', writeVal );
 			break;
 		case 3:
 			chnlgroup = 0;
-			if (rtlphy->current_chan_bw ==
-			    HT_CHANNEL_WIDTH_20_40) {
-				RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+			if ( rtlphy->current_chan_bw ==
+			    HT_CHANNEL_WIDTH_20_40 ) {
+				RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 					"customer's limit, 40MHzrf(%c) = 0x%x\n",
 					rf == 0 ? 'A' : 'B',
 					rtlefuse->pwrgroup_ht40[rf]
-					[channel - 1]);
+					[channel - 1] );
 			} else {
-				RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+				RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 					"customer's limit, 20MHz rf(%c) = 0x%x\n",
 					rf == 0 ? 'A' : 'B',
 					rtlefuse->pwrgroup_ht20[rf]
-					[channel - 1]);
+					[channel - 1] );
 			}
-			for (i = 0; i < 4; i++) {
-				pwr_diff_limit[i] = (u8) ((rtlphy->mcs_offset
-				    [chnlgroup][index + (rf ? 8 : 0)]
-				    & (0x7f << (i * 8))) >> (i * 8));
-				if (rtlphy->current_chan_bw ==
-				    HT_CHANNEL_WIDTH_20_40) {
-					if (pwr_diff_limit[i] >
+			for ( i = 0; i < 4; i++ ) {
+				pwr_diff_limit[i] = ( u8 ) ( ( rtlphy->mcs_offset
+				    [chnlgroup][index + ( rf ? 8 : 0 )]
+				    & ( 0x7f << ( i * 8 ) ) ) >> ( i * 8 ) );
+				if ( rtlphy->current_chan_bw ==
+				    HT_CHANNEL_WIDTH_20_40 ) {
+					if ( pwr_diff_limit[i] >
 					    rtlefuse->pwrgroup_ht40[rf]
-						[channel - 1])
+						[channel - 1] )
 						pwr_diff_limit[i] = rtlefuse->
 						    pwrgroup_ht40[rf]
 						    [channel - 1];
 				} else {
-					if (pwr_diff_limit[i] >
+					if ( pwr_diff_limit[i] >
 					    rtlefuse->pwrgroup_ht20[rf]
-						[channel - 1])
+						[channel - 1] )
 						pwr_diff_limit[i] =
 						    rtlefuse->pwrgroup_ht20[rf]
 						    [channel - 1];
 				}
 			}
-			customer_limit = (pwr_diff_limit[3] << 24) |
-			    (pwr_diff_limit[2] << 16) |
-			    (pwr_diff_limit[1] << 8) | (pwr_diff_limit[0]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+			customer_limit = ( pwr_diff_limit[3] << 24 ) |
+			    ( pwr_diff_limit[2] << 16 ) |
+			    ( pwr_diff_limit[1] << 8 ) | ( pwr_diff_limit[0] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"Customer's limit rf(%c) = 0x%x\n",
-				rf == 0 ? 'A' : 'B', customer_limit);
-			writeVal = customer_limit + ((index < 2) ?
-				   powerBase0[rf] : powerBase1[rf]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+				rf == 0 ? 'A' : 'B', customer_limit );
+			writeVal = customer_limit + ( ( index < 2 ) ?
+				   powerBase0[rf] : powerBase1[rf] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"Customer, writeVal rf(%c)= 0x%x\n",
-				rf == 0 ? 'A' : 'B', writeVal);
+				rf == 0 ? 'A' : 'B', writeVal );
 			break;
 		default:
 			chnlgroup = 0;
 			writeVal = rtlphy->mcs_offset[chnlgroup]
-				   [index + (rf ? 8 : 0)] + ((index < 2) ?
-				   powerBase0[rf] : powerBase1[rf]);
-			RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
+				   [index + ( rf ? 8 : 0 )] + ( ( index < 2 ) ?
+				   powerBase0[rf] : powerBase1[rf] );
+			RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
 				"RTK better performance, writeValrf(%c) = 0x%x\n",
-				rf == 0 ? 'A' : 'B', writeVal);
+				rf == 0 ? 'A' : 'B', writeVal );
 			break;
 		}
-		if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-		    TXHIGHPWRLEVEL_LEVEL1)
+		if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+		    TXHIGHPWRLEVEL_LEVEL1 )
 			writeVal = 0x14141414;
-		else if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-			 TXHIGHPWRLEVEL_LEVEL2)
+		else if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+			 TXHIGHPWRLEVEL_LEVEL2 )
 			writeVal = 0x00000000;
-		if (rtlpriv->dm.dynamic_txhighpower_lvl == TXHIGHPWRLEVEL_BT1)
+		if ( rtlpriv->dm.dynamic_txhighpower_lvl == TXHIGHPWRLEVEL_BT1 )
 			writeVal = writeVal - 0x06060606;
-		else if (rtlpriv->dm.dynamic_txhighpower_lvl ==
-			 TXHIGHPWRLEVEL_BT2)
+		else if ( rtlpriv->dm.dynamic_txhighpower_lvl ==
+			 TXHIGHPWRLEVEL_BT2 )
 			writeVal = writeVal;
-		*(p_outwriteval + rf) = writeVal;
+		*( p_outwriteval + rf ) = writeVal;
 	}
 }
 
-static void _rtl92c_write_ofdm_power_reg(struct ieee80211_hw *hw,
-					 u8 index, u32 *pValue)
+static void _rtl92c_write_ofdm_power_reg( struct ieee80211_hw *hw,
+					 u8 index, u32 *pValue )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	u16 regoffset_a[6] = {
 		RTXAGC_A_RATE18_06, RTXAGC_A_RATE54_24,
 		RTXAGC_A_MCS03_MCS00, RTXAGC_A_MCS07_MCS04,
@@ -340,149 +347,149 @@ static void _rtl92c_write_ofdm_power_reg(struct ieee80211_hw *hw,
 	u32 writeVal;
 	u16 regoffset;
 
-	for (rf = 0; rf < 2; rf++) {
+	for ( rf = 0; rf < 2; rf++ ) {
 		writeVal = pValue[rf];
-		for (i = 0; i < 4; i++) {
-			pwr_val[i] = (u8)((writeVal & (0x7f << (i * 8))) >>
-					  (i * 8));
-			if (pwr_val[i] > RF6052_MAX_TX_PWR)
+		for ( i = 0; i < 4; i++ ) {
+			pwr_val[i] = ( u8 )( ( writeVal & ( 0x7f << ( i * 8 ) ) ) >>
+					  ( i * 8 ) );
+			if ( pwr_val[i] > RF6052_MAX_TX_PWR )
 				pwr_val[i] = RF6052_MAX_TX_PWR;
 		}
-		writeVal = (pwr_val[3] << 24) | (pwr_val[2] << 16) |
-		    (pwr_val[1] << 8) | pwr_val[0];
-		if (rf == 0)
+		writeVal = ( pwr_val[3] << 24 ) | ( pwr_val[2] << 16 ) |
+		    ( pwr_val[1] << 8 ) | pwr_val[0];
+		if ( rf == 0 )
 			regoffset = regoffset_a[index];
 		else
 			regoffset = regoffset_b[index];
-		rtl_set_bbreg(hw, regoffset, MASKDWORD, writeVal);
-		RTPRINT(rtlpriv, FPHY, PHY_TXPWR,
-			"Set 0x%x = %08x\n", regoffset, writeVal);
-		if (((get_rf_type(rtlphy) == RF_2T2R) &&
-		     (regoffset == RTXAGC_A_MCS15_MCS12 ||
-		      regoffset == RTXAGC_B_MCS15_MCS12)) ||
-		    ((get_rf_type(rtlphy) != RF_2T2R) &&
-		     (regoffset == RTXAGC_A_MCS07_MCS04 ||
-		      regoffset == RTXAGC_B_MCS07_MCS04))) {
+		rtl_set_bbreg( hw, regoffset, MASKDWORD, writeVal );
+		RTPRINT( rtlpriv, FPHY, PHY_TXPWR,
+			"Set 0x%x = %08x\n", regoffset, writeVal );
+		if ( ( ( get_rf_type( rtlphy ) == RF_2T2R ) &&
+		     ( regoffset == RTXAGC_A_MCS15_MCS12 ||
+		      regoffset == RTXAGC_B_MCS15_MCS12 ) ) ||
+		    ( ( get_rf_type( rtlphy ) != RF_2T2R ) &&
+		     ( regoffset == RTXAGC_A_MCS07_MCS04 ||
+		      regoffset == RTXAGC_B_MCS07_MCS04 ) ) ) {
 			writeVal = pwr_val[3];
-			if (regoffset == RTXAGC_A_MCS15_MCS12 ||
-			    regoffset == RTXAGC_A_MCS07_MCS04)
+			if ( regoffset == RTXAGC_A_MCS15_MCS12 ||
+			    regoffset == RTXAGC_A_MCS07_MCS04 )
 				regoffset = 0xc90;
-			if (regoffset == RTXAGC_B_MCS15_MCS12 ||
-			    regoffset == RTXAGC_B_MCS07_MCS04)
+			if ( regoffset == RTXAGC_B_MCS15_MCS12 ||
+			    regoffset == RTXAGC_B_MCS07_MCS04 )
 				regoffset = 0xc98;
-			for (i = 0; i < 3; i++) {
-				if (i != 2)
-					writeVal = (writeVal > 8) ?
-						   (writeVal - 8) : 0;
+			for ( i = 0; i < 3; i++ ) {
+				if ( i != 2 )
+					writeVal = ( writeVal > 8 ) ?
+						   ( writeVal - 8 ) : 0;
 				else
-					writeVal = (writeVal > 6) ?
-						   (writeVal - 6) : 0;
-				rtl_write_byte(rtlpriv, (u32)(regoffset + i),
-					      (u8)writeVal);
+					writeVal = ( writeVal > 6 ) ?
+						   ( writeVal - 6 ) : 0;
+				rtl_write_byte( rtlpriv, ( u32 )( regoffset + i ),
+					      ( u8 )writeVal );
 			}
 		}
 	}
 }
 
-void rtl92cu_phy_rf6052_set_ofdm_txpower(struct ieee80211_hw *hw,
-					 u8 *ppowerlevel, u8 channel)
+void rtl92cu_phy_rf6052_set_ofdm_txpower( struct ieee80211_hw *hw,
+					 u8 *ppowerlevel, u8 channel )
 {
 	u32 writeVal[2], powerBase0[2], powerBase1[2];
 	u8 index = 0;
 
-	rtl92c_phy_get_power_base(hw, ppowerlevel,
-				  channel, &powerBase0[0], &powerBase1[0]);
-	for (index = 0; index < 6; index++) {
-		_rtl92c_get_txpower_writeval_by_regulatory(hw,
+	rtl92c_phy_get_power_base( hw, ppowerlevel,
+				  channel, &powerBase0[0], &powerBase1[0] );
+	for ( index = 0; index < 6; index++ ) {
+		_rtl92c_get_txpower_writeval_by_regulatory( hw,
 							   channel, index,
 							   &powerBase0[0],
 							   &powerBase1[0],
-							   &writeVal[0]);
-		_rtl92c_write_ofdm_power_reg(hw, index, &writeVal[0]);
+							   &writeVal[0] );
+		_rtl92c_write_ofdm_power_reg( hw, index, &writeVal[0] );
 	}
 }
 
-bool rtl92cu_phy_rf6052_config(struct ieee80211_hw *hw)
+bool rtl92cu_phy_rf6052_config( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	bool rtstatus = true;
 	u8 b_reg_hwparafile = 1;
 
-	if (rtlphy->rf_type == RF_1T1R)
+	if ( rtlphy->rf_type == RF_1T1R )
 		rtlphy->num_total_rfpath = 1;
 	else
 		rtlphy->num_total_rfpath = 2;
-	if (b_reg_hwparafile == 1)
-		rtstatus = _rtl92c_phy_rf6052_config_parafile(hw);
+	if ( b_reg_hwparafile == 1 )
+		rtstatus = _rtl92c_phy_rf6052_config_parafile( hw );
 	return rtstatus;
 }
 
-static bool _rtl92c_phy_rf6052_config_parafile(struct ieee80211_hw *hw)
+static bool _rtl92c_phy_rf6052_config_parafile( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_phy *rtlphy = &( rtlpriv->phy );
 	u32 u4_regvalue = 0;
 	u8 rfpath;
 	bool rtstatus = true;
 	struct bb_reg_def *pphyreg;
 
-	for (rfpath = 0; rfpath < rtlphy->num_total_rfpath; rfpath++) {
+	for ( rfpath = 0; rfpath < rtlphy->num_total_rfpath; rfpath++ ) {
 		pphyreg = &rtlphy->phyreg_def[rfpath];
-		switch (rfpath) {
+		switch ( rfpath ) {
 		case RF90_PATH_A:
 		case RF90_PATH_C:
-			u4_regvalue = rtl_get_bbreg(hw, pphyreg->rfintfs,
-						    BRFSI_RFENV);
+			u4_regvalue = rtl_get_bbreg( hw, pphyreg->rfintfs,
+						    BRFSI_RFENV );
 			break;
 		case RF90_PATH_B:
 		case RF90_PATH_D:
-			u4_regvalue = rtl_get_bbreg(hw, pphyreg->rfintfs,
-						    BRFSI_RFENV << 16);
+			u4_regvalue = rtl_get_bbreg( hw, pphyreg->rfintfs,
+						    BRFSI_RFENV << 16 );
 			break;
 		}
-		rtl_set_bbreg(hw, pphyreg->rfintfe, BRFSI_RFENV << 16, 0x1);
-		udelay(1);
-		rtl_set_bbreg(hw, pphyreg->rfintfo, BRFSI_RFENV, 0x1);
-		udelay(1);
-		rtl_set_bbreg(hw, pphyreg->rfhssi_para2,
-			      B3WIREADDREAALENGTH, 0x0);
-		udelay(1);
-		rtl_set_bbreg(hw, pphyreg->rfhssi_para2, B3WIREDATALENGTH, 0x0);
-		udelay(1);
-		switch (rfpath) {
+		rtl_set_bbreg( hw, pphyreg->rfintfe, BRFSI_RFENV << 16, 0x1 );
+		udelay( 1 );
+		rtl_set_bbreg( hw, pphyreg->rfintfo, BRFSI_RFENV, 0x1 );
+		udelay( 1 );
+		rtl_set_bbreg( hw, pphyreg->rfhssi_para2,
+			      B3WIREADDREAALENGTH, 0x0 );
+		udelay( 1 );
+		rtl_set_bbreg( hw, pphyreg->rfhssi_para2, B3WIREDATALENGTH, 0x0 );
+		udelay( 1 );
+		switch ( rfpath ) {
 		case RF90_PATH_A:
-			rtstatus = rtl92cu_phy_config_rf_with_headerfile(hw,
-					(enum radio_path) rfpath);
+			rtstatus = rtl92cu_phy_config_rf_with_headerfile( hw,
+					( enum radio_path ) rfpath );
 			break;
 		case RF90_PATH_B:
-			rtstatus = rtl92cu_phy_config_rf_with_headerfile(hw,
-					(enum radio_path) rfpath);
+			rtstatus = rtl92cu_phy_config_rf_with_headerfile( hw,
+					( enum radio_path ) rfpath );
 			break;
 		case RF90_PATH_C:
 			break;
 		case RF90_PATH_D:
 			break;
 		}
-		switch (rfpath) {
+		switch ( rfpath ) {
 		case RF90_PATH_A:
 		case RF90_PATH_C:
-			rtl_set_bbreg(hw, pphyreg->rfintfs,
-				      BRFSI_RFENV, u4_regvalue);
+			rtl_set_bbreg( hw, pphyreg->rfintfs,
+				      BRFSI_RFENV, u4_regvalue );
 			break;
 		case RF90_PATH_B:
 		case RF90_PATH_D:
-			rtl_set_bbreg(hw, pphyreg->rfintfs,
-				      BRFSI_RFENV << 16, u4_regvalue);
+			rtl_set_bbreg( hw, pphyreg->rfintfs,
+				      BRFSI_RFENV << 16, u4_regvalue );
 			break;
 		}
-		if (!rtstatus) {
-			RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
-				 "Radio[%d] Fail!!", rfpath);
+		if ( !rtstatus ) {
+			RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE,
+				 "Radio[%d] Fail!!", rfpath );
 			goto phy_rf_cfg_fail;
 		}
 	}
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "<---\n");
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_TRACE, "<---\n" );
 	return rtstatus;
 phy_rf_cfg_fail:
 	return rtstatus;
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/rf.h b/drivers/net/wireless/rtlwifi/rtl8192cu/rf.h
index 11b439d..56801df 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/rf.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/rf.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -34,17 +41,17 @@
 #define RF6052_MAX_REG			0x3F
 #define RF6052_MAX_PATH			2
 
-void rtl92cu_phy_rf6052_set_bandwidth(struct ieee80211_hw *hw, u8 bandwidth);
-void rtl92c_phy_rf6052_set_cck_txpower(struct ieee80211_hw *hw,
-				       u8 *ppowerlevel);
-void rtl92c_phy_rf6052_set_ofdm_txpower(struct ieee80211_hw *hw,
-					u8 *ppowerlevel, u8 channel);
-bool rtl92cu_phy_rf6052_config(struct ieee80211_hw *hw);
-bool rtl92cu_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,
-					   enum radio_path rfpath);
-void rtl92cu_phy_rf6052_set_cck_txpower(struct ieee80211_hw *hw,
-					u8 *ppowerlevel);
-void rtl92cu_phy_rf6052_set_ofdm_txpower(struct ieee80211_hw *hw,
-					 u8 *ppowerlevel, u8 channel);
+void rtl92cu_phy_rf6052_set_bandwidth( struct ieee80211_hw *hw, u8 bandwidth );
+void rtl92c_phy_rf6052_set_cck_txpower( struct ieee80211_hw *hw,
+				       u8 *ppowerlevel );
+void rtl92c_phy_rf6052_set_ofdm_txpower( struct ieee80211_hw *hw,
+					u8 *ppowerlevel, u8 channel );
+bool rtl92cu_phy_rf6052_config( struct ieee80211_hw *hw );
+bool rtl92cu_phy_config_rf_with_headerfile( struct ieee80211_hw *hw,
+					   enum radio_path rfpath );
+void rtl92cu_phy_rf6052_set_cck_txpower( struct ieee80211_hw *hw,
+					u8 *ppowerlevel );
+void rtl92cu_phy_rf6052_set_ofdm_txpower( struct ieee80211_hw *hw,
+					 u8 *ppowerlevel, u8 channel );
 
 #endif
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
index e06bafe..38ab0c7 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -45,19 +52,19 @@
 #include "../rtl8192c/fw_common.h"
 #include <linux/module.h>
 
-MODULE_AUTHOR("Georgia		<georgia@realtek.com>");
-MODULE_AUTHOR("Ziv Huang	<ziv_huang@realtek.com>");
-MODULE_AUTHOR("Larry Finger	<Larry.Finger@lwfinger.net>");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Realtek 8192C/8188C 802.11n USB wireless");
-MODULE_FIRMWARE("rtlwifi/rtl8192cufw.bin");
-MODULE_FIRMWARE("rtlwifi/rtl8192cufw_A.bin");
-MODULE_FIRMWARE("rtlwifi/rtl8192cufw_B.bin");
-MODULE_FIRMWARE("rtlwifi/rtl8192cufw_TMSC.bin");
-
-static int rtl92cu_init_sw_vars(struct ieee80211_hw *hw)
+MODULE_AUTHOR( "Georgia		<georgia@realtek.com>" );
+MODULE_AUTHOR( "Ziv Huang	<ziv_huang@realtek.com>" );
+MODULE_AUTHOR( "Larry Finger	<Larry.Finger@lwfinger.net>" );
+MODULE_LICENSE( "GPL" );
+MODULE_DESCRIPTION( "Realtek 8192C/8188C 802.11n USB wireless" );
+MODULE_FIRMWARE( "rtlwifi/rtl8192cufw.bin" );
+MODULE_FIRMWARE( "rtlwifi/rtl8192cufw_A.bin" );
+MODULE_FIRMWARE( "rtlwifi/rtl8192cufw_B.bin" );
+MODULE_FIRMWARE( "rtlwifi/rtl8192cufw_TMSC.bin" );
+
+static int rtl92cu_init_sw_vars( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	int err;
 
 	rtlpriv->dm.dm_initialgain_enable = true;
@@ -67,42 +74,42 @@ static int rtl92cu_init_sw_vars(struct ieee80211_hw *hw)
 	rtlpriv->dbg.global_debuglevel = rtlpriv->cfg->mod_params->debug;
 
 	/* for firmware buf */
-	rtlpriv->rtlhal.pfirmware = vzalloc(0x4000);
-	if (!rtlpriv->rtlhal.pfirmware) {
-		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
-			 "Can't alloc buffer for fw\n");
+	rtlpriv->rtlhal.pfirmware = vzalloc( 0x4000 );
+	if ( !rtlpriv->rtlhal.pfirmware ) {
+		RT_TRACE( rtlpriv, COMP_ERR, DBG_EMERG,
+			 "Can't alloc buffer for fw\n" );
 		return 1;
 	}
-	if (IS_VENDOR_UMC_A_CUT(rtlpriv->rtlhal.version) &&
-	    !IS_92C_SERIAL(rtlpriv->rtlhal.version)) {
+	if ( IS_VENDOR_UMC_A_CUT( rtlpriv->rtlhal.version ) &&
+	    !IS_92C_SERIAL( rtlpriv->rtlhal.version ) ) {
 		rtlpriv->cfg->fw_name = "rtlwifi/rtl8192cufw_A.bin";
-	} else if (IS_81XXC_VENDOR_UMC_B_CUT(rtlpriv->rtlhal.version)) {
+	} else if ( IS_81XXC_VENDOR_UMC_B_CUT( rtlpriv->rtlhal.version ) ) {
 		rtlpriv->cfg->fw_name = "rtlwifi/rtl8192cufw_B.bin";
 	} else {
 		rtlpriv->cfg->fw_name = "rtlwifi/rtl8192cufw_TMSC.bin";
 	}
 	/* provide name of alternative file */
 	rtlpriv->cfg->alt_fw_name = "rtlwifi/rtl8192cufw.bin";
-	pr_info("Loading firmware %s\n", rtlpriv->cfg->fw_name);
+	pr_info( "Loading firmware %s\n", rtlpriv->cfg->fw_name );
 	rtlpriv->max_fw_size = 0x4000;
-	err = request_firmware_nowait(THIS_MODULE, 1,
+	err = request_firmware_nowait( THIS_MODULE, 1,
 				      rtlpriv->cfg->fw_name, rtlpriv->io.dev,
-				      GFP_KERNEL, hw, rtl_fw_cb);
+				      GFP_KERNEL, hw, rtl_fw_cb );
 	return err;
 }
 
-static void rtl92cu_deinit_sw_vars(struct ieee80211_hw *hw)
+static void rtl92cu_deinit_sw_vars( struct ieee80211_hw *hw )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (rtlpriv->rtlhal.pfirmware) {
-		vfree(rtlpriv->rtlhal.pfirmware);
+	if ( rtlpriv->rtlhal.pfirmware ) {
+		vfree( rtlpriv->rtlhal.pfirmware );
 		rtlpriv->rtlhal.pfirmware = NULL;
 	}
 }
 
 /* get bt coexist status */
-static bool rtl92cu_get_btc_status(void)
+static bool rtl92cu_get_btc_status( void )
 {
 	return false;
 }
@@ -162,10 +169,10 @@ static struct rtl_mod_params rtl92cu_mod_params = {
 	.debug = DBG_EMERG,
 };
 
-module_param_named(swenc, rtl92cu_mod_params.sw_crypto, bool, 0444);
-module_param_named(debug, rtl92cu_mod_params.debug, int, 0444);
-MODULE_PARM_DESC(swenc, "Set to 1 for software crypto (default 0)\n");
-MODULE_PARM_DESC(debug, "Set debug level (0-5) (default 0)");
+module_param_named( swenc, rtl92cu_mod_params.sw_crypto, bool, 0444 );
+module_param_named( debug, rtl92cu_mod_params.debug, int, 0444 );
+MODULE_PARM_DESC( swenc, "Set to 1 for software crypto (default 0)\n" );
+MODULE_PARM_DESC( debug, "Set debug level (0-5) (default 0)" );
 
 static struct rtl_hal_usbint_cfg rtl92cu_interface_cfg = {
 	/* rx */
@@ -255,7 +262,7 @@ static struct rtl_hal_cfg rtl92cu_hal_cfg = {
 	.maps[RTL_IMR_VIDOK] = IMR_VIDOK,
 	.maps[RTL_IMR_VODOK] = IMR_VODOK,
 	.maps[RTL_IMR_ROK] = IMR_ROK,
-	.maps[RTL_IBSS_INT_MASKS] = (IMR_BCNINT | IMR_TBDOK | IMR_TBDER),
+	.maps[RTL_IBSS_INT_MASKS] = ( IMR_BCNINT | IMR_TBDOK | IMR_TBDER ),
 
 	.maps[RTL_RC_CCK_RATE1M] = DESC92_RATE1M,
 	.maps[RTL_RC_CCK_RATE2M] = DESC92_RATE2M,
@@ -280,116 +287,116 @@ static struct usb_device_id rtl8192c_usb_ids[] = {
 
 	/*=== Realtek demoboard ===*/
 	/* Default ID */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8191, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8191, rtl92cu_hal_cfg )},
 
 	/****** 8188CU ********/
 	/* RTL8188CTV */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x018a, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x018a, rtl92cu_hal_cfg )},
 	/* 8188CE-VAU USB minCard */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8170, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8170, rtl92cu_hal_cfg )},
 	/* 8188cu 1*1 dongle */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8176, rtl92cu_hal_cfg)},
-	/* 8188cu 1*1 dongle, (b/g mode only) */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8177, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8176, rtl92cu_hal_cfg )},
+	/* 8188cu 1*1 dongle, ( b/g mode only ) */
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8177, rtl92cu_hal_cfg )},
 	/* 8188cu Slim Solo */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817a, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817a, rtl92cu_hal_cfg )},
 	/* 8188cu Slim Combo */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817b, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817b, rtl92cu_hal_cfg )},
 	/* 8188RU High-power USB Dongle */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817d, rtl92cu_hal_cfg)},
-	/* 8188CE-VAU USB minCard (b/g mode only) */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817e, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817d, rtl92cu_hal_cfg )},
+	/* 8188CE-VAU USB minCard ( b/g mode only ) */
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817e, rtl92cu_hal_cfg )},
 	/* 8188RU in Alfa AWUS036NHR */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817f, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817f, rtl92cu_hal_cfg )},
 	/* RTL8188CUS-VL */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x818a, rtl92cu_hal_cfg)},
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x819a, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x818a, rtl92cu_hal_cfg )},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x819a, rtl92cu_hal_cfg )},
 	/* 8188 Combo for BC4 */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8754, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8754, rtl92cu_hal_cfg )},
 
 	/****** 8192CU ********/
 	/* 8192cu 2*2 */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8178, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x8178, rtl92cu_hal_cfg )},
 	/* 8192CE-VAU USB minCard */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817c, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x817c, rtl92cu_hal_cfg )},
 
 	/*=== Customer ID ===*/
 	/****** 8188CU ********/
-	{RTL_USB_DEVICE(0x050d, 0x1102, rtl92cu_hal_cfg)}, /*Belkin - Edimax*/
-	{RTL_USB_DEVICE(0x050d, 0x11f2, rtl92cu_hal_cfg)}, /*Belkin - ISY*/
-	{RTL_USB_DEVICE(0x06f8, 0xe033, rtl92cu_hal_cfg)}, /*Hercules - Edimax*/
-	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
-	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
-	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
-	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&C*/
-	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
-	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
-	{RTL_USB_DEVICE(0x0df6, 0x0070, rtl92cu_hal_cfg)}, /*Sitecom - 150N */
-	{RTL_USB_DEVICE(0x0df6, 0x0077, rtl92cu_hal_cfg)}, /*Sitecom-WLA2100V2*/
-	{RTL_USB_DEVICE(0x0eb0, 0x9071, rtl92cu_hal_cfg)}, /*NO Brand - Etop*/
-	{RTL_USB_DEVICE(0x4856, 0x0091, rtl92cu_hal_cfg)}, /*NetweeN - Feixun*/
+	{RTL_USB_DEVICE( 0x050d, 0x1102, rtl92cu_hal_cfg )}, /*Belkin - Edimax*/
+	{RTL_USB_DEVICE( 0x050d, 0x11f2, rtl92cu_hal_cfg )}, /*Belkin - ISY*/
+	{RTL_USB_DEVICE( 0x06f8, 0xe033, rtl92cu_hal_cfg )}, /*Hercules - Edimax*/
+	{RTL_USB_DEVICE( 0x07b8, 0x8188, rtl92cu_hal_cfg )}, /*Abocom - Abocom*/
+	{RTL_USB_DEVICE( 0x07b8, 0x8189, rtl92cu_hal_cfg )}, /*Funai - Abocom*/
+	{RTL_USB_DEVICE( 0x0846, 0x9041, rtl92cu_hal_cfg )}, /*NetGear WNA1000M*/
+	{RTL_USB_DEVICE( 0x0bda, 0x5088, rtl92cu_hal_cfg )}, /*Thinkware-CC&C*/
+	{RTL_USB_DEVICE( 0x0df6, 0x0052, rtl92cu_hal_cfg )}, /*Sitecom - Edimax*/
+	{RTL_USB_DEVICE( 0x0df6, 0x005c, rtl92cu_hal_cfg )}, /*Sitecom - Edimax*/
+	{RTL_USB_DEVICE( 0x0df6, 0x0070, rtl92cu_hal_cfg )}, /*Sitecom - 150N */
+	{RTL_USB_DEVICE( 0x0df6, 0x0077, rtl92cu_hal_cfg )}, /*Sitecom-WLA2100V2*/
+	{RTL_USB_DEVICE( 0x0eb0, 0x9071, rtl92cu_hal_cfg )}, /*NO Brand - Etop*/
+	{RTL_USB_DEVICE( 0x4856, 0x0091, rtl92cu_hal_cfg )}, /*NetweeN - Feixun*/
 	/* HP - Lite-On ,8188CUS Slim Combo */
-	{RTL_USB_DEVICE(0x103c, 0x1629, rtl92cu_hal_cfg)},
-	{RTL_USB_DEVICE(0x13d3, 0x3357, rtl92cu_hal_cfg)}, /* AzureWave */
-	{RTL_USB_DEVICE(0x2001, 0x3308, rtl92cu_hal_cfg)}, /*D-Link - Alpha*/
-	{RTL_USB_DEVICE(0x2019, 0x4902, rtl92cu_hal_cfg)}, /*Planex - Etop*/
-	{RTL_USB_DEVICE(0x2019, 0xab2a, rtl92cu_hal_cfg)}, /*Planex - Abocom*/
+	{RTL_USB_DEVICE( 0x103c, 0x1629, rtl92cu_hal_cfg )},
+	{RTL_USB_DEVICE( 0x13d3, 0x3357, rtl92cu_hal_cfg )}, /* AzureWave */
+	{RTL_USB_DEVICE( 0x2001, 0x3308, rtl92cu_hal_cfg )}, /*D-Link - Alpha*/
+	{RTL_USB_DEVICE( 0x2019, 0x4902, rtl92cu_hal_cfg )}, /*Planex - Etop*/
+	{RTL_USB_DEVICE( 0x2019, 0xab2a, rtl92cu_hal_cfg )}, /*Planex - Abocom*/
 	/*SW-WF02-AD15 -Abocom*/
-	{RTL_USB_DEVICE(0x2019, 0xab2e, rtl92cu_hal_cfg)},
-	{RTL_USB_DEVICE(0x2019, 0xed17, rtl92cu_hal_cfg)}, /*PCI - Edimax*/
-	{RTL_USB_DEVICE(0x20f4, 0x648b, rtl92cu_hal_cfg)}, /*TRENDnet - Cameo*/
-	{RTL_USB_DEVICE(0x7392, 0x7811, rtl92cu_hal_cfg)}, /*Edimax - Edimax*/
-	{RTL_USB_DEVICE(0x13d3, 0x3358, rtl92cu_hal_cfg)}, /*Azwave 8188CE-VAU*/
-	/* Russian customer -Azwave (8188CE-VAU  b/g mode only) */
-	{RTL_USB_DEVICE(0x13d3, 0x3359, rtl92cu_hal_cfg)},
-	{RTL_USB_DEVICE(0x4855, 0x0090, rtl92cu_hal_cfg)}, /* Feixun */
-	{RTL_USB_DEVICE(0x4855, 0x0091, rtl92cu_hal_cfg)}, /* NetweeN-Feixun */
-	{RTL_USB_DEVICE(0x9846, 0x9041, rtl92cu_hal_cfg)}, /* Netgear Cameo */
+	{RTL_USB_DEVICE( 0x2019, 0xab2e, rtl92cu_hal_cfg )},
+	{RTL_USB_DEVICE( 0x2019, 0xed17, rtl92cu_hal_cfg )}, /*PCI - Edimax*/
+	{RTL_USB_DEVICE( 0x20f4, 0x648b, rtl92cu_hal_cfg )}, /*TRENDnet - Cameo*/
+	{RTL_USB_DEVICE( 0x7392, 0x7811, rtl92cu_hal_cfg )}, /*Edimax - Edimax*/
+	{RTL_USB_DEVICE( 0x13d3, 0x3358, rtl92cu_hal_cfg )}, /*Azwave 8188CE-VAU*/
+	/* Russian customer -Azwave ( 8188CE-VAU  b/g mode only ) */
+	{RTL_USB_DEVICE( 0x13d3, 0x3359, rtl92cu_hal_cfg )},
+	{RTL_USB_DEVICE( 0x4855, 0x0090, rtl92cu_hal_cfg )}, /* Feixun */
+	{RTL_USB_DEVICE( 0x4855, 0x0091, rtl92cu_hal_cfg )}, /* NetweeN-Feixun */
+	{RTL_USB_DEVICE( 0x9846, 0x9041, rtl92cu_hal_cfg )}, /* Netgear Cameo */
 
 	/****** 8188 RU ********/
 	/* Netcore */
-	{RTL_USB_DEVICE(USB_VENDER_ID_REALTEK, 0x317f, rtl92cu_hal_cfg)},
+	{RTL_USB_DEVICE( USB_VENDER_ID_REALTEK, 0x317f, rtl92cu_hal_cfg )},
 
 	/****** 8188CUS Slim Solo********/
-	{RTL_USB_DEVICE(0x04f2, 0xaff7, rtl92cu_hal_cfg)}, /*Xavi*/
-	{RTL_USB_DEVICE(0x04f2, 0xaff9, rtl92cu_hal_cfg)}, /*Xavi*/
-	{RTL_USB_DEVICE(0x04f2, 0xaffa, rtl92cu_hal_cfg)}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaff7, rtl92cu_hal_cfg )}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaff9, rtl92cu_hal_cfg )}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaffa, rtl92cu_hal_cfg )}, /*Xavi*/
 
 	/****** 8188CUS Slim Combo ********/
-	{RTL_USB_DEVICE(0x04f2, 0xaff8, rtl92cu_hal_cfg)}, /*Xavi*/
-	{RTL_USB_DEVICE(0x04f2, 0xaffb, rtl92cu_hal_cfg)}, /*Xavi*/
-	{RTL_USB_DEVICE(0x04f2, 0xaffc, rtl92cu_hal_cfg)}, /*Xavi*/
-	{RTL_USB_DEVICE(0x2019, 0x1201, rtl92cu_hal_cfg)}, /*Planex-Vencer*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaff8, rtl92cu_hal_cfg )}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaffb, rtl92cu_hal_cfg )}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x04f2, 0xaffc, rtl92cu_hal_cfg )}, /*Xavi*/
+	{RTL_USB_DEVICE( 0x2019, 0x1201, rtl92cu_hal_cfg )}, /*Planex-Vencer*/
 
 	/****** 8192CU ********/
-	{RTL_USB_DEVICE(0x050d, 0x1004, rtl92cu_hal_cfg)}, /*Belcom-SurfN300*/
-	{RTL_USB_DEVICE(0x050d, 0x2102, rtl92cu_hal_cfg)}, /*Belcom-Sercomm*/
-	{RTL_USB_DEVICE(0x050d, 0x2103, rtl92cu_hal_cfg)}, /*Belcom-Edimax*/
-	{RTL_USB_DEVICE(0x0586, 0x341f, rtl92cu_hal_cfg)}, /*Zyxel -Abocom*/
-	{RTL_USB_DEVICE(0x07aa, 0x0056, rtl92cu_hal_cfg)}, /*ATKK-Gemtek*/
-	{RTL_USB_DEVICE(0x07b8, 0x8178, rtl92cu_hal_cfg)}, /*Funai -Abocom*/
-	{RTL_USB_DEVICE(0x0846, 0x9021, rtl92cu_hal_cfg)}, /*Netgear-Sercomm*/
-	{RTL_USB_DEVICE(0x0846, 0xf001, rtl92cu_hal_cfg)}, /*On Netwrks N300MA*/
-	{RTL_USB_DEVICE(0x0b05, 0x17ab, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/
-	{RTL_USB_DEVICE(0x0bda, 0x8186, rtl92cu_hal_cfg)}, /*Realtek 92CE-VAU*/
-	{RTL_USB_DEVICE(0x0df6, 0x0061, rtl92cu_hal_cfg)}, /*Sitecom-Edimax*/
-	{RTL_USB_DEVICE(0x0e66, 0x0019, rtl92cu_hal_cfg)}, /*Hawking-Edimax*/
-	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
-	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
-	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
-	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
-	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
-	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
-	{RTL_USB_DEVICE(0x7392, 0x7822, rtl92cu_hal_cfg)}, /*Edimax -Edimax*/
+	{RTL_USB_DEVICE( 0x050d, 0x1004, rtl92cu_hal_cfg )}, /*Belcom-SurfN300*/
+	{RTL_USB_DEVICE( 0x050d, 0x2102, rtl92cu_hal_cfg )}, /*Belcom-Sercomm*/
+	{RTL_USB_DEVICE( 0x050d, 0x2103, rtl92cu_hal_cfg )}, /*Belcom-Edimax*/
+	{RTL_USB_DEVICE( 0x0586, 0x341f, rtl92cu_hal_cfg )}, /*Zyxel -Abocom*/
+	{RTL_USB_DEVICE( 0x07aa, 0x0056, rtl92cu_hal_cfg )}, /*ATKK-Gemtek*/
+	{RTL_USB_DEVICE( 0x07b8, 0x8178, rtl92cu_hal_cfg )}, /*Funai -Abocom*/
+	{RTL_USB_DEVICE( 0x0846, 0x9021, rtl92cu_hal_cfg )}, /*Netgear-Sercomm*/
+	{RTL_USB_DEVICE( 0x0846, 0xf001, rtl92cu_hal_cfg )}, /*On Netwrks N300MA*/
+	{RTL_USB_DEVICE( 0x0b05, 0x17ab, rtl92cu_hal_cfg )}, /*ASUS-Edimax*/
+	{RTL_USB_DEVICE( 0x0bda, 0x8186, rtl92cu_hal_cfg )}, /*Realtek 92CE-VAU*/
+	{RTL_USB_DEVICE( 0x0df6, 0x0061, rtl92cu_hal_cfg )}, /*Sitecom-Edimax*/
+	{RTL_USB_DEVICE( 0x0e66, 0x0019, rtl92cu_hal_cfg )}, /*Hawking-Edimax*/
+	{RTL_USB_DEVICE( 0x2001, 0x3307, rtl92cu_hal_cfg )}, /*D-Link-Cameo*/
+	{RTL_USB_DEVICE( 0x2001, 0x3309, rtl92cu_hal_cfg )}, /*D-Link-Alpha*/
+	{RTL_USB_DEVICE( 0x2001, 0x330a, rtl92cu_hal_cfg )}, /*D-Link-Alpha*/
+	{RTL_USB_DEVICE( 0x2019, 0xab2b, rtl92cu_hal_cfg )}, /*Planex -Abocom*/
+	{RTL_USB_DEVICE( 0x20f4, 0x624d, rtl92cu_hal_cfg )}, /*TRENDNet*/
+	{RTL_USB_DEVICE( 0x2357, 0x0100, rtl92cu_hal_cfg )}, /*TP-Link WN8200ND*/
+	{RTL_USB_DEVICE( 0x7392, 0x7822, rtl92cu_hal_cfg )}, /*Edimax -Edimax*/
 	{}
 };
 
-MODULE_DEVICE_TABLE(usb, rtl8192c_usb_ids);
+MODULE_DEVICE_TABLE( usb, rtl8192c_usb_ids );
 
-static int rtl8192cu_probe(struct usb_interface *intf,
-			   const struct usb_device_id *id)
+static int rtl8192cu_probe( struct usb_interface *intf,
+			   const struct usb_device_id *id )
 {
-	return rtl_usb_probe(intf, id, &rtl92cu_hal_cfg);
+	return rtl_usb_probe( intf, id, &rtl92cu_hal_cfg );
 }
 
 static struct usb_driver rtl8192cu_driver = {
@@ -406,4 +413,4 @@ static struct usb_driver rtl8192cu_driver = {
 	.disable_hub_initiated_lpm = 1,
 };
 
-module_usb_driver(rtl8192cu_driver);
+module_usb_driver( rtl8192cu_driver );
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.h b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.h
index a1310ab..d68a771 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -32,22 +39,22 @@
 
 #define EFUSE_MAX_SECTION	16
 
-void rtl92cu_phy_rf6052_set_cck_txpower(struct ieee80211_hw *hw,
-					u8 *powerlevel);
-void rtl92cu_phy_rf6052_set_ofdm_txpower(struct ieee80211_hw *hw,
-					u8 *ppowerlevel, u8 channel);
-bool _rtl92cu_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,
-					    u8 configtype);
-bool _rtl92cu_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,
-						    u8 configtype);
-void _rtl92cu_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t);
-void rtl92cu_phy_set_rf_reg(struct ieee80211_hw *hw,
+void rtl92cu_phy_rf6052_set_cck_txpower( struct ieee80211_hw *hw,
+					u8 *powerlevel );
+void rtl92cu_phy_rf6052_set_ofdm_txpower( struct ieee80211_hw *hw,
+					u8 *ppowerlevel, u8 channel );
+bool _rtl92cu_phy_config_bb_with_headerfile( struct ieee80211_hw *hw,
+					    u8 configtype );
+bool _rtl92cu_phy_config_bb_with_pgheaderfile( struct ieee80211_hw *hw,
+						    u8 configtype );
+void _rtl92cu_phy_lc_calibrate( struct ieee80211_hw *hw, bool is2t );
+void rtl92cu_phy_set_rf_reg( struct ieee80211_hw *hw,
 			   enum radio_path rfpath,
-			   u32 regaddr, u32 bitmask, u32 data);
-bool rtl92cu_phy_set_rf_power_state(struct ieee80211_hw *hw,
-				   enum rf_pwrstate rfpwr_state);
-u32 rtl92cu_phy_query_rf_reg(struct ieee80211_hw *hw,
-			    enum radio_path rfpath, u32 regaddr, u32 bitmask);
-void rtl92cu_phy_set_bw_mode_callback(struct ieee80211_hw *hw);
+			   u32 regaddr, u32 bitmask, u32 data );
+bool rtl92cu_phy_set_rf_power_state( struct ieee80211_hw *hw,
+				   enum rf_pwrstate rfpwr_state );
+u32 rtl92cu_phy_query_rf_reg( struct ieee80211_hw *hw,
+			    enum radio_path rfpath, u32 regaddr, u32 bitmask );
+void rtl92cu_phy_set_bw_mode_callback( struct ieee80211_hw *hw );
 
 #endif
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/table.c b/drivers/net/wireless/rtlwifi/rtl8192cu/table.c
index 7903c15..22065df 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/table.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/table.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation.
+ * Copyright( c ) 2009-2012  Realtek Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/table.h b/drivers/net/wireless/rtlwifi/rtl8192cu/table.h
index 4b020e9..82b868d 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/table.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/table.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/trx.c b/drivers/net/wireless/rtlwifi/rtl8192cu/trx.c
index f383d5f..19efbc7 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/trx.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/trx.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -40,19 +47,19 @@
 #include "trx.h"
 #include "../rtl8192c/fw_common.h"
 
-static int _ConfigVerTOutEP(struct ieee80211_hw *hw)
+static int _ConfigVerTOutEP( struct ieee80211_hw *hw )
 {
 	u8 ep_cfg, txqsele;
 	u8 ep_nums = 0;
 
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(usb_priv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb_priv *usb_priv = rtl_usbpriv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( usb_priv );
 
 	rtlusb->out_queue_sel = 0;
-	ep_cfg = rtl_read_byte(rtlpriv, REG_TEST_SIE_OPTIONAL);
-	ep_cfg = (ep_cfg & USB_TEST_EP_MASK) >> USB_TEST_EP_SHIFT;
-	switch (ep_cfg)	{
+	ep_cfg = rtl_read_byte( rtlpriv, REG_TEST_SIE_OPTIONAL );
+	ep_cfg = ( ep_cfg & USB_TEST_EP_MASK ) >> USB_TEST_EP_SHIFT;
+	switch ( ep_cfg )	{
 	case 0:		/* 2 bulk OUT, 1 bulk IN */
 	case 3:
 		rtlusb->out_queue_sel  = TX_SELE_HQ | TX_SELE_LQ;
@@ -60,56 +67,56 @@ static int _ConfigVerTOutEP(struct ieee80211_hw *hw)
 		break;
 	case 1:	/* 1 bulk IN/OUT => map all endpoint to Low queue */
 	case 2:	/* 1 bulk IN, 1 bulk OUT => map all endpoint to High queue */
-		txqsele = rtl_read_byte(rtlpriv, REG_TEST_USB_TXQS);
-		if (txqsele & 0x0F) /* /map all endpoint to High queue */
+		txqsele = rtl_read_byte( rtlpriv, REG_TEST_USB_TXQS );
+		if ( txqsele & 0x0F ) /* /map all endpoint to High queue */
 			rtlusb->out_queue_sel =  TX_SELE_HQ;
-		else if (txqsele&0xF0) /* map all endpoint to Low queue */
+		else if ( txqsele&0xF0 ) /* map all endpoint to Low queue */
 			rtlusb->out_queue_sel =  TX_SELE_LQ;
 		ep_nums = 1;
 		break;
 	default:
 		break;
 	}
-	return (rtlusb->out_ep_nums == ep_nums) ? 0 : -EINVAL;
+	return ( rtlusb->out_ep_nums == ep_nums ) ? 0 : -EINVAL;
 }
 
-static int _ConfigVerNOutEP(struct ieee80211_hw *hw)
+static int _ConfigVerNOutEP( struct ieee80211_hw *hw )
 {
 	u8 ep_cfg;
 	u8 ep_nums = 0;
 
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(usb_priv);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_usb_priv *usb_priv = rtl_usbpriv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( usb_priv );
 
 	rtlusb->out_queue_sel = 0;
 	/* Normal and High queue */
-	ep_cfg =  rtl_read_byte(rtlpriv, (REG_NORMAL_SIE_EP + 1));
-	if (ep_cfg & USB_NORMAL_SIE_EP_MASK) {
+	ep_cfg =  rtl_read_byte( rtlpriv, ( REG_NORMAL_SIE_EP + 1 ) );
+	if ( ep_cfg & USB_NORMAL_SIE_EP_MASK ) {
 		rtlusb->out_queue_sel |= TX_SELE_HQ;
 		ep_nums++;
 	}
-	if ((ep_cfg >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK) {
+	if ( ( ep_cfg >> USB_NORMAL_SIE_EP_SHIFT ) & USB_NORMAL_SIE_EP_MASK ) {
 		rtlusb->out_queue_sel |= TX_SELE_NQ;
 		ep_nums++;
 	}
 	/* Low queue */
-	ep_cfg =  rtl_read_byte(rtlpriv, (REG_NORMAL_SIE_EP + 2));
-	if (ep_cfg & USB_NORMAL_SIE_EP_MASK) {
+	ep_cfg =  rtl_read_byte( rtlpriv, ( REG_NORMAL_SIE_EP + 2 ) );
+	if ( ep_cfg & USB_NORMAL_SIE_EP_MASK ) {
 		rtlusb->out_queue_sel |= TX_SELE_LQ;
 		ep_nums++;
 	}
-	return (rtlusb->out_ep_nums == ep_nums) ? 0 : -EINVAL;
+	return ( rtlusb->out_ep_nums == ep_nums ) ? 0 : -EINVAL;
 }
 
-static void _TwoOutEpMapping(struct ieee80211_hw *hw, bool bIsChipB,
-			     bool  bwificfg, struct rtl_ep_map *ep_map)
+static void _TwoOutEpMapping( struct ieee80211_hw *hw, bool bIsChipB,
+			     bool  bwificfg, struct rtl_ep_map *ep_map )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (bwificfg) { /* for WMM */
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "USB Chip-B & WMM Setting.....\n");
+	if ( bwificfg ) { /* for WMM */
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "USB Chip-B & WMM Setting.....\n" );
 		ep_map->ep_mapping[RTL_TXQ_BE]	= 2;
 		ep_map->ep_mapping[RTL_TXQ_BK]	= 3;
 		ep_map->ep_mapping[RTL_TXQ_VI]	= 3;
@@ -118,8 +125,8 @@ static void _TwoOutEpMapping(struct ieee80211_hw *hw, bool bIsChipB,
 		ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
 		ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
 	} else { /* typical setting */
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "USB typical Setting.....\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "USB typical Setting.....\n" );
 		ep_map->ep_mapping[RTL_TXQ_BE]	= 3;
 		ep_map->ep_mapping[RTL_TXQ_BK]	= 3;
 		ep_map->ep_mapping[RTL_TXQ_VI]	= 2;
@@ -130,13 +137,13 @@ static void _TwoOutEpMapping(struct ieee80211_hw *hw, bool bIsChipB,
 	}
 }
 
-static void _ThreeOutEpMapping(struct ieee80211_hw *hw, bool  bwificfg,
-			       struct rtl_ep_map *ep_map)
+static void _ThreeOutEpMapping( struct ieee80211_hw *hw, bool  bwificfg,
+			       struct rtl_ep_map *ep_map )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	if (bwificfg) { /* for WMM */
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "USB 3EP Setting for WMM.....\n");
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	if ( bwificfg ) { /* for WMM */
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "USB 3EP Setting for WMM.....\n" );
 		ep_map->ep_mapping[RTL_TXQ_BE]	= 5;
 		ep_map->ep_mapping[RTL_TXQ_BK]	= 3;
 		ep_map->ep_mapping[RTL_TXQ_VI]	= 3;
@@ -145,8 +152,8 @@ static void _ThreeOutEpMapping(struct ieee80211_hw *hw, bool  bwificfg,
 		ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
 		ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
 	} else { /* typical setting */
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "USB 3EP Setting for typical.....\n");
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "USB 3EP Setting for typical.....\n" );
 		ep_map->ep_mapping[RTL_TXQ_BE]	= 5;
 		ep_map->ep_mapping[RTL_TXQ_BK]	= 5;
 		ep_map->ep_mapping[RTL_TXQ_VI]	= 3;
@@ -157,7 +164,7 @@ static void _ThreeOutEpMapping(struct ieee80211_hw *hw, bool  bwificfg,
 	}
 }
 
-static void _OneOutEpMapping(struct ieee80211_hw *hw, struct rtl_ep_map *ep_map)
+static void _OneOutEpMapping( struct ieee80211_hw *hw, struct rtl_ep_map *ep_map )
 {
 	ep_map->ep_mapping[RTL_TXQ_BE]	= 2;
 	ep_map->ep_mapping[RTL_TXQ_BK]	= 2;
@@ -167,30 +174,30 @@ static void _OneOutEpMapping(struct ieee80211_hw *hw, struct rtl_ep_map *ep_map)
 	ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
 	ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
 }
-static int _out_ep_mapping(struct ieee80211_hw *hw)
+static int _out_ep_mapping( struct ieee80211_hw *hw )
 {
 	int err = 0;
 	bool bIsChipN, bwificfg = false;
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);
-	struct rtl_usb *rtlusb = rtl_usbdev(usb_priv);
-	struct rtl_ep_map *ep_map = &(rtlusb->ep_map);
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
+	struct rtl_usb_priv *usb_priv = rtl_usbpriv( hw );
+	struct rtl_usb *rtlusb = rtl_usbdev( usb_priv );
+	struct rtl_ep_map *ep_map = &( rtlusb->ep_map );
 
-	bIsChipN = IS_NORMAL_CHIP(rtlhal->version);
-	switch (rtlusb->out_ep_nums) {
+	bIsChipN = IS_NORMAL_CHIP( rtlhal->version );
+	switch ( rtlusb->out_ep_nums ) {
 	case 2:
-		_TwoOutEpMapping(hw, bIsChipN, bwificfg, ep_map);
+		_TwoOutEpMapping( hw, bIsChipN, bwificfg, ep_map );
 		break;
 	case 3:
 		/* Test chip doesn't support three out EPs. */
-		if (!bIsChipN) {
+		if ( !bIsChipN ) {
 			err  =  -EINVAL;
 			goto err_out;
 		}
-		_ThreeOutEpMapping(hw, bIsChipN, ep_map);
+		_ThreeOutEpMapping( hw, bIsChipN, ep_map );
 		break;
 	case 1:
-		_OneOutEpMapping(hw, ep_map);
+		_OneOutEpMapping( hw, ep_map );
 		break;
 	default:
 		err  =  -EINVAL;
@@ -201,36 +208,36 @@ err_out:
 
 }
 /* endpoint mapping */
-int  rtl8192cu_endpoint_mapping(struct ieee80211_hw *hw)
+int  rtl8192cu_endpoint_mapping( struct ieee80211_hw *hw )
 {
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_hal *rtlhal = rtl_hal( rtl_priv( hw ) );
 	int error = 0;
-	if (likely(IS_NORMAL_CHIP(rtlhal->version)))
-		error = _ConfigVerNOutEP(hw);
+	if ( likely( IS_NORMAL_CHIP( rtlhal->version ) ) )
+		error = _ConfigVerNOutEP( hw );
 	else
-		error = _ConfigVerTOutEP(hw);
-	if (error)
+		error = _ConfigVerTOutEP( hw );
+	if ( error )
 		goto err_out;
-	error = _out_ep_mapping(hw);
-	if (error)
+	error = _out_ep_mapping( hw );
+	if ( error )
 		goto err_out;
 err_out:
 	return error;
 }
 
-u16 rtl8192cu_mq_to_hwq(__le16 fc, u16 mac80211_queue_index)
+u16 rtl8192cu_mq_to_hwq( __le16 fc, u16 mac80211_queue_index )
 {
 	u16 hw_queue_index;
 
-	if (unlikely(ieee80211_is_beacon(fc))) {
+	if ( unlikely( ieee80211_is_beacon( fc ) ) ) {
 		hw_queue_index = RTL_TXQ_BCN;
 		goto out;
 	}
-	if (ieee80211_is_mgmt(fc)) {
+	if ( ieee80211_is_mgmt( fc ) ) {
 		hw_queue_index = RTL_TXQ_MGT;
 		goto out;
 	}
-	switch (mac80211_queue_index) {
+	switch ( mac80211_queue_index ) {
 	case 0:
 		hw_queue_index = RTL_TXQ_VO;
 		break;
@@ -245,49 +252,49 @@ u16 rtl8192cu_mq_to_hwq(__le16 fc, u16 mac80211_queue_index)
 		break;
 	default:
 		hw_queue_index = RTL_TXQ_BE;
-		RT_ASSERT(false, "QSLT_BE queue, skb_queue:%d\n",
-			  mac80211_queue_index);
+		RT_ASSERT( false, "QSLT_BE queue, skb_queue:%d\n",
+			  mac80211_queue_index );
 		break;
 	}
 out:
 	return hw_queue_index;
 }
 
-static enum rtl_desc_qsel _rtl8192cu_mq_to_descq(struct ieee80211_hw *hw,
-					 __le16 fc, u16 mac80211_queue_index)
+static enum rtl_desc_qsel _rtl8192cu_mq_to_descq( struct ieee80211_hw *hw,
+					 __le16 fc, u16 mac80211_queue_index )
 {
 	enum rtl_desc_qsel qsel;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 
-	if (unlikely(ieee80211_is_beacon(fc))) {
+	if ( unlikely( ieee80211_is_beacon( fc ) ) ) {
 		qsel = QSLT_BEACON;
 		goto out;
 	}
-	if (ieee80211_is_mgmt(fc)) {
+	if ( ieee80211_is_mgmt( fc ) ) {
 		qsel = QSLT_MGNT;
 		goto out;
 	}
-	switch (mac80211_queue_index) {
+	switch ( mac80211_queue_index ) {
 	case 0:	/* VO */
 		qsel = QSLT_VO;
-		RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG,
-			 "VO queue, set qsel = 0x%x\n", QSLT_VO);
+		RT_TRACE( rtlpriv, COMP_USB, DBG_DMESG,
+			 "VO queue, set qsel = 0x%x\n", QSLT_VO );
 		break;
 	case 1:	/* VI */
 		qsel = QSLT_VI;
-		RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG,
-			 "VI queue, set qsel = 0x%x\n", QSLT_VI);
+		RT_TRACE( rtlpriv, COMP_USB, DBG_DMESG,
+			 "VI queue, set qsel = 0x%x\n", QSLT_VI );
 		break;
 	case 3:	/* BK */
 		qsel = QSLT_BK;
-		RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG,
-			 "BK queue, set qsel = 0x%x\n", QSLT_BK);
+		RT_TRACE( rtlpriv, COMP_USB, DBG_DMESG,
+			 "BK queue, set qsel = 0x%x\n", QSLT_BK );
 		break;
 	case 2:	/* BE */
 	default:
 		qsel = QSLT_BE;
-		RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG,
-			 "BE queue, set qsel = 0x%x\n", QSLT_BE);
+		RT_TRACE( rtlpriv, COMP_USB, DBG_DMESG,
+			 "BE queue, set qsel = 0x%x\n", QSLT_BE );
 		break;
 	}
 out:
@@ -301,53 +308,53 @@ out:
  *	Rx handler
  *
  *---------------------------------------------------------------------- */
-bool rtl92cu_rx_query_desc(struct ieee80211_hw *hw,
+bool rtl92cu_rx_query_desc( struct ieee80211_hw *hw,
 			   struct rtl_stats *stats,
 			   struct ieee80211_rx_status *rx_status,
-			   u8 *pdesc, struct sk_buff *skb)
+			   u8 *pdesc, struct sk_buff *skb )
 {
 	struct rx_fwinfo_92c *p_drvinfo;
-	struct rx_desc_92c *p_desc = (struct rx_desc_92c *)pdesc;
-	u32 phystatus = GET_RX_DESC_PHY_STATUS(pdesc);
+	struct rx_desc_92c *p_desc = ( struct rx_desc_92c * )pdesc;
+	u32 phystatus = GET_RX_DESC_PHY_STATUS( pdesc );
 
-	stats->length = (u16) GET_RX_DESC_PKT_LEN(pdesc);
-	stats->rx_drvinfo_size = (u8)GET_RX_DESC_DRVINFO_SIZE(pdesc) *
+	stats->length = ( u16 ) GET_RX_DESC_PKT_LEN( pdesc );
+	stats->rx_drvinfo_size = ( u8 )GET_RX_DESC_DRVINFO_SIZE( pdesc ) *
 				 RX_DRV_INFO_SIZE_UNIT;
-	stats->rx_bufshift = (u8) (GET_RX_DESC_SHIFT(pdesc) & 0x03);
-	stats->icv = (u16) GET_RX_DESC_ICV(pdesc);
-	stats->crc = (u16) GET_RX_DESC_CRC32(pdesc);
-	stats->hwerror = (stats->crc | stats->icv);
-	stats->decrypted = !GET_RX_DESC_SWDEC(pdesc);
-	stats->rate = (u8) GET_RX_DESC_RX_MCS(pdesc);
-	stats->shortpreamble = (u16) GET_RX_DESC_SPLCP(pdesc);
-	stats->isampdu = (bool) (GET_RX_DESC_PAGGR(pdesc) == 1);
-	stats->isampdu = (bool) ((GET_RX_DESC_PAGGR(pdesc) == 1)
-				   && (GET_RX_DESC_FAGGR(pdesc) == 1));
-	stats->timestamp_low = GET_RX_DESC_TSFL(pdesc);
-	stats->rx_is40Mhzpacket = (bool) GET_RX_DESC_BW(pdesc);
+	stats->rx_bufshift = ( u8 ) ( GET_RX_DESC_SHIFT( pdesc ) & 0x03 );
+	stats->icv = ( u16 ) GET_RX_DESC_ICV( pdesc );
+	stats->crc = ( u16 ) GET_RX_DESC_CRC32( pdesc );
+	stats->hwerror = ( stats->crc | stats->icv );
+	stats->decrypted = !GET_RX_DESC_SWDEC( pdesc );
+	stats->rate = ( u8 ) GET_RX_DESC_RX_MCS( pdesc );
+	stats->shortpreamble = ( u16 ) GET_RX_DESC_SPLCP( pdesc );
+	stats->isampdu = ( bool ) ( GET_RX_DESC_PAGGR( pdesc ) == 1 );
+	stats->isampdu = ( bool ) ( ( GET_RX_DESC_PAGGR( pdesc ) == 1 )
+				   && ( GET_RX_DESC_FAGGR( pdesc ) == 1 ) );
+	stats->timestamp_low = GET_RX_DESC_TSFL( pdesc );
+	stats->rx_is40Mhzpacket = ( bool ) GET_RX_DESC_BW( pdesc );
 	rx_status->freq = hw->conf.chandef.chan->center_freq;
 	rx_status->band = hw->conf.chandef.chan->band;
-	if (GET_RX_DESC_CRC32(pdesc))
+	if ( GET_RX_DESC_CRC32( pdesc ) )
 		rx_status->flag |= RX_FLAG_FAILED_FCS_CRC;
-	if (!GET_RX_DESC_SWDEC(pdesc))
+	if ( !GET_RX_DESC_SWDEC( pdesc ) )
 		rx_status->flag |= RX_FLAG_DECRYPTED;
-	if (GET_RX_DESC_BW(pdesc))
+	if ( GET_RX_DESC_BW( pdesc ) )
 		rx_status->flag |= RX_FLAG_40MHZ;
-	if (GET_RX_DESC_RX_HT(pdesc))
+	if ( GET_RX_DESC_RX_HT( pdesc ) )
 		rx_status->flag |= RX_FLAG_HT;
 	rx_status->flag |= RX_FLAG_MACTIME_START;
-	if (stats->decrypted)
+	if ( stats->decrypted )
 		rx_status->flag |= RX_FLAG_DECRYPTED;
-	rx_status->rate_idx = rtlwifi_rate_mapping(hw,
-					(bool)GET_RX_DESC_RX_HT(pdesc),
-					(u8)GET_RX_DESC_RX_MCS(pdesc),
-					(bool)GET_RX_DESC_PAGGR(pdesc));
-	rx_status->mactime = GET_RX_DESC_TSFL(pdesc);
-	if (phystatus) {
-		p_drvinfo = (struct rx_fwinfo_92c *)(skb->data +
-						     stats->rx_bufshift);
-		rtl92c_translate_rx_signal_stuff(hw, skb, stats, p_desc,
-						 p_drvinfo);
+	rx_status->rate_idx = rtlwifi_rate_mapping( hw,
+					( bool )GET_RX_DESC_RX_HT( pdesc ),
+					( u8 )GET_RX_DESC_RX_MCS( pdesc ),
+					( bool )GET_RX_DESC_PAGGR( pdesc ) );
+	rx_status->mactime = GET_RX_DESC_TSFL( pdesc );
+	if ( phystatus ) {
+		p_drvinfo = ( struct rx_fwinfo_92c * )( skb->data +
+						     stats->rx_bufshift );
+		rtl92c_translate_rx_signal_stuff( hw, skb, stats, p_desc,
+						 p_drvinfo );
 	}
 	/*rx_status->qual = stats->signal; */
 	rx_status->signal = stats->recvsignalpower + 10;
@@ -356,12 +363,12 @@ bool rtl92cu_rx_query_desc(struct ieee80211_hw *hw,
 
 #define RTL_RX_DRV_INFO_UNIT		8
 
-static void _rtl_rx_process(struct ieee80211_hw *hw, struct sk_buff *skb)
+static void _rtl_rx_process( struct ieee80211_hw *hw, struct sk_buff *skb )
 {
 	struct ieee80211_rx_status *rx_status =
-		 (struct ieee80211_rx_status *)IEEE80211_SKB_RXCB(skb);
+		 ( struct ieee80211_rx_status * )IEEE80211_SKB_RXCB( skb );
 	u32 skb_len, pkt_len, drvinfo_len;
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u8 *rxdesc;
 	struct rtl_stats stats = {
 		.signal = 0,
@@ -372,80 +379,80 @@ static void _rtl_rx_process(struct ieee80211_hw *hw, struct sk_buff *skb)
 	__le16 fc;
 	struct ieee80211_hdr *hdr;
 
-	memset(rx_status, 0, sizeof(*rx_status));
+	memset( rx_status, 0, sizeof( *rx_status ) );
 	rxdesc	= skb->data;
 	skb_len	= skb->len;
-	drvinfo_len = (GET_RX_DESC_DRVINFO_SIZE(rxdesc) * RTL_RX_DRV_INFO_UNIT);
-	pkt_len		= GET_RX_DESC_PKT_LEN(rxdesc);
+	drvinfo_len = ( GET_RX_DESC_DRVINFO_SIZE( rxdesc ) * RTL_RX_DRV_INFO_UNIT );
+	pkt_len		= GET_RX_DESC_PKT_LEN( rxdesc );
 	/* TODO: Error recovery. drop this skb or something. */
-	WARN_ON(skb_len < (pkt_len + RTL_RX_DESC_SIZE + drvinfo_len));
-	stats.length = (u16) GET_RX_DESC_PKT_LEN(rxdesc);
-	stats.rx_drvinfo_size = (u8)GET_RX_DESC_DRVINFO_SIZE(rxdesc) *
+	WARN_ON( skb_len < ( pkt_len + RTL_RX_DESC_SIZE + drvinfo_len ) );
+	stats.length = ( u16 ) GET_RX_DESC_PKT_LEN( rxdesc );
+	stats.rx_drvinfo_size = ( u8 )GET_RX_DESC_DRVINFO_SIZE( rxdesc ) *
 				RX_DRV_INFO_SIZE_UNIT;
-	stats.rx_bufshift = (u8) (GET_RX_DESC_SHIFT(rxdesc) & 0x03);
-	stats.icv = (u16) GET_RX_DESC_ICV(rxdesc);
-	stats.crc = (u16) GET_RX_DESC_CRC32(rxdesc);
-	stats.hwerror = (stats.crc | stats.icv);
-	stats.decrypted = !GET_RX_DESC_SWDEC(rxdesc);
-	stats.rate = (u8) GET_RX_DESC_RX_MCS(rxdesc);
-	stats.shortpreamble = (u16) GET_RX_DESC_SPLCP(rxdesc);
-	stats.isampdu = (bool) ((GET_RX_DESC_PAGGR(rxdesc) == 1)
-				   && (GET_RX_DESC_FAGGR(rxdesc) == 1));
-	stats.timestamp_low = GET_RX_DESC_TSFL(rxdesc);
-	stats.rx_is40Mhzpacket = (bool) GET_RX_DESC_BW(rxdesc);
+	stats.rx_bufshift = ( u8 ) ( GET_RX_DESC_SHIFT( rxdesc ) & 0x03 );
+	stats.icv = ( u16 ) GET_RX_DESC_ICV( rxdesc );
+	stats.crc = ( u16 ) GET_RX_DESC_CRC32( rxdesc );
+	stats.hwerror = ( stats.crc | stats.icv );
+	stats.decrypted = !GET_RX_DESC_SWDEC( rxdesc );
+	stats.rate = ( u8 ) GET_RX_DESC_RX_MCS( rxdesc );
+	stats.shortpreamble = ( u16 ) GET_RX_DESC_SPLCP( rxdesc );
+	stats.isampdu = ( bool ) ( ( GET_RX_DESC_PAGGR( rxdesc ) == 1 )
+				   && ( GET_RX_DESC_FAGGR( rxdesc ) == 1 ) );
+	stats.timestamp_low = GET_RX_DESC_TSFL( rxdesc );
+	stats.rx_is40Mhzpacket = ( bool ) GET_RX_DESC_BW( rxdesc );
 	/* TODO: is center_freq changed when doing scan? */
 	/* TODO: Shall we add protection or just skip those two step? */
 	rx_status->freq = hw->conf.chandef.chan->center_freq;
 	rx_status->band = hw->conf.chandef.chan->band;
-	if (GET_RX_DESC_CRC32(rxdesc))
+	if ( GET_RX_DESC_CRC32( rxdesc ) )
 		rx_status->flag |= RX_FLAG_FAILED_FCS_CRC;
-	if (!GET_RX_DESC_SWDEC(rxdesc))
+	if ( !GET_RX_DESC_SWDEC( rxdesc ) )
 		rx_status->flag |= RX_FLAG_DECRYPTED;
-	if (GET_RX_DESC_BW(rxdesc))
+	if ( GET_RX_DESC_BW( rxdesc ) )
 		rx_status->flag |= RX_FLAG_40MHZ;
-	if (GET_RX_DESC_RX_HT(rxdesc))
+	if ( GET_RX_DESC_RX_HT( rxdesc ) )
 		rx_status->flag |= RX_FLAG_HT;
 	/* Data rate */
-	rx_status->rate_idx = rtlwifi_rate_mapping(hw,
-					(bool)GET_RX_DESC_RX_HT(rxdesc),
-					(u8)GET_RX_DESC_RX_MCS(rxdesc),
-					(bool)GET_RX_DESC_PAGGR(rxdesc));
+	rx_status->rate_idx = rtlwifi_rate_mapping( hw,
+					( bool )GET_RX_DESC_RX_HT( rxdesc ),
+					( u8 )GET_RX_DESC_RX_MCS( rxdesc ),
+					( bool )GET_RX_DESC_PAGGR( rxdesc ) );
 	/*  There is a phy status after this rx descriptor. */
-	if (GET_RX_DESC_PHY_STATUS(rxdesc)) {
-		p_drvinfo = (struct rx_fwinfo_92c *)(rxdesc + RTL_RX_DESC_SIZE);
-		rtl92c_translate_rx_signal_stuff(hw, skb, &stats,
-				 (struct rx_desc_92c *)rxdesc, p_drvinfo);
+	if ( GET_RX_DESC_PHY_STATUS( rxdesc ) ) {
+		p_drvinfo = ( struct rx_fwinfo_92c * )( rxdesc + RTL_RX_DESC_SIZE );
+		rtl92c_translate_rx_signal_stuff( hw, skb, &stats,
+				 ( struct rx_desc_92c * )rxdesc, p_drvinfo );
 	}
-	skb_pull(skb, (drvinfo_len + RTL_RX_DESC_SIZE));
-	hdr = (struct ieee80211_hdr *)(skb->data);
+	skb_pull( skb, ( drvinfo_len + RTL_RX_DESC_SIZE ) );
+	hdr = ( struct ieee80211_hdr * )( skb->data );
 	fc = hdr->frame_control;
-	bv = ieee80211_is_probe_resp(fc);
-	if (bv)
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
-			 "Got probe response frame\n");
-	if (ieee80211_is_beacon(fc))
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Got beacon frame\n");
-	if (ieee80211_is_data(fc))
-		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Got data frame\n");
-	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
+	bv = ieee80211_is_probe_resp( fc );
+	if ( bv )
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
+			 "Got probe response frame\n" );
+	if ( ieee80211_is_beacon( fc ) )
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG, "Got beacon frame\n" );
+	if ( ieee80211_is_data( fc ) )
+		RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG, "Got data frame\n" );
+	RT_TRACE( rtlpriv, COMP_INIT, DBG_DMESG,
 		 "Fram: fc = 0x%X addr1 = 0x%02X:0x%02X:0x%02X:0x%02X:0x%02X:0x%02X\n",
 		 fc,
-		 (u32)hdr->addr1[0], (u32)hdr->addr1[1],
-		 (u32)hdr->addr1[2], (u32)hdr->addr1[3],
-		 (u32)hdr->addr1[4], (u32)hdr->addr1[5]);
-	memcpy(IEEE80211_SKB_RXCB(skb), rx_status, sizeof(*rx_status));
-	ieee80211_rx(hw, skb);
+		 ( u32 )hdr->addr1[0], ( u32 )hdr->addr1[1],
+		 ( u32 )hdr->addr1[2], ( u32 )hdr->addr1[3],
+		 ( u32 )hdr->addr1[4], ( u32 )hdr->addr1[5] );
+	memcpy( IEEE80211_SKB_RXCB( skb ), rx_status, sizeof( *rx_status ) );
+	ieee80211_rx( hw, skb );
 }
 
-void  rtl8192cu_rx_hdl(struct ieee80211_hw *hw, struct sk_buff * skb)
+void  rtl8192cu_rx_hdl( struct ieee80211_hw *hw, struct sk_buff * skb )
 {
-	_rtl_rx_process(hw, skb);
+	_rtl_rx_process( hw, skb );
 }
 
-void rtl8192c_rx_segregate_hdl(
+void rtl8192c_rx_segregate_hdl( 
 	struct ieee80211_hw *hw,
 	struct sk_buff *skb,
-	struct sk_buff_head *skb_list)
+	struct sk_buff_head *skb_list )
 {
 }
 
@@ -454,235 +461,235 @@ void rtl8192c_rx_segregate_hdl(
  *	Tx handler
  *
  *---------------------------------------------------------------------- */
-void rtl8192c_tx_cleanup(struct ieee80211_hw *hw, struct sk_buff  *skb)
+void rtl8192c_tx_cleanup( struct ieee80211_hw *hw, struct sk_buff  *skb )
 {
 }
 
-int rtl8192c_tx_post_hdl(struct ieee80211_hw *hw, struct urb *urb,
-			 struct sk_buff *skb)
+int rtl8192c_tx_post_hdl( struct ieee80211_hw *hw, struct urb *urb,
+			 struct sk_buff *skb )
 {
 	return 0;
 }
 
-struct sk_buff *rtl8192c_tx_aggregate_hdl(struct ieee80211_hw *hw,
-					   struct sk_buff_head *list)
+struct sk_buff *rtl8192c_tx_aggregate_hdl( struct ieee80211_hw *hw,
+					   struct sk_buff_head *list )
 {
-	return skb_dequeue(list);
+	return skb_dequeue( list );
 }
 
 /*======================================== trx ===============================*/
 
-static void _rtl_fill_usb_tx_desc(u8 *txdesc)
+static void _rtl_fill_usb_tx_desc( u8 *txdesc )
 {
-	SET_TX_DESC_OWN(txdesc, 1);
-	SET_TX_DESC_LAST_SEG(txdesc, 1);
-	SET_TX_DESC_FIRST_SEG(txdesc, 1);
+	SET_TX_DESC_OWN( txdesc, 1 );
+	SET_TX_DESC_LAST_SEG( txdesc, 1 );
+	SET_TX_DESC_FIRST_SEG( txdesc, 1 );
 }
 /**
  *	For HW recovery information
  */
-static void _rtl_tx_desc_checksum(u8 *txdesc)
+static void _rtl_tx_desc_checksum( u8 *txdesc )
 {
-	u16 *ptr = (u16 *)txdesc;
+	u16 *ptr = ( u16 * )txdesc;
 	u16	checksum = 0;
 	u32 index;
 
 	/* Clear first */
-	SET_TX_DESC_TX_DESC_CHECKSUM(txdesc, 0);
-	for (index = 0; index < 16; index++)
-		checksum = checksum ^ (*(ptr + index));
-	SET_TX_DESC_TX_DESC_CHECKSUM(txdesc, checksum);
+	SET_TX_DESC_TX_DESC_CHECKSUM( txdesc, 0 );
+	for ( index = 0; index < 16; index++ )
+		checksum = checksum ^ ( *( ptr + index ) );
+	SET_TX_DESC_TX_DESC_CHECKSUM( txdesc, checksum );
 }
 
-void rtl92cu_tx_fill_desc(struct ieee80211_hw *hw,
+void rtl92cu_tx_fill_desc( struct ieee80211_hw *hw,
 			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
 			  u8 *pbd_desc_tx, struct ieee80211_tx_info *info,
 			  struct ieee80211_sta *sta,
 			  struct sk_buff *skb,
 			  u8 queue_index,
-			  struct rtl_tcb_desc *tcb_desc)
+			  struct rtl_tcb_desc *tcb_desc )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
+	struct rtl_mac *mac = rtl_mac( rtl_priv( hw ) );
+	struct rtl_ps_ctl *ppsc = rtl_psc( rtl_priv( hw ) );
 	bool defaultadapter = true;
-	u8 *qc = ieee80211_get_qos_ctl(hdr);
+	u8 *qc = ieee80211_get_qos_ctl( hdr );
 	u8 tid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;
 	u16 seq_number;
 	__le16 fc = hdr->frame_control;
 	u8 rate_flag = info->control.rates[0].flags;
 	u16 pktlen = skb->len;
-	enum rtl_desc_qsel fw_qsel = _rtl8192cu_mq_to_descq(hw, fc,
-						skb_get_queue_mapping(skb));
+	enum rtl_desc_qsel fw_qsel = _rtl8192cu_mq_to_descq( hw, fc,
+						skb_get_queue_mapping( skb ) );
 	u8 *txdesc;
 
-	seq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
-	rtl_get_tcb_desc(hw, info, sta, skb, tcb_desc);
-	txdesc = (u8 *)skb_push(skb, RTL_TX_HEADER_SIZE);
-	memset(txdesc, 0, RTL_TX_HEADER_SIZE);
-	SET_TX_DESC_PKT_SIZE(txdesc, pktlen);
-	SET_TX_DESC_LINIP(txdesc, 0);
-	SET_TX_DESC_PKT_OFFSET(txdesc, RTL_DUMMY_OFFSET);
-	SET_TX_DESC_OFFSET(txdesc, RTL_TX_HEADER_SIZE);
-	SET_TX_DESC_TX_RATE(txdesc, tcb_desc->hw_rate);
-	if (tcb_desc->use_shortgi || tcb_desc->use_shortpreamble)
-		SET_TX_DESC_DATA_SHORTGI(txdesc, 1);
-	if (mac->tids[tid].agg.agg_state == RTL_AGG_ON &&
-		    info->flags & IEEE80211_TX_CTL_AMPDU) {
-		SET_TX_DESC_AGG_ENABLE(txdesc, 1);
-		SET_TX_DESC_MAX_AGG_NUM(txdesc, 0x14);
+	seq_number = ( le16_to_cpu( hdr->seq_ctrl ) & IEEE80211_SCTL_SEQ ) >> 4;
+	rtl_get_tcb_desc( hw, info, sta, skb, tcb_desc );
+	txdesc = ( u8 * )skb_push( skb, RTL_TX_HEADER_SIZE );
+	memset( txdesc, 0, RTL_TX_HEADER_SIZE );
+	SET_TX_DESC_PKT_SIZE( txdesc, pktlen );
+	SET_TX_DESC_LINIP( txdesc, 0 );
+	SET_TX_DESC_PKT_OFFSET( txdesc, RTL_DUMMY_OFFSET );
+	SET_TX_DESC_OFFSET( txdesc, RTL_TX_HEADER_SIZE );
+	SET_TX_DESC_TX_RATE( txdesc, tcb_desc->hw_rate );
+	if ( tcb_desc->use_shortgi || tcb_desc->use_shortpreamble )
+		SET_TX_DESC_DATA_SHORTGI( txdesc, 1 );
+	if ( mac->tids[tid].agg.agg_state == RTL_AGG_ON &&
+		    info->flags & IEEE80211_TX_CTL_AMPDU ) {
+		SET_TX_DESC_AGG_ENABLE( txdesc, 1 );
+		SET_TX_DESC_MAX_AGG_NUM( txdesc, 0x14 );
 	} else {
-		SET_TX_DESC_AGG_BREAK(txdesc, 1);
+		SET_TX_DESC_AGG_BREAK( txdesc, 1 );
 	}
-	SET_TX_DESC_SEQ(txdesc, seq_number);
-	SET_TX_DESC_RTS_ENABLE(txdesc, ((tcb_desc->rts_enable &&
-			       !tcb_desc->cts_enable) ? 1 : 0));
-	SET_TX_DESC_HW_RTS_ENABLE(txdesc, ((tcb_desc->rts_enable ||
-				  tcb_desc->cts_enable) ? 1 : 0));
-	SET_TX_DESC_CTS2SELF(txdesc, ((tcb_desc->cts_enable) ? 1 : 0));
-	SET_TX_DESC_RTS_STBC(txdesc, ((tcb_desc->rts_stbc) ? 1 : 0));
-	SET_TX_DESC_RTS_RATE(txdesc, tcb_desc->rts_rate);
-	SET_TX_DESC_RTS_BW(txdesc, 0);
-	SET_TX_DESC_RTS_SC(txdesc, tcb_desc->rts_sc);
-	SET_TX_DESC_RTS_SHORT(txdesc,
-			      ((tcb_desc->rts_rate <= DESC92_RATE54M) ?
-			       (tcb_desc->rts_use_shortpreamble ? 1 : 0)
-			       : (tcb_desc->rts_use_shortgi ? 1 : 0)));
-	if (mac->bw_40) {
-		if (rate_flag & IEEE80211_TX_RC_DUP_DATA) {
-			SET_TX_DESC_DATA_BW(txdesc, 1);
-			SET_TX_DESC_DATA_SC(txdesc, 3);
-		} else if(rate_flag & IEEE80211_TX_RC_40_MHZ_WIDTH){
-			SET_TX_DESC_DATA_BW(txdesc, 1);
-			SET_TX_DESC_DATA_SC(txdesc, mac->cur_40_prime_sc);
+	SET_TX_DESC_SEQ( txdesc, seq_number );
+	SET_TX_DESC_RTS_ENABLE( txdesc, ( ( tcb_desc->rts_enable &&
+			       !tcb_desc->cts_enable ) ? 1 : 0 ) );
+	SET_TX_DESC_HW_RTS_ENABLE( txdesc, ( ( tcb_desc->rts_enable ||
+				  tcb_desc->cts_enable ) ? 1 : 0 ) );
+	SET_TX_DESC_CTS2SELF( txdesc, ( ( tcb_desc->cts_enable ) ? 1 : 0 ) );
+	SET_TX_DESC_RTS_STBC( txdesc, ( ( tcb_desc->rts_stbc ) ? 1 : 0 ) );
+	SET_TX_DESC_RTS_RATE( txdesc, tcb_desc->rts_rate );
+	SET_TX_DESC_RTS_BW( txdesc, 0 );
+	SET_TX_DESC_RTS_SC( txdesc, tcb_desc->rts_sc );
+	SET_TX_DESC_RTS_SHORT( txdesc,
+			      ( ( tcb_desc->rts_rate <= DESC92_RATE54M ) ?
+			       ( tcb_desc->rts_use_shortpreamble ? 1 : 0 )
+			       : ( tcb_desc->rts_use_shortgi ? 1 : 0 ) ) );
+	if ( mac->bw_40 ) {
+		if ( rate_flag & IEEE80211_TX_RC_DUP_DATA ) {
+			SET_TX_DESC_DATA_BW( txdesc, 1 );
+			SET_TX_DESC_DATA_SC( txdesc, 3 );
+		} else if( rate_flag & IEEE80211_TX_RC_40_MHZ_WIDTH ){
+			SET_TX_DESC_DATA_BW( txdesc, 1 );
+			SET_TX_DESC_DATA_SC( txdesc, mac->cur_40_prime_sc );
 		} else {
-			SET_TX_DESC_DATA_BW(txdesc, 0);
-			SET_TX_DESC_DATA_SC(txdesc, 0);
+			SET_TX_DESC_DATA_BW( txdesc, 0 );
+			SET_TX_DESC_DATA_SC( txdesc, 0 );
 		}
 	} else {
-		SET_TX_DESC_DATA_BW(txdesc, 0);
-		SET_TX_DESC_DATA_SC(txdesc, 0);
+		SET_TX_DESC_DATA_BW( txdesc, 0 );
+		SET_TX_DESC_DATA_SC( txdesc, 0 );
 	}
 	rcu_read_lock();
-	sta = ieee80211_find_sta(mac->vif, mac->bssid);
-	if (sta) {
+	sta = ieee80211_find_sta( mac->vif, mac->bssid );
+	if ( sta ) {
 		u8 ampdu_density = sta->ht_cap.ampdu_density;
-		SET_TX_DESC_AMPDU_DENSITY(txdesc, ampdu_density);
+		SET_TX_DESC_AMPDU_DENSITY( txdesc, ampdu_density );
 	}
 	rcu_read_unlock();
-	if (info->control.hw_key) {
+	if ( info->control.hw_key ) {
 		struct ieee80211_key_conf *keyconf = info->control.hw_key;
-		switch (keyconf->cipher) {
+		switch ( keyconf->cipher ) {
 		case WLAN_CIPHER_SUITE_WEP40:
 		case WLAN_CIPHER_SUITE_WEP104:
 		case WLAN_CIPHER_SUITE_TKIP:
-			SET_TX_DESC_SEC_TYPE(txdesc, 0x1);
+			SET_TX_DESC_SEC_TYPE( txdesc, 0x1 );
 			break;
 		case WLAN_CIPHER_SUITE_CCMP:
-			SET_TX_DESC_SEC_TYPE(txdesc, 0x3);
+			SET_TX_DESC_SEC_TYPE( txdesc, 0x3 );
 			break;
 		default:
-			SET_TX_DESC_SEC_TYPE(txdesc, 0x0);
+			SET_TX_DESC_SEC_TYPE( txdesc, 0x0 );
 			break;
 		}
 	}
-	SET_TX_DESC_PKT_ID(txdesc, 0);
-	SET_TX_DESC_QUEUE_SEL(txdesc, fw_qsel);
-	SET_TX_DESC_DATA_RATE_FB_LIMIT(txdesc, 0x1F);
-	SET_TX_DESC_RTS_RATE_FB_LIMIT(txdesc, 0xF);
-	SET_TX_DESC_DISABLE_FB(txdesc, 0);
-	SET_TX_DESC_USE_RATE(txdesc, tcb_desc->use_driver_rate ? 1 : 0);
-	if (ieee80211_is_data_qos(fc)) {
-		if (mac->rdg_en) {
-			RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,
-				 "Enable RDG function\n");
-			SET_TX_DESC_RDG_ENABLE(txdesc, 1);
-			SET_TX_DESC_HTC(txdesc, 1);
+	SET_TX_DESC_PKT_ID( txdesc, 0 );
+	SET_TX_DESC_QUEUE_SEL( txdesc, fw_qsel );
+	SET_TX_DESC_DATA_RATE_FB_LIMIT( txdesc, 0x1F );
+	SET_TX_DESC_RTS_RATE_FB_LIMIT( txdesc, 0xF );
+	SET_TX_DESC_DISABLE_FB( txdesc, 0 );
+	SET_TX_DESC_USE_RATE( txdesc, tcb_desc->use_driver_rate ? 1 : 0 );
+	if ( ieee80211_is_data_qos( fc ) ) {
+		if ( mac->rdg_en ) {
+			RT_TRACE( rtlpriv, COMP_SEND, DBG_TRACE,
+				 "Enable RDG function\n" );
+			SET_TX_DESC_RDG_ENABLE( txdesc, 1 );
+			SET_TX_DESC_HTC( txdesc, 1 );
 		}
 	}
-	if (rtlpriv->dm.useramask) {
-		SET_TX_DESC_RATE_ID(txdesc, tcb_desc->ratr_index);
-		SET_TX_DESC_MACID(txdesc, tcb_desc->mac_id);
+	if ( rtlpriv->dm.useramask ) {
+		SET_TX_DESC_RATE_ID( txdesc, tcb_desc->ratr_index );
+		SET_TX_DESC_MACID( txdesc, tcb_desc->mac_id );
 	} else {
-		SET_TX_DESC_RATE_ID(txdesc, 0xC + tcb_desc->ratr_index);
-		SET_TX_DESC_MACID(txdesc, tcb_desc->ratr_index);
+		SET_TX_DESC_RATE_ID( txdesc, 0xC + tcb_desc->ratr_index );
+		SET_TX_DESC_MACID( txdesc, tcb_desc->ratr_index );
 	}
-	if ((!ieee80211_is_data_qos(fc)) && ppsc->leisure_ps &&
-	      ppsc->fwctrl_lps) {
-		SET_TX_DESC_HWSEQ_EN(txdesc, 1);
-		SET_TX_DESC_PKT_ID(txdesc, 8);
-		if (!defaultadapter)
-			SET_TX_DESC_QOS(txdesc, 1);
+	if ( ( !ieee80211_is_data_qos( fc ) ) && ppsc->leisure_ps &&
+	      ppsc->fwctrl_lps ) {
+		SET_TX_DESC_HWSEQ_EN( txdesc, 1 );
+		SET_TX_DESC_PKT_ID( txdesc, 8 );
+		if ( !defaultadapter )
+			SET_TX_DESC_QOS( txdesc, 1 );
 	}
-	if (ieee80211_has_morefrags(fc))
-		SET_TX_DESC_MORE_FRAG(txdesc, 1);
-	if (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||
-	    is_broadcast_ether_addr(ieee80211_get_DA(hdr)))
-		SET_TX_DESC_BMC(txdesc, 1);
-	_rtl_fill_usb_tx_desc(txdesc);
-	_rtl_tx_desc_checksum(txdesc);
-	RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE, "==>\n");
+	if ( ieee80211_has_morefrags( fc ) )
+		SET_TX_DESC_MORE_FRAG( txdesc, 1 );
+	if ( is_multicast_ether_addr( ieee80211_get_DA( hdr ) ) ||
+	    is_broadcast_ether_addr( ieee80211_get_DA( hdr ) ) )
+		SET_TX_DESC_BMC( txdesc, 1 );
+	_rtl_fill_usb_tx_desc( txdesc );
+	_rtl_tx_desc_checksum( txdesc );
+	RT_TRACE( rtlpriv, COMP_SEND, DBG_TRACE, "==>\n" );
 }
 
-void rtl92cu_fill_fake_txdesc(struct ieee80211_hw *hw, u8 * pDesc,
-			      u32 buffer_len, bool bIsPsPoll)
+void rtl92cu_fill_fake_txdesc( struct ieee80211_hw *hw, u8 * pDesc,
+			      u32 buffer_len, bool bIsPsPoll )
 {
 	/* Clear all status */
-	memset(pDesc, 0, RTL_TX_HEADER_SIZE);
-	SET_TX_DESC_FIRST_SEG(pDesc, 1); /* bFirstSeg; */
-	SET_TX_DESC_LAST_SEG(pDesc, 1); /* bLastSeg; */
-	SET_TX_DESC_OFFSET(pDesc, RTL_TX_HEADER_SIZE); /* Offset = 32 */
-	SET_TX_DESC_PKT_SIZE(pDesc, buffer_len); /* Buffer size + command hdr */
-	SET_TX_DESC_QUEUE_SEL(pDesc, QSLT_MGNT); /* Fixed queue of Mgnt queue */
+	memset( pDesc, 0, RTL_TX_HEADER_SIZE );
+	SET_TX_DESC_FIRST_SEG( pDesc, 1 ); /* bFirstSeg; */
+	SET_TX_DESC_LAST_SEG( pDesc, 1 ); /* bLastSeg; */
+	SET_TX_DESC_OFFSET( pDesc, RTL_TX_HEADER_SIZE ); /* Offset = 32 */
+	SET_TX_DESC_PKT_SIZE( pDesc, buffer_len ); /* Buffer size + command hdr */
+	SET_TX_DESC_QUEUE_SEL( pDesc, QSLT_MGNT ); /* Fixed queue of Mgnt queue */
 	/* Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error
 	 * vlaue by Hw. */
-	if (bIsPsPoll) {
-		SET_TX_DESC_NAV_USE_HDR(pDesc, 1);
+	if ( bIsPsPoll ) {
+		SET_TX_DESC_NAV_USE_HDR( pDesc, 1 );
 	} else {
-		SET_TX_DESC_HWSEQ_EN(pDesc, 1); /* Hw set sequence number */
-		SET_TX_DESC_PKT_ID(pDesc, 0x100); /* set bit3 to 1. */
+		SET_TX_DESC_HWSEQ_EN( pDesc, 1 ); /* Hw set sequence number */
+		SET_TX_DESC_PKT_ID( pDesc, 0x100 ); /* set bit3 to 1. */
 	}
-	SET_TX_DESC_USE_RATE(pDesc, 1); /* use data rate which is set by Sw */
-	SET_TX_DESC_OWN(pDesc, 1);
-	SET_TX_DESC_TX_RATE(pDesc, DESC92_RATE1M);
-	_rtl_tx_desc_checksum(pDesc);
+	SET_TX_DESC_USE_RATE( pDesc, 1 ); /* use data rate which is set by Sw */
+	SET_TX_DESC_OWN( pDesc, 1 );
+	SET_TX_DESC_TX_RATE( pDesc, DESC92_RATE1M );
+	_rtl_tx_desc_checksum( pDesc );
 }
 
-void rtl92cu_tx_fill_cmddesc(struct ieee80211_hw *hw,
+void rtl92cu_tx_fill_cmddesc( struct ieee80211_hw *hw,
 			     u8 *pdesc, bool firstseg,
-			     bool lastseg, struct sk_buff *skb)
+			     bool lastseg, struct sk_buff *skb )
 {
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_priv *rtlpriv = rtl_priv( hw );
 	u8 fw_queue = QSLT_BEACON;
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);
+	struct ieee80211_hdr *hdr = ( struct ieee80211_hdr * )( skb->data );
 	__le16 fc = hdr->frame_control;
 
-	memset((void *)pdesc, 0, RTL_TX_HEADER_SIZE);
-	if (firstseg)
-		SET_TX_DESC_OFFSET(pdesc, RTL_TX_HEADER_SIZE);
-	SET_TX_DESC_TX_RATE(pdesc, DESC92_RATE1M);
-	SET_TX_DESC_SEQ(pdesc, 0);
-	SET_TX_DESC_LINIP(pdesc, 0);
-	SET_TX_DESC_QUEUE_SEL(pdesc, fw_queue);
-	SET_TX_DESC_FIRST_SEG(pdesc, 1);
-	SET_TX_DESC_LAST_SEG(pdesc, 1);
-	SET_TX_DESC_RATE_ID(pdesc, 7);
-	SET_TX_DESC_MACID(pdesc, 0);
-	SET_TX_DESC_OWN(pdesc, 1);
-	SET_TX_DESC_PKT_SIZE(pdesc, (u16)skb->len);
-	SET_TX_DESC_FIRST_SEG(pdesc, 1);
-	SET_TX_DESC_LAST_SEG(pdesc, 1);
-	SET_TX_DESC_OFFSET(pdesc, 0x20);
-	SET_TX_DESC_USE_RATE(pdesc, 1);
-	if (!ieee80211_is_data_qos(fc)) {
-		SET_TX_DESC_HWSEQ_EN(pdesc, 1);
-		SET_TX_DESC_PKT_ID(pdesc, 8);
+	memset( ( void * )pdesc, 0, RTL_TX_HEADER_SIZE );
+	if ( firstseg )
+		SET_TX_DESC_OFFSET( pdesc, RTL_TX_HEADER_SIZE );
+	SET_TX_DESC_TX_RATE( pdesc, DESC92_RATE1M );
+	SET_TX_DESC_SEQ( pdesc, 0 );
+	SET_TX_DESC_LINIP( pdesc, 0 );
+	SET_TX_DESC_QUEUE_SEL( pdesc, fw_queue );
+	SET_TX_DESC_FIRST_SEG( pdesc, 1 );
+	SET_TX_DESC_LAST_SEG( pdesc, 1 );
+	SET_TX_DESC_RATE_ID( pdesc, 7 );
+	SET_TX_DESC_MACID( pdesc, 0 );
+	SET_TX_DESC_OWN( pdesc, 1 );
+	SET_TX_DESC_PKT_SIZE( pdesc, ( u16 )skb->len );
+	SET_TX_DESC_FIRST_SEG( pdesc, 1 );
+	SET_TX_DESC_LAST_SEG( pdesc, 1 );
+	SET_TX_DESC_OFFSET( pdesc, 0x20 );
+	SET_TX_DESC_USE_RATE( pdesc, 1 );
+	if ( !ieee80211_is_data_qos( fc ) ) {
+		SET_TX_DESC_HWSEQ_EN( pdesc, 1 );
+		SET_TX_DESC_PKT_ID( pdesc, 8 );
 	}
-	RT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD, "H2C Tx Cmd Content",
-		      pdesc, RTL_TX_DESC_SIZE);
+	RT_PRINT_DATA( rtlpriv, COMP_CMD, DBG_LOUD, "H2C Tx Cmd Content",
+		      pdesc, RTL_TX_DESC_SIZE );
 }
 
-bool rtl92cu_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb)
+bool rtl92cu_cmd_send_packet( struct ieee80211_hw *hw, struct sk_buff *skb )
 {
 	return true;
 }
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/trx.h b/drivers/net/wireless/rtlwifi/rtl8192cu/trx.h
index fd8051d..fb59eaa 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/trx.h
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/trx.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009-2012  Realtek Corporation. All rights reserved.
+ * Copyright( c ) 2009-2012  Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -23,6 +23,13 @@
  * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
  * Hsinchu 300, Taiwan.
  *
+ *
+ * Bug Fixes and enhancements for Linux Kernels >= 3.2
+ * by Benjamin Porter <BenjaminPorter86@gmail.com>
+ *
+ * Project homepage: https://github.com/FreedomBen/rtl8188ce-linux-driver
+ *
+ *
  * Larry Finger <Larry.Finger@lwfinger.net>
  *
  *****************************************************************************/
@@ -46,9 +53,9 @@ enum usb_rx_agg_mode {
 	USB_RX_AGG_DMA_USB
 };
 
-#define TX_SELE_HQ				BIT(0)	/* High Queue */
-#define TX_SELE_LQ				BIT(1)	/* Low Queue */
-#define TX_SELE_NQ				BIT(2)	/* Normal Queue */
+#define TX_SELE_HQ				BIT( 0 )	/* High Queue */
+#define TX_SELE_LQ				BIT( 1 )	/* Low Queue */
+#define TX_SELE_NQ				BIT( 2 )	/* Normal Queue */
 
 #define RTL_USB_TX_AGG_NUM_DESC			5
 
@@ -101,9 +108,9 @@ struct rx_drv_info_92c {
  * bit count, and extracts that number of bits.
  */
 
-#define SHIFT_AND_MASK_LE(__pdesc, __shift, __bits)		\
-	((le32_to_cpu(*(((__le32 *)(__pdesc)))) >> (__shift)) &	\
-	BIT_LEN_MASK_32(__bits))
+#define SHIFT_AND_MASK_LE( __pdesc, __shift, __bits )		\
+	( ( le32_to_cpu( *( ( ( __le32 * )( __pdesc ) ) ) ) >> ( __shift ) ) &	\
+	BIT_LEN_MASK_32( __bits ) )
 
 /* Define a macro that clears a bit field in an le32 word and
  * sets the specified value into that bit field. The resulting
@@ -112,324 +119,324 @@ struct rx_drv_info_92c {
  * back to le32.
  */
 
-#define SET_BITS_OFFSET_LE(__pdesc, __shift, __len, __val)	\
-	(*(__le32 *)(__pdesc) = 				\
-	(cpu_to_le32((le32_to_cpu(*((__le32 *)(__pdesc))) &	\
-	(~(BIT_OFFSET_LEN_MASK_32((__shift), __len)))) |		\
-	(((u32)(__val) & BIT_LEN_MASK_32(__len)) << (__shift)))));
+#define SET_BITS_OFFSET_LE( __pdesc, __shift, __len, __val )	\
+	( *( __le32 * )( __pdesc ) = 				\
+	( cpu_to_le32( ( le32_to_cpu( *( ( __le32 * )( __pdesc ) ) ) &	\
+	( ~( BIT_OFFSET_LEN_MASK_32( ( __shift ), __len ) ) ) ) |		\
+	( ( ( u32 )( __val ) & BIT_LEN_MASK_32( __len ) ) << ( __shift ) ) ) ) );
 
 /* macros to read various fields in RX descriptor */
 
 /* DWORD 0 */
-#define GET_RX_DESC_PKT_LEN(__rxdesc)		\
-	SHIFT_AND_MASK_LE((__rxdesc), 0, 14)
-#define GET_RX_DESC_CRC32(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 14, 1)
-#define GET_RX_DESC_ICV(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 15, 1)
-#define GET_RX_DESC_DRVINFO_SIZE(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc, 16, 4)
-#define GET_RX_DESC_SECURITY(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 20, 3)
-#define GET_RX_DESC_QOS(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 23, 1)
-#define GET_RX_DESC_SHIFT(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 24, 2)
-#define GET_RX_DESC_PHY_STATUS(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc, 26, 1)
-#define GET_RX_DESC_SWDEC(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 27, 1)
-#define GET_RX_DESC_LAST_SEG(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 28, 1)
-#define GET_RX_DESC_FIRST_SEG(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 29, 1)
-#define GET_RX_DESC_EOR(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 30, 1)
-#define GET_RX_DESC_OWN(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc, 31, 1)
+#define GET_RX_DESC_PKT_LEN( __rxdesc )		\
+	SHIFT_AND_MASK_LE( ( __rxdesc ), 0, 14 )
+#define GET_RX_DESC_CRC32( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 14, 1 )
+#define GET_RX_DESC_ICV( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 15, 1 )
+#define GET_RX_DESC_DRVINFO_SIZE( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc, 16, 4 )
+#define GET_RX_DESC_SECURITY( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 20, 3 )
+#define GET_RX_DESC_QOS( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 23, 1 )
+#define GET_RX_DESC_SHIFT( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 24, 2 )
+#define GET_RX_DESC_PHY_STATUS( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc, 26, 1 )
+#define GET_RX_DESC_SWDEC( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 27, 1 )
+#define GET_RX_DESC_LAST_SEG( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 28, 1 )
+#define GET_RX_DESC_FIRST_SEG( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 29, 1 )
+#define GET_RX_DESC_EOR( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 30, 1 )
+#define GET_RX_DESC_OWN( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc, 31, 1 )
 
 /* DWORD 1 */
-#define GET_RX_DESC_MACID(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 0, 5)
-#define GET_RX_DESC_TID(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 5, 4)
-#define GET_RX_DESC_PAGGR(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 14, 1)
-#define GET_RX_DESC_FAGGR(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 15, 1)
-#define GET_RX_DESC_A1_FIT(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 16, 4)
-#define GET_RX_DESC_A2_FIT(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 20, 4)
-#define GET_RX_DESC_PAM(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 24, 1)
-#define GET_RX_DESC_PWR(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 25, 1)
-#define GET_RX_DESC_MORE_DATA(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 26, 1)
-#define GET_RX_DESC_MORE_FRAG(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 27, 1)
-#define GET_RX_DESC_TYPE(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 28, 2)
-#define GET_RX_DESC_MC(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 30, 1)
-#define GET_RX_DESC_BC(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+4, 31, 1)
+#define GET_RX_DESC_MACID( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 0, 5 )
+#define GET_RX_DESC_TID( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 5, 4 )
+#define GET_RX_DESC_PAGGR( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 14, 1 )
+#define GET_RX_DESC_FAGGR( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 15, 1 )
+#define GET_RX_DESC_A1_FIT( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 16, 4 )
+#define GET_RX_DESC_A2_FIT( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 20, 4 )
+#define GET_RX_DESC_PAM( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 24, 1 )
+#define GET_RX_DESC_PWR( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 25, 1 )
+#define GET_RX_DESC_MORE_DATA( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 26, 1 )
+#define GET_RX_DESC_MORE_FRAG( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 27, 1 )
+#define GET_RX_DESC_TYPE( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 28, 2 )
+#define GET_RX_DESC_MC( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 30, 1 )
+#define GET_RX_DESC_BC( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+4, 31, 1 )
 
 /* DWORD 2 */
-#define GET_RX_DESC_SEQ(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+8, 0, 12)
-#define GET_RX_DESC_FRAG(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+8, 12, 4)
-#define GET_RX_DESC_USB_AGG_PKTNUM(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc+8, 16, 8)
-#define GET_RX_DESC_NEXT_IND(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+8, 30, 1)
+#define GET_RX_DESC_SEQ( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+8, 0, 12 )
+#define GET_RX_DESC_FRAG( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+8, 12, 4 )
+#define GET_RX_DESC_USB_AGG_PKTNUM( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc+8, 16, 8 )
+#define GET_RX_DESC_NEXT_IND( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+8, 30, 1 )
 
 /* DWORD 3 */
-#define GET_RX_DESC_RX_MCS(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 0, 6)
-#define GET_RX_DESC_RX_HT(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 6, 1)
-#define GET_RX_DESC_AMSDU(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 7, 1)
-#define GET_RX_DESC_SPLCP(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 8, 1)
-#define GET_RX_DESC_BW(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 9, 1)
-#define GET_RX_DESC_HTC(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 10, 1)
-#define GET_RX_DESC_TCP_CHK_RPT(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 11, 1)
-#define GET_RX_DESC_IP_CHK_RPT(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 12, 1)
-#define GET_RX_DESC_TCP_CHK_VALID(__rxdesc)	\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 13, 1)
-#define GET_RX_DESC_HWPC_ERR(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 14, 1)
-#define GET_RX_DESC_HWPC_IND(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 15, 1)
-#define GET_RX_DESC_IV0(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+12, 16, 16)
+#define GET_RX_DESC_RX_MCS( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 0, 6 )
+#define GET_RX_DESC_RX_HT( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 6, 1 )
+#define GET_RX_DESC_AMSDU( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 7, 1 )
+#define GET_RX_DESC_SPLCP( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 8, 1 )
+#define GET_RX_DESC_BW( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 9, 1 )
+#define GET_RX_DESC_HTC( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 10, 1 )
+#define GET_RX_DESC_TCP_CHK_RPT( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 11, 1 )
+#define GET_RX_DESC_IP_CHK_RPT( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 12, 1 )
+#define GET_RX_DESC_TCP_CHK_VALID( __rxdesc )	\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 13, 1 )
+#define GET_RX_DESC_HWPC_ERR( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 14, 1 )
+#define GET_RX_DESC_HWPC_IND( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 15, 1 )
+#define GET_RX_DESC_IV0( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+12, 16, 16 )
 
 /* DWORD 4 */
-#define GET_RX_DESC_IV1(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+16, 0, 32)
+#define GET_RX_DESC_IV1( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+16, 0, 32 )
 
 /* DWORD 5 */
-#define GET_RX_DESC_TSFL(__rxdesc)		\
-	SHIFT_AND_MASK_LE(__rxdesc+20, 0, 32)
+#define GET_RX_DESC_TSFL( __rxdesc )		\
+	SHIFT_AND_MASK_LE( __rxdesc+20, 0, 32 )
 
 /*======================= tx desc ============================================*/
 
 /* macros to set various fields in TX descriptor */
 
 /* Dword 0 */
-#define SET_TX_DESC_PKT_SIZE(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 0, 16, __value)
-#define SET_TX_DESC_OFFSET(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 16, 8, __value)
-#define SET_TX_DESC_BMC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 24, 1, __value)
-#define SET_TX_DESC_HTC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 25, 1, __value)
-#define SET_TX_DESC_LAST_SEG(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 26, 1, __value)
-#define SET_TX_DESC_FIRST_SEG(__txdesc, __value)	\
-	 SET_BITS_OFFSET_LE(__txdesc, 27, 1, __value)
-#define SET_TX_DESC_LINIP(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 28, 1, __value)
-#define SET_TX_DESC_NO_ACM(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 29, 1, __value)
-#define SET_TX_DESC_GF(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 30, 1, __value)
-#define SET_TX_DESC_OWN(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc, 31, 1, __value)
+#define SET_TX_DESC_PKT_SIZE( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 0, 16, __value )
+#define SET_TX_DESC_OFFSET( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 16, 8, __value )
+#define SET_TX_DESC_BMC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 24, 1, __value )
+#define SET_TX_DESC_HTC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 25, 1, __value )
+#define SET_TX_DESC_LAST_SEG( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 26, 1, __value )
+#define SET_TX_DESC_FIRST_SEG( __txdesc, __value )	\
+	 SET_BITS_OFFSET_LE( __txdesc, 27, 1, __value )
+#define SET_TX_DESC_LINIP( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 28, 1, __value )
+#define SET_TX_DESC_NO_ACM( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 29, 1, __value )
+#define SET_TX_DESC_GF( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 30, 1, __value )
+#define SET_TX_DESC_OWN( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc, 31, 1, __value )
 
 
 /* Dword 1 */
-#define SET_TX_DESC_MACID(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+4, 0, 5, __value)
-#define SET_TX_DESC_AGG_ENABLE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 5, 1, __value)
-#define SET_TX_DESC_AGG_BREAK(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 6, 1, __value)
-#define SET_TX_DESC_RDG_ENABLE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 7, 1, __value)
-#define SET_TX_DESC_QUEUE_SEL(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 8, 5, __value)
-#define SET_TX_DESC_RDG_NAV_EXT(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 13, 1, __value)
-#define SET_TX_DESC_LSIG_TXOP_EN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 14, 1, __value)
-#define SET_TX_DESC_PIFS(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+4, 15, 1, __value)
-#define SET_TX_DESC_RATE_ID(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+4, 16, 4, __value)
-#define SET_TX_DESC_RA_BRSR_ID(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 16, 4, __value)
-#define SET_TX_DESC_NAV_USE_HDR(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 20, 1, __value)
-#define SET_TX_DESC_EN_DESC_ID(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 21, 1, __value)
-#define SET_TX_DESC_SEC_TYPE(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+4, 22, 2, __value)
-#define SET_TX_DESC_PKT_OFFSET(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+4, 26, 5, __value)
+#define SET_TX_DESC_MACID( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+4, 0, 5, __value )
+#define SET_TX_DESC_AGG_ENABLE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 5, 1, __value )
+#define SET_TX_DESC_AGG_BREAK( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 6, 1, __value )
+#define SET_TX_DESC_RDG_ENABLE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 7, 1, __value )
+#define SET_TX_DESC_QUEUE_SEL( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 8, 5, __value )
+#define SET_TX_DESC_RDG_NAV_EXT( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 13, 1, __value )
+#define SET_TX_DESC_LSIG_TXOP_EN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 14, 1, __value )
+#define SET_TX_DESC_PIFS( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+4, 15, 1, __value )
+#define SET_TX_DESC_RATE_ID( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+4, 16, 4, __value )
+#define SET_TX_DESC_RA_BRSR_ID( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 16, 4, __value )
+#define SET_TX_DESC_NAV_USE_HDR( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 20, 1, __value )
+#define SET_TX_DESC_EN_DESC_ID( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 21, 1, __value )
+#define SET_TX_DESC_SEC_TYPE( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+4, 22, 2, __value )
+#define SET_TX_DESC_PKT_OFFSET( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+4, 26, 5, __value )
 
 /* Dword 2 */
-#define SET_TX_DESC_RTS_RC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 0, 6, __value)
-#define SET_TX_DESC_DATA_RC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 6, 6, __value)
-#define SET_TX_DESC_BAR_RTY_TH(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+8, 14, 2, __value)
-#define SET_TX_DESC_MORE_FRAG(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+8, 17, 1, __value)
-#define SET_TX_DESC_RAW(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 18, 1, __value)
-#define SET_TX_DESC_CCX(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 19, 1, __value)
-#define SET_TX_DESC_AMPDU_DENSITY(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+8, 20, 3, __value)
-#define SET_TX_DESC_ANTSEL_A(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 24, 1, __value)
-#define SET_TX_DESC_ANTSEL_B(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 25, 1, __value)
-#define SET_TX_DESC_TX_ANT_CCK(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+8, 26, 2, __value)
-#define SET_TX_DESC_TX_ANTL(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+8, 28, 2, __value)
-#define SET_TX_DESC_TX_ANT_HT(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+8, 30, 2, __value)
+#define SET_TX_DESC_RTS_RC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 0, 6, __value )
+#define SET_TX_DESC_DATA_RC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 6, 6, __value )
+#define SET_TX_DESC_BAR_RTY_TH( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+8, 14, 2, __value )
+#define SET_TX_DESC_MORE_FRAG( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+8, 17, 1, __value )
+#define SET_TX_DESC_RAW( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 18, 1, __value )
+#define SET_TX_DESC_CCX( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 19, 1, __value )
+#define SET_TX_DESC_AMPDU_DENSITY( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+8, 20, 3, __value )
+#define SET_TX_DESC_ANTSEL_A( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 24, 1, __value )
+#define SET_TX_DESC_ANTSEL_B( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 25, 1, __value )
+#define SET_TX_DESC_TX_ANT_CCK( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+8, 26, 2, __value )
+#define SET_TX_DESC_TX_ANTL( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+8, 28, 2, __value )
+#define SET_TX_DESC_TX_ANT_HT( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+8, 30, 2, __value )
 
 /* Dword 3 */
-#define SET_TX_DESC_NEXT_HEAP_PAGE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+12, 0, 8, __value)
-#define SET_TX_DESC_TAIL_PAGE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+12, 8, 8, __value)
-#define SET_TX_DESC_SEQ(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+12, 16, 12, __value)
-#define SET_TX_DESC_PKT_ID(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+12, 28, 4, __value)
+#define SET_TX_DESC_NEXT_HEAP_PAGE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+12, 0, 8, __value )
+#define SET_TX_DESC_TAIL_PAGE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+12, 8, 8, __value )
+#define SET_TX_DESC_SEQ( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+12, 16, 12, __value )
+#define SET_TX_DESC_PKT_ID( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+12, 28, 4, __value )
 
 /* Dword 4 */
-#define SET_TX_DESC_RTS_RATE(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 0, 5, __value)
-#define SET_TX_DESC_AP_DCFE(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 5, 1, __value)
-#define SET_TX_DESC_QOS(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 6, 1, __value)
-#define SET_TX_DESC_HWSEQ_EN(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 7, 1, __value)
-#define SET_TX_DESC_USE_RATE(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 8, 1, __value)
-#define SET_TX_DESC_DISABLE_RTS_FB(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 9, 1, __value)
-#define SET_TX_DESC_DISABLE_FB(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 10, 1, __value)
-#define SET_TX_DESC_CTS2SELF(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 11, 1, __value)
-#define SET_TX_DESC_RTS_ENABLE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 12, 1, __value)
-#define SET_TX_DESC_HW_RTS_ENABLE(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 13, 1, __value)
-#define SET_TX_DESC_WAIT_DCTS(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 18, 1, __value)
-#define SET_TX_DESC_CTS2AP_EN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 19, 1, __value)
-#define SET_TX_DESC_DATA_SC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 20, 2, __value)
-#define SET_TX_DESC_DATA_STBC(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 22, 2, __value)
-#define SET_TX_DESC_DATA_SHORT(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 24, 1, __value)
-#define SET_TX_DESC_DATA_BW(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 25, 1, __value)
-#define SET_TX_DESC_RTS_SHORT(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+16, 26, 1, __value)
-#define SET_TX_DESC_RTS_BW(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 27, 1, __value)
-#define SET_TX_DESC_RTS_SC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 28, 2, __value)
-#define SET_TX_DESC_RTS_STBC(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+16, 30, 2, __value)
+#define SET_TX_DESC_RTS_RATE( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 0, 5, __value )
+#define SET_TX_DESC_AP_DCFE( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 5, 1, __value )
+#define SET_TX_DESC_QOS( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 6, 1, __value )
+#define SET_TX_DESC_HWSEQ_EN( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 7, 1, __value )
+#define SET_TX_DESC_USE_RATE( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 8, 1, __value )
+#define SET_TX_DESC_DISABLE_RTS_FB( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 9, 1, __value )
+#define SET_TX_DESC_DISABLE_FB( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 10, 1, __value )
+#define SET_TX_DESC_CTS2SELF( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 11, 1, __value )
+#define SET_TX_DESC_RTS_ENABLE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 12, 1, __value )
+#define SET_TX_DESC_HW_RTS_ENABLE( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 13, 1, __value )
+#define SET_TX_DESC_WAIT_DCTS( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 18, 1, __value )
+#define SET_TX_DESC_CTS2AP_EN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 19, 1, __value )
+#define SET_TX_DESC_DATA_SC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 20, 2, __value )
+#define SET_TX_DESC_DATA_STBC( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 22, 2, __value )
+#define SET_TX_DESC_DATA_SHORT( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 24, 1, __value )
+#define SET_TX_DESC_DATA_BW( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 25, 1, __value )
+#define SET_TX_DESC_RTS_SHORT( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+16, 26, 1, __value )
+#define SET_TX_DESC_RTS_BW( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 27, 1, __value )
+#define SET_TX_DESC_RTS_SC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 28, 2, __value )
+#define SET_TX_DESC_RTS_STBC( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+16, 30, 2, __value )
 
 /* Dword 5 */
-#define SET_TX_DESC_TX_RATE(__pdesc, __val)		\
-	SET_BITS_OFFSET_LE(__pdesc+20, 0, 6, __val)
-#define SET_TX_DESC_DATA_SHORTGI(__pdesc, __val)	\
-	SET_BITS_OFFSET_LE(__pdesc+20, 6, 1, __val)
-#define SET_TX_DESC_CCX_TAG(__pdesc, __val)		\
-	SET_BITS_OFFSET_LE(__pdesc+20, 7, 1, __val)
-#define SET_TX_DESC_DATA_RATE_FB_LIMIT(__txdesc, __value) \
-	SET_BITS_OFFSET_LE(__txdesc+20, 8, 5, __value)
-#define SET_TX_DESC_RTS_RATE_FB_LIMIT(__txdesc, __value) \
-	SET_BITS_OFFSET_LE(__txdesc+20, 13, 4, __value)
-#define SET_TX_DESC_RETRY_LIMIT_ENABLE(__txdesc, __value) \
-	SET_BITS_OFFSET_LE(__txdesc+20, 17, 1, __value)
-#define SET_TX_DESC_DATA_RETRY_LIMIT(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+20, 18, 6, __value)
-#define SET_TX_DESC_USB_TXAGG_NUM(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+20, 24, 8, __value)
+#define SET_TX_DESC_TX_RATE( __pdesc, __val )		\
+	SET_BITS_OFFSET_LE( __pdesc+20, 0, 6, __val )
+#define SET_TX_DESC_DATA_SHORTGI( __pdesc, __val )	\
+	SET_BITS_OFFSET_LE( __pdesc+20, 6, 1, __val )
+#define SET_TX_DESC_CCX_TAG( __pdesc, __val )		\
+	SET_BITS_OFFSET_LE( __pdesc+20, 7, 1, __val )
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT( __txdesc, __value ) \
+	SET_BITS_OFFSET_LE( __txdesc+20, 8, 5, __value )
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT( __txdesc, __value ) \
+	SET_BITS_OFFSET_LE( __txdesc+20, 13, 4, __value )
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE( __txdesc, __value ) \
+	SET_BITS_OFFSET_LE( __txdesc+20, 17, 1, __value )
+#define SET_TX_DESC_DATA_RETRY_LIMIT( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+20, 18, 6, __value )
+#define SET_TX_DESC_USB_TXAGG_NUM( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+20, 24, 8, __value )
 
 /* Dword 6 */
-#define SET_TX_DESC_TXAGC_A(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+24, 0, 5, __value)
-#define SET_TX_DESC_TXAGC_B(__txdesc, __value)		\
-	SET_BITS_OFFSET_LE(__txdesc+24, 5, 5, __value)
-#define SET_TX_DESC_USB_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 10, 1, __value)
-#define SET_TX_DESC_MAX_AGG_NUM(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 11, 5, __value)
-#define SET_TX_DESC_MCSG1_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 16, 4, __value)
-#define SET_TX_DESC_MCSG2_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 20, 4, __value)
-#define SET_TX_DESC_MCSG3_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 24, 4, __value)
-#define SET_TX_DESC_MCSG7_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+24, 28, 4, __value)
+#define SET_TX_DESC_TXAGC_A( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+24, 0, 5, __value )
+#define SET_TX_DESC_TXAGC_B( __txdesc, __value )		\
+	SET_BITS_OFFSET_LE( __txdesc+24, 5, 5, __value )
+#define SET_TX_DESC_USB_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 10, 1, __value )
+#define SET_TX_DESC_MAX_AGG_NUM( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 11, 5, __value )
+#define SET_TX_DESC_MCSG1_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 16, 4, __value )
+#define SET_TX_DESC_MCSG2_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 20, 4, __value )
+#define SET_TX_DESC_MCSG3_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 24, 4, __value )
+#define SET_TX_DESC_MCSG7_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+24, 28, 4, __value )
 
 /* Dword 7 */
-#define SET_TX_DESC_TX_DESC_CHECKSUM(__txdesc, __value) \
-	SET_BITS_OFFSET_LE(__txdesc+28, 0, 16, __value)
-#define SET_TX_DESC_MCSG4_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+28, 16, 4, __value)
-#define SET_TX_DESC_MCSG5_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+28, 20, 4, __value)
-#define SET_TX_DESC_MCSG6_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+28, 24, 4, __value)
-#define SET_TX_DESC_MCSG15_MAX_LEN(__txdesc, __value)	\
-	SET_BITS_OFFSET_LE(__txdesc+28, 28, 4, __value)
-
-
-int  rtl8192cu_endpoint_mapping(struct ieee80211_hw *hw);
-u16 rtl8192cu_mq_to_hwq(__le16 fc, u16 mac80211_queue_index);
-bool rtl92cu_rx_query_desc(struct ieee80211_hw *hw,
+#define SET_TX_DESC_TX_DESC_CHECKSUM( __txdesc, __value ) \
+	SET_BITS_OFFSET_LE( __txdesc+28, 0, 16, __value )
+#define SET_TX_DESC_MCSG4_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+28, 16, 4, __value )
+#define SET_TX_DESC_MCSG5_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+28, 20, 4, __value )
+#define SET_TX_DESC_MCSG6_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+28, 24, 4, __value )
+#define SET_TX_DESC_MCSG15_MAX_LEN( __txdesc, __value )	\
+	SET_BITS_OFFSET_LE( __txdesc+28, 28, 4, __value )
+
+
+int  rtl8192cu_endpoint_mapping( struct ieee80211_hw *hw );
+u16 rtl8192cu_mq_to_hwq( __le16 fc, u16 mac80211_queue_index );
+bool rtl92cu_rx_query_desc( struct ieee80211_hw *hw,
 			   struct rtl_stats *stats,
 			   struct ieee80211_rx_status *rx_status,
-			   u8 *p_desc, struct sk_buff *skb);
-void  rtl8192cu_rx_hdl(struct ieee80211_hw *hw, struct sk_buff * skb);
-void rtl8192c_rx_segregate_hdl(struct ieee80211_hw *, struct sk_buff *,
-			       struct sk_buff_head *);
-void rtl8192c_tx_cleanup(struct ieee80211_hw *hw, struct sk_buff  *skb);
-int rtl8192c_tx_post_hdl(struct ieee80211_hw *hw, struct urb *urb,
-			 struct sk_buff *skb);
-struct sk_buff *rtl8192c_tx_aggregate_hdl(struct ieee80211_hw *,
-					   struct sk_buff_head *);
-void rtl92cu_tx_fill_desc(struct ieee80211_hw *hw,
+			   u8 *p_desc, struct sk_buff *skb );
+void  rtl8192cu_rx_hdl( struct ieee80211_hw *hw, struct sk_buff * skb );
+void rtl8192c_rx_segregate_hdl( struct ieee80211_hw *, struct sk_buff *,
+			       struct sk_buff_head * );
+void rtl8192c_tx_cleanup( struct ieee80211_hw *hw, struct sk_buff  *skb );
+int rtl8192c_tx_post_hdl( struct ieee80211_hw *hw, struct urb *urb,
+			 struct sk_buff *skb );
+struct sk_buff *rtl8192c_tx_aggregate_hdl( struct ieee80211_hw *,
+					   struct sk_buff_head * );
+void rtl92cu_tx_fill_desc( struct ieee80211_hw *hw,
 			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
 			  u8 *pbd_desc_tx, struct ieee80211_tx_info *info,
 			  struct ieee80211_sta *sta,
 			  struct sk_buff *skb,
 			  u8 queue_index,
-			  struct rtl_tcb_desc *tcb_desc);
-void rtl92cu_fill_fake_txdesc(struct ieee80211_hw *hw, u8 * pDesc,
-			      u32 buffer_len, bool bIsPsPoll);
-void rtl92cu_tx_fill_cmddesc(struct ieee80211_hw *hw,
+			  struct rtl_tcb_desc *tcb_desc );
+void rtl92cu_fill_fake_txdesc( struct ieee80211_hw *hw, u8 * pDesc,
+			      u32 buffer_len, bool bIsPsPoll );
+void rtl92cu_tx_fill_cmddesc( struct ieee80211_hw *hw,
 			     u8 *pdesc, bool b_firstseg,
-			     bool b_lastseg, struct sk_buff *skb);
-bool rtl92cu_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb);
+			     bool b_lastseg, struct sk_buff *skb );
+bool rtl92cu_cmd_send_packet( struct ieee80211_hw *hw, struct sk_buff *skb );
 
 #endif
