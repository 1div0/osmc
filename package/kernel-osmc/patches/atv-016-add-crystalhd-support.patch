diff --git a/drivers/staging/chd/20-crystalhd.rules b/drivers/staging/chd/20-crystalhd.rules
new file mode 100644
index 0000000..93b21b8
--- /dev/null
+++ b/drivers/staging/chd/20-crystalhd.rules
@@ -0,0 +1 @@
+KERNEL=="crystalhd", MODE="0666"
diff --git a/drivers/staging/chd/FleaDefs.h b/drivers/staging/chd/FleaDefs.h
new file mode 100644
index 0000000..2f17028
--- /dev/null
+++ b/drivers/staging/chd/FleaDefs.h
@@ -0,0 +1,218 @@
+#ifndef _FLEA_DEFS_
+#define _FLEA_DEFS_
+
+/*
+* Include a whole bunch of RDB files for register definitions
+*/
+#include "bchp_misc1.h"
+#include "bchp_misc2.h"
+#include "bchp_misc3.h"
+#include "bchp_scrub_ctrl.h"
+#include "bchp_wrap_misc_intr2.h"
+#include "bchp_armcr4_bridge.h"
+#include "bchp_intr.h"
+#include "bchp_pri_arb_control_regs.h"
+#include "bchp_ddr23_ctl_regs_0.h"
+#include "bchp_ddr23_phy_byte_lane_0.h"
+#include "bchp_ddr23_phy_byte_lane_1.h"
+#include "bchp_ddr23_phy_control_regs.h"
+#include "bchp_clk.h"
+#include "bchp_pcie_tl.h"
+#include "bchp_sun_gisb_arb.h"
+#include "bchp_misc_perst.h"
+#include "bchp_decode_cpuregs_0.h"
+#include "bchp_decode_cpuregs2_0.h"
+#include "bchp_pcie_cfg.h"
+#include "bchp_mfd.h"
+#include "bchp_sun_top_ctrl.h"
+#include "bchp_gio.h"
+#include "bchp_pri_client_regs.h"
+
+// Assume we have 64MB DRam
+#define FLEA_TOTAL_DRAM_SIZE		64*1024*1024
+#define FLEA_GISB_DIRECT_BASE		0x50
+
+/*- These definition of the ADDRESS and DATA
+  - Registers are not there in RDB.
+ */
+#define FLEA_GISB_INDIRECT_ADDRESS	0xFFF8
+#define FLEA_GISB_INDIRECT_DATA		0xFFFC
+
+/*
+ * POLL count for Flea.
+ */
+#define FLEA_MAX_POLL_CNT		1000
+
+/*
+ -- Flea Firmware Signature length (128 bit)
+ */
+#define FLEA_FW_SIG_LEN_IN_BYTES	16
+#define LENGTH_FIELD_SIZE			4
+#define FLEA_FW_SIG_LEN_IN_DWORD	(FLEA_FW_SIG_LEN_IN_BYTES/4)
+#define FW_DOWNLOAD_START_ADDR		0
+
+/*
+ * Some macros to ease the bit specification from RDB
+ */
+#define SCRAM_KEY_DONE_INT_BIT	BC_BIT(BCHP_WRAP_MISC_INTR2_CPU_STATUS_SCRM_KEY_DONE_INTR_SHIFT)
+#define BOOT_VER_DONE_BIT		BC_BIT(BCHP_WRAP_MISC_INTR2_CPU_STATUS_BOOT_VER_DONE_INTR_SHIFT)
+#define BOOT_VER_FAIL_BIT		BC_BIT(BCHP_WRAP_MISC_INTR2_CPU_STATUS_BOOT_VER_FAIL_INTR_SHIFT)
+#define SHARF_ERR_INTR			BC_BIT(BCHP_WRAP_MISC_INTR2_CPU_STATUS_SHARF_ERR_INTR_SHIFT)
+#define SCRUB_ENABLE_BIT		BC_BIT(BCHP_SCRUB_CTRL_SCRUB_ENABLE_SCRUB_EN_SHIFT)
+#define DRAM_SCRAM_ENABLE_BIT	BC_BIT(BCHP_SCRUB_CTRL_SCRUB_ENABLE_DSCRAM_EN_SHIFT)
+#define ARM_RUN_REQ_BIT			BC_BIT(BCHP_ARMCR4_BRIDGE_REG_BRIDGE_CTL_arm_run_request_SHIFT)
+#define GetScrubEndAddr(_Sz)	((FW_DOWNLOAD_START_ADDR + (_Sz - FLEA_FW_SIG_LEN_IN_BYTES -LENGTH_FIELD_SIZE-1))& (BCHP_SCRUB_CTRL_BORCH_END_ADDRESS_BORCH_END_ADDR_MASK))
+
+/*
+-- Firmware Command Interface Definitions.
+-- We use BCHP_ARMCR4_BRIDGE_REG_MBOX_PCI1 as host to FW mailbox.
+-- We use BCHP_ARMCR4_BRIDGE_REG_MBOX_ARM1 as FW to Host mailbox.
+*/
+
+// Address where the command parameters are written.
+#define DDRADDR_4_FWCMDS		0x100
+
+//
+// mailbox used for passing the FW Command address (DDR address) to
+// firmware.
+//
+#define FW_CMD_POST_MBOX		BCHP_ARMCR4_BRIDGE_REG_MBOX_ARM1
+
+// Once we get a firmware command done interrupt,
+// we will need to get the address of the response.
+// This mailbox is written by FW before asserting the
+// firmware command done interrupt.
+#define FW_CMD_RES_MBOX			BCHP_ARMCR4_BRIDGE_REG_MBOX_PCI1
+
+/*
+-- RxDMA Picture QStatus Mailbox.
+-- RxDMA Picture Post Mailbox. < Write DDR address to this mailbox >
+ */
+#define RX_DMA_PIC_QSTS_MBOX		BCHP_ARMCR4_BRIDGE_REG_MBOX_PCI2
+#define RX_POST_MAILBOX				BCHP_ARMCR4_BRIDGE_REG_MBOX_ARM2
+#define RX_POST_CONFIRM_SCRATCH		BCHP_ARMCR4_BRIDGE_REG_SCRATCH_5
+#define RX_START_SEQ_NUMBER			1
+#define INDICATE_TX_DONE_REG		BCHP_ARMCR4_BRIDGE_REG_SCRATCH_9
+
+/*
+-- At the end of the picture frame there is the Link's Y0 data
+-- and there is Width data. The driver will copy this 32 bit data to Y[0]
+-- location. This makes the Flea PIB compatible with Link.
+-- Also note that Flea is capable of putting out the odd size picture widths
+-- so the PicWidth field is the actual picture width of the picture. In link
+-- We were only getting 1920,1280 or 720 as picture widths.
+*/
+#define PIC_PIB_DATA_OFFSET_FROM_END	4
+#define PIC_PIB_DATA_SIZE_IN_BYTES		4	//The data that use to be in Y[0] component
+#define PIC_WIDTH_OFFSET_FROM_END		8	//Width information for the driver.
+#define PIC_WIDTH_DATA_SIZE_IN_BYTES	4	//Width information for the driver.
+
+/*
+-- The format change PIB comes in a dummy frame now.
+-- The Width field has the format change flag (bit-31) which
+-- the driver uses to detect the format change now.
+*/
+#define PIB_FORMAT_CHANGE_BIT			BC_BIT(31)
+#define PIB_EOS_DETECTED_BIT			BC_BIT(30)
+
+#define FLEA_DECODE_ERROR_FLAG			0x800
+
+/*
+-- Interrupt Mask, Set and Clear registers are exactly
+-- same as the interrupt status register. We will
+-- Use the following union for all the registers.
+*/
+typedef
+union
+_FLEA_INTR_BITS_COMMON_
+{
+	struct
+	{
+		uint32_t	L0TxDMADone:1;		// Bit-0
+		uint32_t	L0TxDMAErr:1;		// Bit-1
+		uint32_t	L0YRxDMADone:1;		// Bit-2
+		uint32_t	L0YRxDMAErr:1;		// Bit-3
+		uint32_t	L0UVRxDMADone:1;	// Bit-4
+		uint32_t	L0UVRxDMAErr:1;		// Bit-5
+		uint32_t	Reserved1:2;		// Bit-6-7
+		uint32_t	L1TxDMADone:1;		// Bit-8
+		uint32_t	L1TxDMAErr:1;		// Bit-9
+		uint32_t	L1YRxDMADone:1;		// Bit-10
+		uint32_t	L1YRxDMAErr:1;		// Bit-11
+		uint32_t	L1UVRxDMADone:1;	// Bit-12
+		uint32_t	L1UVRxDMAErr:1;		// Bit-13
+		uint32_t	Reserved2:2;		// Bit-14-15
+		uint32_t	ArmMbox0Int:1;		// Bit-16
+		uint32_t	ArmMbox1Int:1;		// Bit-17
+		uint32_t	ArmMbox2Int:1;		// Bit-18
+		uint32_t	ArmMbox3Int:1;		// Bit-19
+		uint32_t	Reserved3:4;		// Bit-20-23
+		uint32_t	PcieTgtUrAttn:1;	// Bit-24
+		uint32_t	PcieTgtCaAttn:1;	// Bit-25
+		uint32_t 	HaltIntr:1;			// Bit-26
+		uint32_t	Reserved4:5;			// Bit-27-31
+	};
+
+	 uint32_t	WholeReg;
+}FLEA_INTR_BITS_COMMON;
+
+typedef FLEA_INTR_BITS_COMMON FLEA_INTR_STS_REG;
+typedef FLEA_INTR_BITS_COMMON FLEA_MASK_REG;
+
+/*
+================================================================
+-- Flea power state machine
+-- FLEA_PS_NONE
+--	Enter to this state when system boots up and device is not open.
+-- FLEA_PS_ACTIVE:
+--	1. Set when the device is started and FW downloaded.
+--	2. We come to this state from FLEA_PS_LP_COMPLETE when
+--		2.a Free list length becomes greater than X. [Same As Internal Pause Sequence]
+--		2.b There is a firmware command issued.
+--  3. We come to this state from FLEA_PS_LP_PENDING when
+--		3.a Free list length becomes greater than X. [Same As Internal Pause Sequence]
+--		3.b There is a firmware command Issued.
+-- FLEA_PS_LP_PENDING
+--	1. Enter to this state from FLEA_PS_ACTIVE
+--		1.a FLL becomes greater less than Y[Same as Internal Resume].
+-- FLEA_PS_LP_COMPLETE
+--	1. Enter in to this state from FLEA_PS_LP_PENDING
+--		1.a There are no Pending TX, RX, and FW Command.
+--	2. Enter to This state when the handle is closed.
+--  3. Enter to this state From ACTIVE
+--		3.a FLL < Y.
+--		3.b There is no TX,RX and FW pending.
+--  4. Enter this state when RX is not running, either before it is started or after it is stopped.
+=================================================================
+*/
+typedef
+enum
+_FLEA_POWER_STATES_
+{
+	FLEA_PS_NONE=0,
+	FLEA_PS_STOPPED,
+	FLEA_PS_ACTIVE,
+	FLEA_PS_LP_PENDING,
+	FLEA_PS_LP_COMPLETE
+}FLEA_POWER_STATES;
+
+typedef enum _FLEA_STATE_CH_EVENT_
+{
+	FLEA_EVT_NONE=0,
+	FLEA_EVT_START_DEVICE,
+	FLEA_EVT_STOP_DEVICE,
+	FLEA_EVT_FLL_CHANGE,
+	FLEA_EVT_FW_CMD_POST,
+	FLEA_EVT_CMD_COMP
+}FLEA_STATE_CH_EVENT;
+
+#define TEST_BIT(_value_,_bit_number_)	(_value_ & (0x00000001 << _bit_number_))
+
+#define CLEAR_BIT(_value_,_bit_number_)\
+{_value_ = _value_ & (~(0x00000001 << _bit_number_));}
+
+#define SET_BIT(_value_,_bit_number_)\
+{_value_ |=  (0x01 << _bit_number_);}
+
+#endif
+
diff --git a/drivers/staging/chd/Makefile b/drivers/staging/chd/Makefile
new file mode 100644
index 0000000..53026d5
--- /dev/null
+++ b/drivers/staging/chd/Makefile
@@ -0,0 +1,40 @@
+#
+#  Broadcom Crystal HD (BCM970012) controller Makefile.
+#
+#
+KDIR:=$(shell pwd)/../../../../../
+
+INCLUDES  = -I$(KDIR)/include
+INCLUDES += -I$(src)/../../include
+INCLUDES += -I$(src)/../../include/link
+INCLUDES += -I$(src)/../../include/flea
+INCLUDES += -I$(src)/../../include/flea/70015/magnum/basemodules/chp/70015/rdb/a0
+
+EXTRA_CFLAGS   = -D__KERNEL__ -DMODULE $(INCLUDES) $(INC)
+EXTRA_CFLAGS  += -Wall -Wstrict-prototypes -Wno-trigraphs -Werror -O2
+
+OBJ :=	crystalhd_lnx.o \
+	crystalhd_misc.o \
+	crystalhd_cmds.o \
+	crystalhd_hw.o \
+	crystalhd_linkfuncs.o \
+	crystalhd_fleafuncs.o \
+	crystalhd_flea_ddr.o
+
+PWD = $(shell pwd)
+
+obj-m := crystalhd.o
+	crystalhd-objs := $(OBJ)
+
+all:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
+
+clean:
+	rm -f *.map *.list *.o *.ko crystalhd.mod.c $(OBJ)
+
+distclean:
+	rm -f *.map *.list *.o *.ko crystalhd.mod.c $(OBJ)
+	rm -f configure config.status config.log *~*
+	rm -rf autom4te.cache
+	rm -f Makefile
+	rm -f Module.symvers
diff --git a/drivers/staging/chd/Makefile.in b/drivers/staging/chd/Makefile.in
new file mode 100644
index 0000000..bb71a7e
--- /dev/null
+++ b/drivers/staging/chd/Makefile.in
@@ -0,0 +1,48 @@
+#
+#  Broadcom Crystal HD (BCM970012) controller Makefile.
+#
+#
+KDIR = @KERN_DIR@
+
+
+INCLUDES  = -I$(KDIR)/include
+INCLUDES += -I$(src)/../../include
+INCLUDES += -I$(src)/../../include/link
+INCLUDES += -I$(src)/../../include/flea
+INCLUDES += -I$(src)/../../include/flea/70015/magnum/basemodules/chp/70015/rdb/a0
+
+EXTRA_CFLAGS   = -D__KERNEL__ -DMODULE $(INCLUDES) $(INC)
+EXTRA_CFLAGS  += -Wall -Wstrict-prototypes -Wno-trigraphs -Werror -O2
+
+OBJ :=	crystalhd_lnx.o \
+	crystalhd_misc.o \
+	crystalhd_cmds.o \
+	crystalhd_hw.o \
+	crystalhd_linkfuncs.o \
+	crystalhd_fleafuncs.o \
+	crystalhd_flea_ddr.o
+
+PWD = $(shell pwd)
+
+obj-m := crystalhd.o
+	crystalhd-objs := $(OBJ)
+
+all:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
+
+install:
+	if [ -e "/lib/udev/rules.d" ] ; then cp -f 20-crystalhd.rules /lib/udev/rules.d/ ; fi
+	if [ -e "/etc/udev/rules.d" ] ; then cp -f 20-crystalhd.rules /etc/udev/rules.d/ ; fi
+	install -d /lib/modules/$(shell uname -r)/kernel/drivers/video/broadcom
+	install -m 0644 crystalhd.ko /lib/modules/$(shell uname -r)/kernel/drivers/video/broadcom
+	/sbin/depmod -a
+
+clean:
+	rm -f *.map *.list *.o *.ko crystalhd.mod.c $(OBJ)
+
+distclean:
+	rm -f *.map *.list *.o *.ko crystalhd.mod.c $(OBJ)
+	rm -f configure config.status config.log *~*
+	rm -rf autom4te.cache
+	rm -f Makefile
+	rm -f Module.symvers
diff --git a/drivers/staging/chd/bcm_70012_dev.sh b/drivers/staging/chd/bcm_70012_dev.sh
new file mode 100644
index 0000000..a0f2d5c
--- /dev/null
+++ b/drivers/staging/chd/bcm_70012_dev.sh
@@ -0,0 +1,56 @@
+#!/bin/bash
+#
+# Author: Prasad Bolisetty
+#
+# Script to load broadcom 70012 module and create device node.
+# 
+# 
+
+bcm_dev_bin="bcm70012"
+bcm_dev_name="crystalhd"
+bcm_node="/dev/crystalhd"
+
+if  ! whoami | grep root > /dev/null ; then
+	echo " Login as root and try.."	
+	exit 1;
+fi
+
+bcm_pci_id=`lspci -d 14e4:1612`
+if [ $? -ne 0 -o -z "$bcm_pci_id" ]; then
+	echo "BCM 70012 not installed.."
+	exit 1;
+fi
+
+if  lsmod | grep $bcm_dev_bin > /dev/null ; then
+	echo "Stopping Broadcom MediaPC 70012 Module"
+	rmmod $bcm_dev_bin >& /dev/null
+	if [ $? -ne 0 ]; then
+		echo "Failed to stop: Close applications and try again. "
+		exit 1;
+	fi
+fi
+
+bcm_major=`cat /proc/devices | grep "$bcm_dev_name" | cut -c1-3`
+
+if [ -z "$bcm_major" ]; then
+	modinfo $bcm_dev_bin >& /dev/null
+	if [ $? -ne 0 ]; then
+		echo "Broadcom MediaPC 70012 Kernel Module not installed"
+		exit 1;
+	fi
+	modprobe $bcm_dev_bin >& /dev/null
+	bcm_major=`cat /proc/devices | grep "$bcm_dev_name" | cut -c1-3`
+	if [ $? -ne 0 -o -z "$bcm_major" ]; then
+		echo "Error($bcm_major): Loading Broadcom MediaPC 70012 Module"
+		rmmod $bcm_dev_bin >& /dev/null
+		exit 1;
+	fi
+fi
+if [ -c $bcm_node ]; then
+	rm -f $bcm_node >& /dev/null
+fi
+
+mknod -m 666 $bcm_node c $bcm_major 0
+
+echo "Broadcom MediaPC 70012 Module loaded"
+
diff --git a/drivers/staging/chd/bcm_70012_run.sh b/drivers/staging/chd/bcm_70012_run.sh
new file mode 100644
index 0000000..4ed072e
--- /dev/null
+++ b/drivers/staging/chd/bcm_70012_run.sh
@@ -0,0 +1,47 @@
+#!/bin/bash
+#
+# Author: Prasad Bolisetty
+#
+# Script to load broadcom 70012 module and create device node.
+# 
+# 
+
+bcm_dev_bin="crystalhd"
+bcm_dev_bin_ko="crystalhd.ko"
+bcm_dev_name="crystalhd"
+bcm_node="/dev/crystalhd"
+
+if  ! whoami | grep root > /dev/null ; then
+	echo " Login as root and try.."	
+	exit 1;
+fi
+
+
+if  /sbin/lsmod | grep $bcm_dev_bin > /dev/null ; then
+	echo "Stopping Broadcom Crystal HD (BCM70012) Module"
+	/sbin/rmmod $bcm_dev_bin >& /dev/null
+	if [ $? -ne 0 ]; then
+		echo "Failed to stop: Close applications and try again. "
+		exit 1;
+	fi
+fi
+
+bcm_major=`cat /proc/devices | grep "$bcm_dev_name" | cut -c1-3`
+
+if [ -z "$bcm_major" ]; then
+	/sbin/insmod $bcm_dev_bin_ko >& /dev/null
+	bcm_major=`cat /proc/devices | grep "$bcm_dev_name" | cut -c1-3`
+	if [ $? -ne 0 -o -z "$bcm_major" ]; then
+		echo "Error($bcm_major): Loading Broadcom Crystal HD (BCM70012) Module"
+		rmmod $bcm_dev_bin >& /dev/null
+		exit 1;
+	fi
+fi
+if [ -c $bcm_node ]; then
+	rm -f $bcm_node >& /dev/null
+fi
+
+mknod -m 666 $bcm_node c $bcm_major 0
+
+echo "Broadcom Crystal HD (BCM70012) Module loaded"
+
diff --git a/drivers/staging/chd/configure.ac b/drivers/staging/chd/configure.ac
new file mode 100644
index 0000000..5b89da7
--- /dev/null
+++ b/drivers/staging/chd/configure.ac
@@ -0,0 +1,12 @@
+AC_INIT(configure.ac)
+AC_CHECK_TOOL(LD, ld, :)
+
+AC_ARG_WITH(kernel-path, [  --with-kernel-path    Specify kernel path],
+    KERN_DIR=$withval, KERN_DIR="/lib/modules/"$(uname -r)"/build")
+
+
+AC_SUBST(KERN_DIR)
+
+AC_OUTPUT([
+./Makefile
+])
diff --git a/drivers/staging/chd/crystalhd_cmds.c b/drivers/staging/chd/crystalhd_cmds.c
new file mode 100644
index 0000000..d69f5d4
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_cmds.c
@@ -0,0 +1,1156 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_cmds . c
+ *
+ *  Description:
+ *		BCM70012/BCM70015 Linux driver user command interfaces.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include "crystalhd_lnx.h"
+
+static struct crystalhd_user *bc_cproc_get_uid(struct crystalhd_cmd *ctx)
+{
+	struct crystalhd_user *user = NULL;
+	int i;
+
+	for (i = 0; i < BC_LINK_MAX_OPENS; i++) {
+		if (!ctx->user[i].in_use) {
+			user = &ctx->user[i];
+			break;
+		}
+	}
+
+	return user;
+}
+
+static int bc_cproc_get_user_count(struct crystalhd_cmd *ctx)
+{
+	int i, count = 0;
+
+	for (i = 0; i < BC_LINK_MAX_OPENS; i++) {
+		if (ctx->user[i].in_use)
+			count++;
+	}
+
+	return count;
+}
+
+static void bc_cproc_mark_pwr_state(struct crystalhd_cmd *ctx)
+{
+	int i;
+
+	for (i = 0; i < BC_LINK_MAX_OPENS; i++) {
+		if (!ctx->user[i].in_use)
+			continue;
+		if ((ctx->user[i].mode & 0xFF) == DTS_DIAG_MODE ||
+		    (ctx->user[i].mode & 0xFF) == DTS_PLAYBACK_MODE) {
+			ctx->pwr_state_change = 1;
+			break;
+		}
+	}
+}
+
+static BC_STATUS bc_cproc_notify_mode(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	int rc = 0, i = 0;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (ctx->user[idata->u_id].mode != DTS_MODE_INV) {
+		dev_err(dev, "Close the handle first..\n");
+		return BC_STS_ERR_USAGE;
+	}
+
+	if ((idata->udata.u.NotifyMode.Mode && 0xFF) == DTS_MONITOR_MODE) {
+		ctx->user[idata->u_id].mode = idata->udata.u.NotifyMode.Mode;
+		return BC_STS_SUCCESS;
+	}
+
+	if (ctx->state != BC_LINK_INVALID) {
+		dev_err(dev, "Link invalid state notify mode %d \n", ctx->state);
+		return BC_STS_ERR_USAGE;
+	}
+	/* Check for duplicate playback sessions..*/
+	for (i = 0; i < BC_LINK_MAX_OPENS; i++) {
+		if ((ctx->user[i].mode & 0xFF) == DTS_DIAG_MODE ||
+		    (ctx->user[i].mode & 0xFF) == DTS_PLAYBACK_MODE) {
+			dev_err(dev, "multiple playback sessions are not "
+				"supported..\n");
+			return BC_STS_ERR_USAGE;
+		}
+	}
+	ctx->cin_wait_exit = 0;
+
+	ctx->user[idata->u_id].mode = idata->udata.u.NotifyMode.Mode;
+	/* Create list pools */
+	rc = crystalhd_create_elem_pool(ctx->adp, BC_LINK_ELEM_POOL_SZ);
+	if (rc)
+		return BC_STS_ERROR;
+	/* Setup mmap pool for uaddr sgl mapping..*/
+	rc = crystalhd_create_dio_pool(ctx->adp, BC_LINK_MAX_SGLS);
+	if (rc)
+		return BC_STS_ERROR;
+
+	/* Setup Hardware DMA rings */
+	return crystalhd_hw_setup_dma_rings(ctx->hw_ctx);
+}
+
+static BC_STATUS bc_cproc_get_version(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata) {
+		dev_err(chddev(), "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+	idata->udata.u.VerInfo.DriverMajor = crystalhd_kmod_major;
+	idata->udata.u.VerInfo.DriverMinor = crystalhd_kmod_minor;
+	idata->udata.u.VerInfo.DriverRevision	= crystalhd_kmod_rev;
+	return BC_STS_SUCCESS;
+}
+
+
+static BC_STATUS bc_cproc_get_hwtype(struct crystalhd_cmd *ctx, crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata) {
+		dev_err(chddev(), "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	crystalhd_pci_cfg_rd(ctx->adp, 0, 2,
+			   (uint32_t *)&idata->udata.u.hwType.PciVenId);
+	crystalhd_pci_cfg_rd(ctx->adp, 2, 2,
+			   (uint32_t *)&idata->udata.u.hwType.PciDevId);
+	crystalhd_pci_cfg_rd(ctx->adp, 8, 1,
+			   (uint32_t *)&idata->udata.u.hwType.HwRev);
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_reg_rd(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+	idata->udata.u.regAcc.Value = ctx->hw_ctx->pfnReadDevRegister(ctx->adp,
+					idata->udata.u.regAcc.Offset);
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_reg_wr(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+
+	ctx->hw_ctx->pfnWriteDevRegister(ctx->adp, idata->udata.u.regAcc.Offset,
+		      idata->udata.u.regAcc.Value);
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_link_reg_rd(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+
+	idata->udata.u.regAcc.Value = ctx->hw_ctx->pfnReadFPGARegister(ctx->adp,
+					idata->udata.u.regAcc.Offset);
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_link_reg_wr(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+
+	ctx->hw_ctx->pfnWriteFPGARegister(ctx->adp, idata->udata.u.regAcc.Offset,
+		       idata->udata.u.regAcc.Value);
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_mem_rd(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if (!ctx || !idata || !idata->add_cdata)
+		return BC_STS_INV_ARG;
+
+	if (idata->udata.u.devMem.NumDwords > (idata->add_cdata_sz / 4)) {
+		dev_err(chddev(), "insufficient buffer\n");
+		return BC_STS_INV_ARG;
+	}
+	sts = ctx->hw_ctx->pfnDevDRAMRead(ctx->hw_ctx, idata->udata.u.devMem.StartOff,
+			     idata->udata.u.devMem.NumDwords,
+			     (uint32_t *)idata->add_cdata);
+	return sts;
+
+}
+
+static BC_STATUS bc_cproc_mem_wr(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if (!ctx || !idata || !idata->add_cdata)
+		return BC_STS_INV_ARG;
+
+	if (idata->udata.u.devMem.NumDwords > (idata->add_cdata_sz / 4)) {
+		dev_err(chddev(), "insufficient buffer\n");
+		return BC_STS_INV_ARG;
+	}
+
+	sts = ctx->hw_ctx->pfnDevDRAMWrite(ctx->hw_ctx, idata->udata.u.devMem.StartOff,
+			     idata->udata.u.devMem.NumDwords,
+			     (uint32_t *)idata->add_cdata);
+	return sts;
+}
+
+static BC_STATUS bc_cproc_cfg_rd(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	uint32_t ix, cnt, off, len;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	uint32_t *temp;
+
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+
+	temp = (uint32_t *) idata->udata.u.pciCfg.pci_cfg_space;
+	off = idata->udata.u.pciCfg.Offset;
+	len = idata->udata.u.pciCfg.Size;
+
+	if (len <= 4) {
+		sts = crystalhd_pci_cfg_rd(ctx->adp, off, len, temp);
+		return sts;
+	}
+
+	/* Truncate to dword alignment..*/
+	len = 4;
+	cnt = idata->udata.u.pciCfg.Size / len;
+	for (ix = 0; ix < cnt; ix++) {
+		sts = crystalhd_pci_cfg_rd(ctx->adp, off, len, &temp[ix]);
+		if (sts != BC_STS_SUCCESS) {
+			dev_err(chddev(), "config read : %d\n", sts);
+			return sts;
+		}
+		off += len;
+	}
+
+	return sts;
+}
+
+static BC_STATUS bc_cproc_cfg_wr(struct crystalhd_cmd *ctx,
+				 crystalhd_ioctl_data *idata)
+{
+	uint32_t ix, cnt, off, len;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	uint32_t *temp;
+
+	if (!ctx || !idata)
+		return BC_STS_INV_ARG;
+
+	temp = (uint32_t *) idata->udata.u.pciCfg.pci_cfg_space;
+	off = idata->udata.u.pciCfg.Offset;
+	len = idata->udata.u.pciCfg.Size;
+
+	if (len <= 4)
+		return crystalhd_pci_cfg_wr(ctx->adp, off, len, temp[0]);
+
+	/* Truncate to dword alignment..*/
+	len = 4;
+	cnt = idata->udata.u.pciCfg.Size / len;
+	for (ix = 0; ix < cnt; ix++) {
+		sts = crystalhd_pci_cfg_wr(ctx->adp, off, len, temp[ix]);
+		if (sts != BC_STS_SUCCESS) {
+			dev_err(chddev(), "config write : %d\n", sts);
+			return sts;
+		}
+		off += len;
+	}
+
+	return sts;
+}
+
+static BC_STATUS bc_cproc_download_fw(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	dev_dbg(chddev(), "Downloading FW\n");
+
+	if (!ctx || !idata || !idata->add_cdata || !idata->add_cdata_sz) {
+		dev_err(chddev(), "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (ctx->state != BC_LINK_INVALID) {
+		dev_err(chddev(), "Link invalid state download fw %d \n", ctx->state);
+		return BC_STS_ERR_USAGE;
+	}
+
+	sts = ctx->hw_ctx->pfnFWDwnld(ctx->hw_ctx, (uint8_t *)idata->add_cdata,
+				  idata->add_cdata_sz);
+
+	if (sts != BC_STS_SUCCESS) {
+		dev_info(chddev(), "Firmware Download Failure!! - %d\n", sts);
+	} else
+		ctx->state |= BC_LINK_INIT;
+
+	ctx->hw_ctx->FwCmdCnt = 0;
+	return sts;
+}
+
+/*
+ * We use the FW_CMD interface to sync up playback state with application
+ * and  firmware. This function will perform the required pre and post
+ * processing of the Firmware commands.
+ *
+ * Pause -
+ *	Disable capture after decoder pause.
+ * Resume -
+ *	First enable capture and issue decoder resume command.
+ * Flush -
+ *	Abort pending input transfers and issue decoder flush command.
+ *
+ */
+static BC_STATUS bc_cproc_do_fw_cmd(struct crystalhd_cmd *ctx, crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	BC_STATUS sts;
+	uint32_t *cmd;
+
+	if (!(ctx->state & BC_LINK_INIT)) {
+		dev_err(dev, "Link invalid state do fw cmd %d \n", ctx->state);
+		return BC_STS_ERR_USAGE;
+	}
+
+	cmd = idata->udata.u.fwCmd.cmd;
+
+	/* Pre-Process */
+	if (cmd[0] == eCMD_C011_DEC_CHAN_PAUSE) {
+		if (!cmd[3]) {
+			ctx->state &= ~BC_LINK_PAUSED;
+			ctx->hw_ctx->pfnIssuePause(ctx->hw_ctx, false);
+		}
+	} else if (cmd[0] == eCMD_C011_DEC_CHAN_FLUSH) {
+		dev_dbg(dev, "Flush issued\n");
+		if (cmd[3])
+			ctx->cin_wait_exit = 1;
+	}
+
+	sts = ctx->hw_ctx->pfnDoFirmwareCmd(ctx->hw_ctx, &idata->udata.u.fwCmd);
+
+	if (sts != BC_STS_SUCCESS) {
+		dev_info(dev, "fw cmd %x failed\n", cmd[0]);
+		return sts;
+	}
+
+	/* Post-Process */
+	if (cmd[0] == eCMD_C011_DEC_CHAN_PAUSE) {
+		if (cmd[3]) {
+			ctx->state |= BC_LINK_PAUSED;
+			ctx->hw_ctx->pfnIssuePause(ctx->hw_ctx, true);
+		}
+	}
+
+	return sts;
+}
+
+static void bc_proc_in_completion(crystalhd_dio_req *dio_hnd,
+				  wait_queue_head_t *event, BC_STATUS sts)
+{
+	if (!dio_hnd || !event) {
+		dev_err(chddev(), "%s: Invalid Arg\n", __func__);
+		return;
+	}
+	if (sts == BC_STS_IO_USER_ABORT)
+		 return;
+
+	dio_hnd->uinfo.comp_sts = sts;
+	dio_hnd->uinfo.ev_sts = 1;
+	crystalhd_set_event(event);
+}
+
+static BC_STATUS bc_cproc_codein_sleep(struct crystalhd_cmd *ctx)
+{
+	wait_queue_head_t sleep_ev;
+	int rc = 0;
+
+	if (ctx->state & BC_LINK_SUSPEND)
+		return BC_STS_IO_USER_ABORT;
+
+	if (ctx->cin_wait_exit) {
+		ctx->cin_wait_exit = 0;
+		return BC_STS_CMD_CANCELLED;
+	}
+	crystalhd_create_event(&sleep_ev);
+	crystalhd_wait_on_event(&sleep_ev, 0, 100, rc, false);
+	if (rc == -EINTR)
+		return BC_STS_IO_USER_ABORT;
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_hw_txdma(struct crystalhd_cmd *ctx,
+				   crystalhd_ioctl_data *idata,
+				   crystalhd_dio_req *dio)
+{
+	struct device *dev = chddev();
+	uint32_t tx_listid = 0;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	wait_queue_head_t event;
+	int rc = 0;
+
+	if (!ctx || !idata || !dio) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	crystalhd_create_event(&event);
+
+	ctx->tx_list_id = 0;
+	/* msleep_interruptible(2000); */
+	sts = crystalhd_hw_post_tx(ctx->hw_ctx, dio, bc_proc_in_completion,
+				 &event, &tx_listid,
+				 idata->udata.u.ProcInput.Encrypted);
+
+	while (sts == BC_STS_BUSY) {
+		sts = bc_cproc_codein_sleep(ctx);
+		if (sts != BC_STS_SUCCESS)
+			break;
+		sts = crystalhd_hw_post_tx(ctx->hw_ctx, dio,
+					 bc_proc_in_completion,
+					 &event, &tx_listid,
+					 idata->udata.u.ProcInput.Encrypted);
+	}
+	if (sts != BC_STS_SUCCESS) {
+		dev_dbg(dev, "_hw_txdma returning sts:%d\n", sts);
+		return sts;
+	}
+	if (ctx->cin_wait_exit)
+		ctx->cin_wait_exit = 0;
+
+	ctx->tx_list_id = tx_listid;
+
+	/* _post() succeeded.. wait for the completion. */
+	crystalhd_wait_on_event(&event, (dio->uinfo.ev_sts), 3000, rc, false);
+	ctx->tx_list_id = 0;
+	if (!rc) {
+		return dio->uinfo.comp_sts;
+	} else if (rc == -EBUSY) {
+		dev_dbg(dev, "_tx_post() T/O \n");
+		sts = BC_STS_TIMEOUT;
+	} else if (rc == -EINTR) {
+		dev_dbg(dev, "Tx Wait Signal int.\n");
+		sts = BC_STS_IO_USER_ABORT;
+	} else {
+		sts = BC_STS_IO_ERROR;
+	}
+
+	/* We are cancelling the IO from the same context as the _post().
+	 * so no need to wait on the event again.. the return itself
+	 * ensures the release of our resources.
+	 */
+	crystalhd_hw_cancel_tx(ctx->hw_ctx, tx_listid);
+
+	return sts;
+}
+
+/* Helper function to check on user buffers */
+static BC_STATUS bc_cproc_check_inbuffs(bool pin, void *ubuff, uint32_t ub_sz,
+					uint32_t uv_off, bool en_422)
+{
+	struct device *dev = chddev();
+	if (!ubuff || !ub_sz) {
+		dev_err(dev, "%s->Invalid Arg %p %x\n",
+			((pin) ? "TX" : "RX"), ubuff, ub_sz);
+		return BC_STS_INV_ARG;
+	}
+
+	/* Check for alignment */
+	if (((uintptr_t)ubuff) & 0x03) {
+		dev_err(dev, "%s-->Un-aligned address not implemented yet.. %p \n",
+				((pin) ? "TX" : "RX"), ubuff);
+		return BC_STS_NOT_IMPL;
+	}
+	if (pin)
+		return BC_STS_SUCCESS;
+
+	if (!en_422 && !uv_off) {
+		dev_err(dev, "Need UV offset for 420 mode.\n");
+		return BC_STS_INV_ARG;
+	}
+
+	if (en_422 && uv_off) {
+		dev_err(dev, "UV offset in 422 mode ??\n");
+		return BC_STS_INV_ARG;
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_proc_input(struct crystalhd_cmd *ctx, crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	void *ubuff;
+	uint32_t ub_sz;
+	crystalhd_dio_req *dio_hnd = NULL;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	ubuff = idata->udata.u.ProcInput.pDmaBuff;
+	ub_sz = idata->udata.u.ProcInput.BuffSz;
+
+	sts = bc_cproc_check_inbuffs(1, ubuff, ub_sz, 0, 0);
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	sts = crystalhd_map_dio(ctx->adp, ubuff, ub_sz, 0, 0, 1, &dio_hnd);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "dio map - %d \n", sts);
+		return sts;
+	}
+
+	if (!dio_hnd)
+		return BC_STS_ERROR;
+
+	sts = bc_cproc_hw_txdma(ctx, idata, dio_hnd);
+
+	crystalhd_unmap_dio(ctx->adp, dio_hnd);
+
+	return sts;
+}
+
+static BC_STATUS bc_cproc_add_cap_buff(struct crystalhd_cmd *ctx,
+				       crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	void *ubuff;
+	uint32_t ub_sz, uv_off;
+	bool en_422;
+	crystalhd_dio_req *dio_hnd = NULL;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	ubuff = idata->udata.u.RxBuffs.YuvBuff;
+	ub_sz = idata->udata.u.RxBuffs.YuvBuffSz;
+	uv_off = idata->udata.u.RxBuffs.UVbuffOffset;
+	en_422 = idata->udata.u.RxBuffs.b422Mode;
+
+	sts = bc_cproc_check_inbuffs(0, ubuff, ub_sz, uv_off, en_422);
+
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	sts = crystalhd_map_dio(ctx->adp, ubuff, ub_sz, uv_off,
+			      en_422, 0, &dio_hnd);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "dio map - %d \n", sts);
+		return sts;
+	}
+
+	if (!dio_hnd)
+		return BC_STS_ERROR;
+
+	sts = crystalhd_hw_add_cap_buffer(ctx->hw_ctx, dio_hnd, (ctx->state == BC_LINK_READY));
+	if ((sts != BC_STS_SUCCESS) && (sts != BC_STS_BUSY)) {
+		crystalhd_unmap_dio(ctx->adp, dio_hnd);
+		return sts;
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_fmt_change(struct crystalhd_cmd *ctx,
+				     crystalhd_dio_req *dio)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	sts = crystalhd_hw_add_cap_buffer(ctx->hw_ctx, dio, 0);
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	ctx->state |= BC_LINK_FMT_CHG;
+	if (ctx->state == BC_LINK_READY)
+		sts = crystalhd_hw_start_capture(ctx->hw_ctx);
+
+	return sts;
+}
+
+static BC_STATUS bc_cproc_fetch_frame(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	crystalhd_dio_req *dio = NULL;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	BC_DEC_OUT_BUFF *frame;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (!(ctx->state & BC_LINK_CAP_EN)) {
+		dev_dbg(dev, "Capture not enabled..%x\n", ctx->state);
+		return BC_STS_ERR_USAGE;
+	}
+
+	frame = &idata->udata.u.DecOutData;
+
+	sts = crystalhd_hw_get_cap_buffer(ctx->hw_ctx, &frame->PibInfo, &dio);
+	if (sts != BC_STS_SUCCESS)
+		return (ctx->state & BC_LINK_SUSPEND) ? BC_STS_IO_USER_ABORT : sts;
+
+	frame->Flags = dio->uinfo.comp_flags;
+
+	if (frame->Flags & COMP_FLAG_FMT_CHANGE)
+		return bc_cproc_fmt_change(ctx, dio);
+
+	frame->OutPutBuffs.YuvBuff = dio->uinfo.xfr_buff;
+	frame->OutPutBuffs.YuvBuffSz = dio->uinfo.xfr_len;
+	frame->OutPutBuffs.UVbuffOffset = dio->uinfo.uv_offset;
+	frame->OutPutBuffs.b422Mode = dio->uinfo.b422mode;
+
+	frame->OutPutBuffs.YBuffDoneSz = dio->uinfo.y_done_sz;
+	frame->OutPutBuffs.UVBuffDoneSz = dio->uinfo.uv_done_sz;
+
+	crystalhd_unmap_dio(ctx->adp, dio);
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_start_capture(struct crystalhd_cmd *ctx,
+					crystalhd_ioctl_data *idata)
+{
+	ctx->state |= BC_LINK_CAP_EN;
+
+	if( idata->udata.u.RxCap.PauseThsh )
+		ctx->hw_ctx->PauseThreshold = idata->udata.u.RxCap.PauseThsh;
+	else
+		ctx->hw_ctx->PauseThreshold = HW_PAUSE_THRESHOLD;
+
+	if( idata->udata.u.RxCap.ResumeThsh )
+		ctx->hw_ctx->ResumeThreshold = idata->udata.u.RxCap.ResumeThsh;
+	else
+		ctx->hw_ctx->ResumeThreshold = HW_RESUME_THRESHOLD;
+
+	printk(KERN_DEBUG "start_capture: pause_th:%d, resume_th:%d\n", ctx->hw_ctx->PauseThreshold, ctx->hw_ctx->ResumeThreshold);
+
+	ctx->hw_ctx->DrvTotalFrmCaptured = 0;
+
+	ctx->hw_ctx->DefaultPauseThreshold = ctx->hw_ctx->PauseThreshold; // used to restore on FMTCH
+
+	ctx->hw_ctx->pfnNotifyHardware(ctx->hw_ctx, BC_EVENT_START_CAPTURE);
+
+	if (ctx->state == BC_LINK_READY)
+		return crystalhd_hw_start_capture(ctx->hw_ctx);
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_flush_cap_buffs(struct crystalhd_cmd *ctx,
+					  crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	crystalhd_rx_dma_pkt *rpkt;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (!(ctx->state & BC_LINK_CAP_EN))
+		return BC_STS_ERR_USAGE;
+
+	/* We should ack flush even when we are in paused/suspend state */
+// 	if (!(ctx->state & BC_LINK_READY))
+// 		return crystalhd_hw_stop_capture(&ctx->hw_ctx);
+
+	dev_dbg(dev, "number of rx success %u and failure %u\n", ctx->hw_ctx->stats.rx_success, ctx->hw_ctx->stats.rx_errors);
+	if(idata->udata.u.FlushRxCap.bDiscardOnly) {
+		// just flush without unmapping and then resume
+		crystalhd_hw_stop_capture(ctx->hw_ctx, false);
+		while((rpkt = crystalhd_dioq_fetch(ctx->hw_ctx->rx_actq)) != NULL)
+			crystalhd_dioq_add(ctx->hw_ctx->rx_freeq, rpkt, false, rpkt->pkt_tag);
+
+		while((rpkt = crystalhd_dioq_fetch(ctx->hw_ctx->rx_rdyq)) != NULL)
+			crystalhd_dioq_add(ctx->hw_ctx->rx_freeq, rpkt, false, rpkt->pkt_tag);
+		crystalhd_hw_start_capture(ctx->hw_ctx);
+	} else {
+		ctx->state &= ~(BC_LINK_CAP_EN|BC_LINK_FMT_CHG);
+		crystalhd_hw_stop_capture(ctx->hw_ctx, true);
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_get_stats(struct crystalhd_cmd *ctx,
+				    crystalhd_ioctl_data *idata)
+{
+	BC_DTS_STATS *stats;
+	struct crystalhd_hw_stats	hw_stats;
+	uint32_t pic_width;
+	uint8_t flags = 0;
+	bool readTxOnly = false;
+	unsigned long irqflags;
+
+	if (!ctx || !idata) {
+		dev_err(chddev(), "%s: Invalid Arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	crystalhd_hw_stats(ctx->hw_ctx, &hw_stats);
+
+	stats = &idata->udata.u.drvStat;
+	stats->drvRLL = hw_stats.rdyq_count;
+	stats->drvFLL = hw_stats.freeq_count;
+	stats->DrvTotalFrmDropped = hw_stats.rx_errors;
+	stats->DrvTotalHWErrs = hw_stats.rx_errors + hw_stats.tx_errors;
+	stats->intCount = hw_stats.num_interrupts;
+	stats->DrvIgnIntrCnt = hw_stats.num_interrupts -
+				hw_stats.dev_interrupts;
+	stats->TxFifoBsyCnt = hw_stats.cin_busy;
+	stats->pauseCount = hw_stats.pause_cnt;
+
+	/* Indicate that we are checking stats on the input buffer for a single threaded application */
+	/* this will prevent the HW from going to low power because we assume that once we have told the application */
+	/* that we have space in the HW, the app is going to try to DMA. And if we block that DMA, a single threaded application */
+	/* will deadlock */
+	if(stats->DrvNextMDataPLD & BC_BIT(31))
+	{
+		flags |= 0x08;
+		// Also for single threaded applications, check to see if we have reduced the power down
+		// pause threshold to too low and increase it if the RLL is close to the threshold
+/*		if(pDrvStat->drvRLL >= pDevExt->pHwExten->PauseThreshold)
+			pDevExt->pHwExten->PauseThreshold++;
+		PeekNextTS = TRUE;*/
+	}
+
+	/* also indicate that we are just checking stats and not posting */
+	/* This allows multi-threaded applications to be placed into low power state */
+	/* because eveentually the RX thread will wake up the HW when needed */
+	flags |= 0x04;
+
+	if (ctx->pwr_state_change)
+		stats->pwr_state_change = 1;
+	if (ctx->state & BC_LINK_PAUSED)
+		stats->DrvPauseTime = 1;
+
+	// use bit 29 of the input status to indicate that we are trying to read VC1 status
+	// This is important for the BCM70012 which uses a different input queue for VC1
+	if(stats->DrvcpbEmptySize & BC_BIT(29))
+		flags = 0x2;
+	// Bit 30 is used to indicate that we are reading only the TX stats and to not touch the Ready list
+	if(stats->DrvcpbEmptySize & BC_BIT(30))
+		readTxOnly = true;
+
+	spin_lock_irqsave(&ctx->hw_ctx->lock, irqflags);
+	ctx->hw_ctx->pfnCheckInputFIFO(ctx->hw_ctx, 0, &stats->DrvcpbEmptySize,
+				      false, &flags);
+	spin_unlock_irqrestore(&ctx->hw_ctx->lock, irqflags);
+
+	/* status peek ahead to retreive the next decoded frame timestamp */
+//	if (!readTxOnly && stats->drvRLL && (stats->DrvNextMDataPLD & BC_BIT(31))) {
+	if (!readTxOnly && stats->drvRLL) {
+		pic_width = stats->DrvNextMDataPLD & 0xffff;
+		stats->DrvNextMDataPLD = 0;
+		if (pic_width <= 1920) {
+			// get fetch lock to make sure that fetch is not in progress as wel peek
+ 			if(down_interruptible(&ctx->hw_ctx->fetch_sem))
+				goto get_out;
+			if(ctx->hw_ctx->pfnPeekNextDeodedFr(ctx->hw_ctx,&stats->DrvNextMDataPLD, &stats->picNumFlags, pic_width)) {
+				// Check in case we dropped a picture here
+				crystalhd_hw_stats(ctx->hw_ctx, &hw_stats);
+				stats->drvRLL = hw_stats.rdyq_count;
+				stats->drvFLL = hw_stats.freeq_count;
+			}
+			up(&ctx->hw_ctx->fetch_sem);
+		}
+	}
+
+get_out:
+	return BC_STS_SUCCESS;
+}
+
+static BC_STATUS bc_cproc_reset_stats(struct crystalhd_cmd *ctx,
+				      crystalhd_ioctl_data *idata)
+{
+	crystalhd_hw_stats(ctx->hw_ctx, NULL);
+
+	return BC_STS_SUCCESS;
+}
+
+/*=============== Cmd Proc Table.. ======================================*/
+static const crystalhd_cmd_tbl_t	g_crystalhd_cproc_tbl[] = {
+	{ BCM_IOC_GET_VERSION,		bc_cproc_get_version,	0},
+	{ BCM_IOC_GET_HWTYPE,		bc_cproc_get_hwtype,	0},
+	{ BCM_IOC_REG_RD,			bc_cproc_reg_rd,	0},
+	{ BCM_IOC_REG_WR,			bc_cproc_reg_wr,	0},
+	{ BCM_IOC_FPGA_RD,			bc_cproc_link_reg_rd,	0},
+	{ BCM_IOC_FPGA_WR,			bc_cproc_link_reg_wr,	0},
+	{ BCM_IOC_MEM_RD,			bc_cproc_mem_rd,	0},
+	{ BCM_IOC_MEM_WR,			bc_cproc_mem_wr,	0},
+	{ BCM_IOC_RD_PCI_CFG,		bc_cproc_cfg_rd,	0},
+	{ BCM_IOC_WR_PCI_CFG,		bc_cproc_cfg_wr,	1},
+	{ BCM_IOC_FW_DOWNLOAD,		bc_cproc_download_fw,	1},
+	{ BCM_IOC_FW_CMD,			bc_cproc_do_fw_cmd,	1},
+	{ BCM_IOC_PROC_INPUT,		bc_cproc_proc_input,	1},
+	{ BCM_IOC_ADD_RXBUFFS,		bc_cproc_add_cap_buff,	1},
+	{ BCM_IOC_FETCH_RXBUFF,		bc_cproc_fetch_frame,	1},
+	{ BCM_IOC_START_RX_CAP,		bc_cproc_start_capture,	1},
+	{ BCM_IOC_FLUSH_RX_CAP,		bc_cproc_flush_cap_buffs, 1},
+	{ BCM_IOC_GET_DRV_STAT,		bc_cproc_get_stats,	0},
+	{ BCM_IOC_RST_DRV_STAT,		bc_cproc_reset_stats,	0},
+	{ BCM_IOC_NOTIFY_MODE,		bc_cproc_notify_mode,	0},
+	{ BCM_IOC_END,				NULL},
+};
+
+/*=============== Cmd Proc Functions.. ===================================*/
+
+/**
+ * crystalhd_suspend - Power management suspend request.
+ * @ctx: Command layer context.
+ * @idata: Iodata - required for internal use.
+ *
+ * Return:
+ *	status
+ *
+ * 1. Set the state to Suspend.
+ * 2. Flush the Rx Buffers it will unmap all the buffers and
+ *    stop the RxDMA engine.
+ * 3. Cancel The TX Io and Stop Dma Engine.
+ * 4. Put the DDR in to deep sleep.
+ * 5. Stop the hardware putting it in to Reset State.
+ *
+ * Current gstreamer frame work does not provide any power management
+ * related notification to user mode decoder plug-in. As a work-around
+ * we pass on the power mangement notification to our plug-in by completing
+ * all outstanding requests with BC_STS_IO_USER_ABORT return code.
+ */
+BC_STATUS crystalhd_suspend(struct crystalhd_cmd *ctx, crystalhd_ioctl_data *idata)
+{
+	struct device *dev = chddev();
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if (!ctx || !idata) {
+		dev_err(dev, "Invalid Parameters\n");
+		return BC_STS_ERROR;
+	}
+
+	if (ctx->state & BC_LINK_SUSPEND)
+		return BC_STS_SUCCESS;
+
+	if (ctx->state == BC_LINK_INVALID) {
+		dev_dbg(dev, "Nothing To Do Suspend Success\n");
+		return BC_STS_SUCCESS;
+	}
+
+	ctx->state |= BC_LINK_SUSPEND;
+
+	bc_cproc_mark_pwr_state(ctx);
+
+	if (ctx->state & BC_LINK_CAP_EN) {
+		idata->udata.u.FlushRxCap.bDiscardOnly = true;
+		sts = bc_cproc_flush_cap_buffs(ctx, idata);
+		if (sts != BC_STS_SUCCESS)
+			return sts;
+	}
+
+	if (ctx->tx_list_id) {
+		sts = crystalhd_hw_cancel_tx(ctx->hw_ctx, ctx->tx_list_id);
+		if (sts != BC_STS_SUCCESS)
+			return sts;
+	}
+
+	sts = crystalhd_hw_suspend(ctx->hw_ctx);
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	dev_info(dev, "Crystal HD suspend success\n");
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_resume - Resume frame capture.
+ * @ctx: Command layer contextx.
+ *
+ * Return:
+ *	status
+ *
+ *
+ * Resume frame capture.
+ *
+ * PM_Resume can't resume the playback state back to pre-suspend state
+ * because we don't keep video clip related information within driver.
+ * To get back to the pre-suspend state App will re-open the device and
+ * start a new playback session from the pre-suspend clip position.
+ *
+ */
+BC_STATUS crystalhd_resume(struct crystalhd_cmd *ctx)
+{
+	dev_info(chddev(), "crystalhd_resume Success %x\n", ctx->state);
+
+	bc_cproc_mark_pwr_state(ctx);
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_user_open - Create application handle.
+ * @ctx: Command layer contextx.
+ * @user_ctx: User ID context.
+ *
+ * Return:
+ *	status
+ *
+ * Creates an application specific UID and allocates
+ * application specific resources. HW layer initialization
+ * is done for the first open request.
+ */
+BC_STATUS crystalhd_user_open(struct crystalhd_cmd *ctx,
+			      struct crystalhd_user **user_ctx)
+{
+	struct device *dev = chddev();
+	struct crystalhd_user *uc;
+
+	if (!ctx || !user_ctx) {
+		dev_err(dev, "Invalid arg..\n");
+		return BC_STS_INV_ARG;
+	}
+
+	uc = bc_cproc_get_uid(ctx);
+	if (!uc) {
+		dev_info(dev, "No free user context...\n");
+		return BC_STS_BUSY;
+	}
+
+	dev_info(dev, "Opening new user[%x] handle\n", uc->uid);
+
+	uc->mode = DTS_MODE_INV;
+	uc->in_use = 0;
+
+	if(ctx->hw_ctx == NULL) {
+		ctx->hw_ctx = (struct crystalhd_hw*)kmalloc(sizeof(struct crystalhd_hw), GFP_KERNEL);
+		if(ctx->hw_ctx != NULL)
+			memset(ctx->hw_ctx, 0, sizeof(struct crystalhd_hw));
+		else
+			return BC_STS_ERROR;
+
+		crystalhd_hw_open(ctx->hw_ctx, ctx->adp);
+	}
+
+	uc->in_use = 1;
+
+	*user_ctx = uc;
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_user_close - Close application handle.
+ * @ctx: Command layer contextx.
+ * @uc: User ID context.
+ *
+ * Return:
+ *	status
+ *
+ * Closer aplication handle and release app specific
+ * resources.
+ */
+BC_STATUS crystalhd_user_close(struct crystalhd_cmd *ctx, struct crystalhd_user *uc)
+{
+	uint32_t mode = uc->mode;
+
+	ctx->user[uc->uid].mode = DTS_MODE_INV;
+	ctx->user[uc->uid].in_use = 0;
+
+	dev_info(chddev(), "Closing user[%x] handle with mode %x\n", uc->uid, mode);
+
+	if (((mode & 0xFF) == DTS_DIAG_MODE) ||
+		((mode & 0xFF) == DTS_PLAYBACK_MODE) ||
+		((bc_cproc_get_user_count(ctx) == 0) && (ctx->hw_ctx != NULL))) {
+		ctx->cin_wait_exit = 1;
+		ctx->pwr_state_change = 0;
+		// Stop the HW Capture just in case flush did not get called before stop
+		crystalhd_hw_stop_capture(ctx->hw_ctx, true);
+		crystalhd_hw_free_dma_rings(ctx->hw_ctx);
+		crystalhd_destroy_dio_pool(ctx->adp);
+		crystalhd_delete_elem_pool(ctx->adp);
+		ctx->state = BC_LINK_INVALID;
+		crystalhd_hw_close(ctx->hw_ctx, ctx->adp);
+		kfree(ctx->hw_ctx);
+		ctx->hw_ctx = NULL;
+	} /*else if (bc_cproc_get_user_count(ctx)) {
+		return BC_STS_SUCCESS;
+	}*/
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_setup_cmd_context - Setup Command layer resources.
+ * @ctx: Command layer contextx.
+ * @adp: Adapter context
+ *
+ * Return:
+ *	status
+ *
+ * Called at the time of driver load.
+ */
+BC_STATUS crystalhd_setup_cmd_context(struct crystalhd_cmd *ctx,
+				    struct crystalhd_adp *adp)
+{
+	struct device *dev = &adp->pdev->dev;
+	int i = 0;
+
+	if (!ctx || !adp) {
+		dev_err(dev, "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (ctx->adp)
+		dev_dbg(dev, "Resetting Cmd context delete missing..\n");
+
+	ctx->adp = adp;
+	for (i = 0; i < BC_LINK_MAX_OPENS; i++) {
+		ctx->user[i].uid = i;
+		ctx->user[i].in_use = 0;
+		ctx->user[i].mode = DTS_MODE_INV;
+	}
+
+	ctx->hw_ctx = (struct crystalhd_hw*)kmalloc(sizeof(struct crystalhd_hw), GFP_KERNEL);
+
+	memset(ctx->hw_ctx, 0, sizeof(struct crystalhd_hw));
+
+	/*Open and Close the Hardware to put it in to sleep state*/
+	crystalhd_hw_open(ctx->hw_ctx, ctx->adp);
+	crystalhd_hw_close(ctx->hw_ctx, ctx->adp);
+	kfree(ctx->hw_ctx);
+	ctx->hw_ctx = NULL;
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_delete_cmd_context - Release Command layer resources.
+ * @ctx: Command layer contextx.
+ *
+ * Return:
+ *	status
+ *
+ * Called at the time of driver un-load.
+ */
+BC_STATUS crystalhd_delete_cmd_context(struct crystalhd_cmd *ctx)
+{
+	dev_dbg(chddev(), "Deleting Command context..\n");
+
+	ctx->adp = NULL;
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_get_cmd_proc  - Cproc table lookup.
+ * @ctx: Command layer contextx.
+ * @cmd: IOCTL command code.
+ * @uc: User ID context.
+ *
+ * Return:
+ *	command proc function pointer
+ *
+ * This function checks the process context, application's
+ * mode of operation and returns the function pointer
+ * from the cproc table.
+ */
+crystalhd_cmd_proc crystalhd_get_cmd_proc(struct crystalhd_cmd *ctx, uint32_t cmd,
+				      struct crystalhd_user *uc)
+{
+	struct device *dev = chddev();
+	crystalhd_cmd_proc cproc = NULL;
+	unsigned int i, tbl_sz;
+
+	if (!ctx) {
+		dev_err(dev, "Invalid arg.. Cmd[%d]\n", cmd);
+		return NULL;
+	}
+
+	if ((cmd != BCM_IOC_GET_DRV_STAT) && (ctx->state & BC_LINK_SUSPEND)) {
+		dev_err(dev, "Invalid State [suspend Set].. Cmd[%d]\n", cmd);
+		return NULL;
+	}
+
+	tbl_sz = sizeof(g_crystalhd_cproc_tbl) / sizeof(crystalhd_cmd_tbl_t);
+	for (i = 0; i < tbl_sz; i++) {
+		if (g_crystalhd_cproc_tbl[i].cmd_id == cmd) {
+			if ((uc->mode == DTS_MONITOR_MODE) &&
+			    (g_crystalhd_cproc_tbl[i].block_mon)) {
+				dev_info(dev, "Blocking cmd %d \n", cmd);
+				break;
+			}
+			cproc = g_crystalhd_cproc_tbl[i].cmd_proc;
+			break;
+		}
+	}
+
+	return cproc;
+}
+
+/**
+ * crystalhd_cmd_interrupt - ISR entry point
+ * @ctx: Command layer contextx.
+ *
+ * Return:
+ *	TRUE: If interrupt from CrystalHD device.
+ *
+ *
+ * ISR entry point from OS layer.
+ */
+bool crystalhd_cmd_interrupt(struct crystalhd_cmd *ctx)
+{
+	if (!ctx) {
+		printk(KERN_ERR "%s: Invalid arg..\n", __func__);
+		return false;
+	}
+
+	// If HW has not been initialized then all interrupts are spurious
+	if ((ctx->hw_ctx == NULL) || (ctx->hw_ctx->pfnFindAndClearIntr == NULL))
+		return false;
+
+	return ctx->hw_ctx->pfnFindAndClearIntr(ctx->adp, ctx->hw_ctx);
+}
diff --git a/drivers/staging/chd/crystalhd_cmds.h b/drivers/staging/chd/crystalhd_cmds.h
new file mode 100644
index 0000000..b6d3b3e
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_cmds.h
@@ -0,0 +1,91 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_cmds . h
+ *
+ *  Description:
+ *		BCM70010 Linux driver user command interfaces.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_CMDS_H_
+#define _CRYSTALHD_CMDS_H_
+
+/*
+ * NOTE:: This is the main interface file between the Linux layer
+ *        and the harware layer. This file will use the definitions
+ *        from _dts_glob and dts_defs etc.. which are defined for
+ *        windows.
+ */
+
+#include "crystalhd_hw.h"
+#include "crystalhd_misc.h"
+
+extern struct device * chddev(void);
+
+enum _crystalhd_state{
+	BC_LINK_INVALID		= 0x00,
+	BC_LINK_INIT		= 0x01,
+	BC_LINK_CAP_EN		= 0x02,
+	BC_LINK_FMT_CHG		= 0x04,
+	BC_LINK_SUSPEND		= 0x10,
+	BC_LINK_PAUSED		= 0x20,
+	BC_LINK_READY	= (BC_LINK_INIT | BC_LINK_CAP_EN | BC_LINK_FMT_CHG),
+};
+
+struct crystalhd_user {
+	uint32_t	uid;
+	uint32_t	in_use;
+	uint32_t	mode;
+};
+
+#define DTS_MODE_INV	(-1)
+
+struct crystalhd_cmd {
+	uint32_t		state;
+	struct crystalhd_adp	*adp;
+	struct crystalhd_user	user[BC_LINK_MAX_OPENS];
+
+	spinlock_t		ctx_lock;
+	uint32_t		tx_list_id;
+	uint32_t		cin_wait_exit;
+	uint32_t		pwr_state_change;
+	struct crystalhd_hw		*hw_ctx;
+};
+
+typedef BC_STATUS (*crystalhd_cmd_proc)(struct crystalhd_cmd *, crystalhd_ioctl_data *);
+
+typedef struct _crystalhd_cmd_tbl {
+	uint32_t		cmd_id;
+	const crystalhd_cmd_proc	cmd_proc;
+	uint32_t		block_mon;
+} crystalhd_cmd_tbl_t;
+
+
+BC_STATUS crystalhd_suspend(struct crystalhd_cmd *ctx, crystalhd_ioctl_data *idata);
+BC_STATUS crystalhd_resume(struct crystalhd_cmd *ctx);
+crystalhd_cmd_proc crystalhd_get_cmd_proc(struct crystalhd_cmd *ctx, uint32_t cmd,
+				      struct crystalhd_user *uc);
+BC_STATUS crystalhd_user_open(struct crystalhd_cmd *ctx, struct crystalhd_user **user_ctx);
+BC_STATUS crystalhd_user_close(struct crystalhd_cmd *ctx, struct crystalhd_user *uc);
+BC_STATUS crystalhd_setup_cmd_context(struct crystalhd_cmd *ctx, struct crystalhd_adp *adp);
+BC_STATUS crystalhd_delete_cmd_context(struct crystalhd_cmd *ctx);
+bool crystalhd_cmd_interrupt(struct crystalhd_cmd *ctx);
+
+#endif
diff --git a/drivers/staging/chd/crystalhd_flea_ddr.c b/drivers/staging/chd/crystalhd_flea_ddr.c
new file mode 100644
index 0000000..a5f3657
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_flea_ddr.c
@@ -0,0 +1,735 @@
+/***************************************************************************
+ * Copyright (c) 2005-2010, Broadcom Corporation.
+ *
+ *  Name: crystalhd_flea_ddr . c
+ *
+ *  Description:
+ *		BCM70015 generic DDR routines
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include <linux/delay.h>
+#include "crystalhd_hw.h"
+#include "crystalhd_flea_ddr.h"
+
+//#include "bchp_ddr23_ctl_regs_0.h"
+//#include "bchp_ddr23_phy_byte_lane_0.h"
+//#include "bchp_ddr23_phy_byte_lane_1.h"
+//#include "bchp_ddr23_phy_control_regs.h"
+//#include "bchp_pri_arb_control_regs.h"
+//#include "bchp_pri_client_regs.h"
+
+// RTS Programming Values for all Clients
+//   column legend
+//   [0]: 1=Program, 0=Default;
+//   [1]: Blockout Count;
+//   [2]: Critical Period;
+//   [3]: Priority;
+//   [4]: Access Mode
+// Default mode for clients is best effort
+
+uint32_t rts_prog_vals[21][5] = {
+  {1,    130,    130,      6,      1}, //       Deblock ( 0)
+  {1,   1469,   1469,      9,      1}, //         Cabac ( 1)
+  {1,    251,    251,      4,      1}, //         Iloop ( 2)
+  {1,    842,    842,      5,      1}, //         Oloop ( 3)
+  {1,   1512,   1512,     10,      1}, //      Symb_Int ( 4)
+  {1,     43,     43,     14,      1}, //         Mcomp ( 5)
+  {1,   1318,   1318,     11,      1}, //         XPT_0 ( 6)
+  {1,   4320,   4320,     16,      1}, //         XPT_1 ( 7)
+  {1,   5400,   5400,     17,      0}, //         XPT_2 ( 8)
+  {1,   1080,   1080,     18,      1}, //           ARM ( 9)
+  {1,    691,    691,      7,      0}, //       MEM_DMA (10)
+  {1,   1382,   1382,     15,      0}, //         SHARF (11)
+  {1,    346,    346,      2,      0}, //           BVN (12)
+  {1,   1728,   1728,     13,      1}, //        RxDMA3 (13)
+  {1,    864,    864,      8,      1}, //         TxDMA (14)
+  {1,    173,    173,      3,      1}, //       MetaDMA (15)
+  {1,   2160,   2160,     19,      1}, //     DirectDMA (16)
+  {1,  10800,  10800,     20,      1}, //           MSA (17)
+  {1,    216,    216,      1,      1}, //         TRACE (18)
+  {1,   1598,   1598,     12,      0}, //      refresh1 (19)
+  { 0, 0, 0, 0, 0}, //(20)
+};
+
+void crystalhd_flea_ddr_pll_config(struct crystalhd_hw* hw, int32_t *speed_grade, int32_t num_plls, uint32_t tmode)
+{
+	uint32_t PLL_NDIV_INT[2];
+	uint32_t PLL_M1DIV[2];
+	int32_t  i;
+	uint32_t tmp;
+	uint32_t config;
+	uint32_t timeout;
+	uint32_t skip_init[2];     // completely skip initialization
+	//uint32_t offset[2];
+	uint32_t skip_pll_setup;
+	uint32_t poll_cnt;
+
+	skip_init[0] =  0;
+	skip_init[1] =  0;
+
+	// If the test mode is not 0 then skip the PLL setups too.
+	if (tmode != 0){
+		skip_pll_setup = 1;
+	}
+	else {
+		skip_pll_setup = 0;
+	}
+
+	// Use this scratch register in DDR0 - which should reset to 0 - as a simple symaphore for the test
+	// to monitor if and when the Initialization of the DDR is complete
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_SCRATCH, 0);
+
+	if (!skip_pll_setup) {
+		for(i=0;i<num_plls;i++) {
+			switch(speed_grade[i])
+			{
+				case DDR2_333MHZ: PLL_NDIV_INT[i] = 49; PLL_M1DIV[i] = 2; break;
+				case DDR2_400MHZ: PLL_NDIV_INT[i] = 59; PLL_M1DIV[i] = 2; break;
+				case DDR2_533MHZ: PLL_NDIV_INT[i] = 39; PLL_M1DIV[i] = 1; break;
+				case DDR2_667MHZ: PLL_NDIV_INT[i] = 49; PLL_M1DIV[i] = 1; break;
+				default:
+					printk("Undefined speed_grade of %d\n",speed_grade[i]);
+					break;
+			}
+		}
+
+		////////////////////////////
+		//setup the PLLs
+
+		for(i=0;i<num_plls;i++) {
+			if (skip_init[i]) continue;
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG,
+					  (0 << 0) | //PWRDWN
+					  (0 << 1) | //REFCOMP_PWRDWN
+					  (1 << 2) | //ARESET
+					  (1 << 3) | //DRESET
+					  (0 << 4) | //ENB_CLKOUT
+					  (0 << 5) | //BYPEN ???
+					  (0 << 6) | //PWRDWN_CH1
+					  (0 << 8) | //DLY_CH1
+					  (0 << 10)| //VCO_RNG
+					  (1 << 31)  //DIV2 CLK RESET
+					  );
+
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_PRE_DIVIDER,
+						(1 << 0) | //P1DIV
+						(1 << 4) | //P2DIV
+						(PLL_NDIV_INT[i] << 8) | //NDIV_INT
+						(1 << 24) //BYPASS_SDMOD
+						);
+
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_DIVIDER,
+						(PLL_M1DIV[i] << 24) //M1DIV
+						);
+
+			config = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+			config &= 0xfffffffb; //clear ARESET
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG, config);
+		}
+
+		//poll for lock
+		for(i=0;i<num_plls;i++){
+			if (skip_init[i]) continue;
+			timeout = 10;
+			tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_STATUS);
+			while((timeout>0) && ((tmp & 0x1) == 0)){
+				msleep_interruptible(1);
+				tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_STATUS);
+				timeout--;
+			}
+			if (timeout<=0)
+				printk("Timed out waiting for DDR Controller PLL %d to lock\n",i);
+		}
+
+		//deassert PLL digital reset
+		for(i=0;i<num_plls;i++){
+			if (skip_init[i]) continue;
+			config = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+			config &= 0xfffffff7; //clear DRESET
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG, config);
+		}
+
+		//deassert reset of logic
+		for(i=0;i<num_plls;i++){
+			if (skip_init[i]) continue;
+			config = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+			config &= 0x7fffffff; //clear logic reset
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG, config);
+		}
+	} // end (skip_pll_setup)
+
+	//run VDL calibration for all byte lanes
+	for(i=0;i<num_plls;i++) {
+		if (skip_init[i]) continue;
+		tmp = 0;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_CALIBRATE,tmp);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_CALIBRATE,tmp);
+		tmp = (
+			(1 << 0) | //calib_fast
+			(1 << 1)   //calib_once
+			);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_CALIBRATE,tmp);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_CALIBRATE,tmp);
+
+
+		if (!skip_pll_setup){  //VDLs might not lock if clocks are bypassed
+			timeout=100;
+			tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_STATUS);
+			while((timeout>0) && ((tmp & 0x3) == 0x0)){
+				msleep_interruptible(1);
+				timeout--;
+				tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_STATUS);
+			}
+			if ((tmp & 0x3) != 0x3)
+				printk("VDL calibration did not finish or did not lock!\n");
+			timeout=100;
+			tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_STATUS);
+			while((timeout>0) && ((tmp & 0x3) == 0x0)){
+				msleep_interruptible(1);
+				timeout--;
+				tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_STATUS);
+			}
+			if ((tmp & 0x3) != 0x3)
+				printk("VDL calibration did not finish or did not lock!\n");
+
+			if(timeout<=0){
+				printk("DDR PHY %d VDL Calibration failed\n",i);
+			}
+		}
+		else {
+			msleep_interruptible(1);
+		}
+
+		//clear VDL calib settings
+		tmp = 0;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_CALIBRATE,tmp);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_CALIBRATE,tmp);
+
+		//override the ADDR/CTRL VDLs with results from Bytelane #0
+		//if tmode other than zero then set the VDL compensations to max values of 0x1ff.
+		tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_STATUS);
+		tmp = (tmp >> 4) & 0x3ff;
+		// If in other than tmode 0 then set the VDL override settings to max.
+		if (tmode) {
+			tmp = 0x3ff;
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_OVERRIDE_0, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_OVERRIDE_1, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_OVERRIDE_2, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_VDL_OVERRIDE_3, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_OVERRIDE_0, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_OVERRIDE_1, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_OVERRIDE_2, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_VDL_OVERRIDE_3, 0x1003f);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_UPDATE_VDL, BCHP_DDR23_CTL_REGS_0_UPDATE_VDL_refresh_MASK);
+		}
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_STATIC_VDL_OVERRIDE,
+			(((tmp & 0x3f0) >> 4) << 0) |  // step override value
+			(1 << 16)  |  // override enable
+			(1 << 20)     // override force ; no update vdl required
+			);
+
+		/* NAREN added support for ZQ Calibration */
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL, 0);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL_sample_en_MASK);
+		tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL);
+
+		poll_cnt = 0;
+		while(1)
+		{
+			if(!(tmp & BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL_sample_done_MASK))
+				tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL);
+			else
+				break;
+
+			if(poll_cnt++ > 100)
+				break;
+		}
+
+		if(tmode) {
+			// Set fields addr_ovr_en and dq_pvr_en to '1'.  Set all *_override_val fields to 0xf - ZQ_PVT_COMP_CTL
+			tmp = ( (  1 << 25) |     //  addr_ovr_en
+					(  1 << 24) |     //  dq_ovr_en
+					(0xf << 12) |     // addr_pd_override_val
+					(0xf << 8)  |     // addr_nd_override_val
+					(0xf << 4)  |     // dq_pd_override_val
+					(0xf << 0)  );    // dq_nd_override_val
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_ZQ_PVT_COMP_CTL, tmp);
+			// Drive_PAD_CTL register.  Set field selrxdrv and slew to 0;
+			tmp = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_DRIVE_PAD_CTL);
+			tmp &= (0xfffffffe);    //clear bits 0 and 1.
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_DRIVE_PAD_CTL,tmp);
+		}
+	}//for(i=0..
+}
+
+void crystalhd_flea_ddr_ctrl_init(struct crystalhd_hw *hw,
+								int32_t port,
+								int32_t ddr3,
+								int32_t speed_grade,
+								int32_t col,
+								int32_t bank,
+								int32_t row,
+								uint32_t tmode)
+{
+	//uint32_t offset;
+	//uint32_t arb_refresh_addr;
+	uint32_t port_int;
+
+	uint32_t data;
+
+	//DDR2 Parameters
+	uint8_t tRCD = 0;
+	uint8_t tRP = 0;
+	uint8_t tRRD = 0;
+	uint8_t tWR = 0;
+	uint8_t tWTR = 0;
+	uint8_t tCAS = 0;
+	uint8_t tWL = 0;
+	uint8_t tRTP = 0;
+	uint8_t tRAS = 0;
+	uint8_t tFAW = 0;
+	uint8_t tRFC = 0;
+	uint8_t INTLV_BYTES = 0;
+	uint8_t INTLV_DISABLE = 0;
+	uint8_t CTRL_BITS = 0;
+	uint8_t ALLOW_PICTMEM_RD = 0;
+	uint8_t DIS_DQS_ODT = 0;
+	uint8_t CS0_ONLY = 0;
+	uint8_t EN_ODT_EARLY = 0;
+	uint8_t EN_ODT_LATE = 0;
+	uint8_t USE_CHR_HGT = 0;
+	uint8_t DIS_ODT = 0;
+	uint8_t EN_2T_TIMING = 0;
+	uint8_t CWL = 0;
+	uint8_t DQ_WIDTH = 0;
+
+	uint8_t DM_IDLE_MODE = 0;
+	uint8_t CTL_IDLE_MODE = 0;
+	uint8_t DQ_IDLE_MODE = 0;
+
+	uint8_t DIS_LATENCY_CTRL = 0;
+
+	uint8_t PSPLIT = 0;
+	uint8_t DSPLIT = 0;
+
+	// For each controller port, 0 and 1.
+	for (port_int=0; port_int < 1; ++port_int)  {
+#if 0
+		printk("******************************************************\n");
+		printk("* Configuring DDR23 at addr=0x%x, speed grade [%s]\n",0,
+                ((speed_grade == DDR2_667MHZ) && (tmode == 0)) ? "667MHZ":
+                ((speed_grade == DDR2_533MHZ) && (tmode == 0)) ? "533MHZ":
+                ((speed_grade == DDR2_400MHZ) && (tmode == 0)) ? "400MHZ":
+                ((speed_grade == DDR2_333MHZ) && (tmode == 0)) ? "333MHZ":
+                ((speed_grade == DDR2_266MHZ) && (tmode == 0)) ? "266MHZ": "400MHZ" );
+#endif
+		// Written in this manner to prevent table lookup in Memory for embedded MIPS code.
+		// Cannot use memory until it is inited!  Case statements with greater than 5 cases use memory tables
+		// when optimized.  Tony O 9/18/07
+		// Note if not in test mode 0, choose the slowest clock speed.
+		if (speed_grade == DDR2_200MHZ) {
+			tRCD = 3;
+			tRP = 3;
+			tRRD = 2;
+			tWR = 3;
+			tWTR = 2;
+			tCAS = 4;
+			tWL = 3;
+			tRTP = 2;
+			tRAS = 8;
+			tFAW = 10;
+			if (bank == BANK_SIZE_4)
+				tRFC = 21;
+			else //BANK_SIZE_8
+				tRFC = 26;
+		}
+		else if (speed_grade == DDR2_266MHZ ) {
+			tRCD = 4;
+			tRP = 4;
+			tRRD = 3;
+			tWR = 4;
+			tWTR = 2;
+			tCAS = 4;
+			tWL = 3;
+			tRTP = 2;
+			tRAS = 11;
+			tFAW = 14;
+			if (bank == BANK_SIZE_4)
+				tRFC = 28;
+			else //BANK_SIZE_8
+				tRFC = 34;
+		}
+		else if (speed_grade == DDR2_333MHZ) {
+			tRCD = 4;
+			tRP = 4;
+			tRRD = 4;
+			tWR = 5;
+			tWTR = 3;
+			tCAS = 4;
+			tWL = 3;
+			tRTP = 3;
+			tRAS = 14;
+			tFAW = 17;
+			if (bank == BANK_SIZE_4)
+				tRFC = 35;
+			else //BANK_SIZE_8
+				tRFC = 43;
+		}
+		else if ((speed_grade == DDR2_400MHZ) || (tmode != 0)) { // -25E timing
+			tRCD = 6;
+			tRP = 6;
+			tRRD = 4;
+			tWR = 6;
+			tWTR = 4;
+			tCAS = ddr3 ? 6 : 5;
+			tWL = ddr3 ? 5 : 4;
+			tRTP = 3;
+			tRAS = 18;
+			tFAW = 20;
+			if (bank == BANK_SIZE_4)
+				tRFC = 42;
+			else //BANK_SIZE_8
+				tRFC = 52;
+			CWL = tWL - 5;
+		}
+		else if (speed_grade == DDR2_533MHZ) { // -187E timing
+			tRCD = 7;
+			tRP = 7;
+			tRRD =  6;
+			tWR = 8;
+			tWTR = 4;
+			tCAS = 7;
+			tWL = tCAS - 1;
+			tRTP = 4;
+			tRAS = 22;
+			tFAW = 24;
+			tRFC = 68;
+			CWL = tWL - 5;
+		}
+		else if (speed_grade == DDR2_667MHZ) { // -15E  timing
+			tRCD = 9;
+			tRP = 9;
+			tRRD =  5;// 4/5
+			tWR = 10;
+			tWTR = 5;
+			tCAS = 9;
+			tWL = 7;
+			tRTP = 5;
+			tRAS = 24;
+			tFAW = 30; // 20/30
+			tRFC = 74;
+			CWL = tWL - 5;
+		}
+		else
+			printk("init: CANNOT HAPPEN - Memory DDR23 Ctrl_init failure. Incorrect speed grade type [%d]\n", speed_grade);
+
+		CTRL_BITS = 0; // Control Bit for CKE signal
+		EN_2T_TIMING = 0;
+		INTLV_DISABLE = ddr3 ? 1:0;  // disable for DDR3, enable for DDR2
+		INTLV_BYTES = 0;
+		ALLOW_PICTMEM_RD = 0;
+		DIS_DQS_ODT = 0;
+		CS0_ONLY = 0;
+		EN_ODT_EARLY = 0;
+		EN_ODT_LATE = 0;
+		USE_CHR_HGT = 0;
+		DIS_ODT = 0;
+
+		//Power Saving Controls
+		DM_IDLE_MODE = 0;
+		CTL_IDLE_MODE = 0;
+		DQ_IDLE_MODE = 0;
+
+		//Latency Control Setting
+		DIS_LATENCY_CTRL = 0;
+
+		// ****** Start of Grain/Flea specific fixed settings *****
+		CS0_ONLY = 1 ;      // 16-bit mode only
+		INTLV_DISABLE = 1 ; // Interleave is always disabled
+		DQ_WIDTH = 16 ;
+		// ****** End of Grain specific fixed settings *****
+
+#if 0
+		printk("* DDR23 Config: CAS: %d, tRFC: %d, INTLV: %d, WIDTH: %d\n",
+				tCAS,tRFC,INTLV_BYTES,DQ_WIDTH);
+		printk("******************************************************\n");
+#endif
+		//Disable refresh
+		data = ((0x68 << 0) |  //Refresh period
+				(0x0 << 12)    //disable refresh
+				);
+
+		hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0, data);
+
+		// DecSd_Ddr2Param1
+		data = 0;
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, trcd, tRCD); // trcd
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, trp, tRP); // trp
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, trrd, tRRD);  // trrd
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, twr, tWR);  // twr
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, twtr, tWTR);  // twtr
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, tcas, tCAS);  // tcas
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, twl, tWL); // twl
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS1, trtp, tRTP); // trtp
+
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS1,  data );
+
+		//DecSd_Ddr2Param3 - deassert reset only
+		data = 0;
+		//DEBUG_PRINT(PARAMS3, data);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS3,  data );
+
+		// Reset must be deasserted 500us before CKE. This needs
+		// to be reflected in the CFE. (add delay here)
+
+		//DecSd_Ddr2Param2
+		data = 0;
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, tras, tRAS);  // tras
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, tfaw, tFAW); // tfaw
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, trfc, tRFC); // trfc
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, bank_bits, bank & 1); //  0 = bank size of 4K == 2bits, 1 = bank size of 8k == 3 bits
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, allow_pictmem_rd, ALLOW_PICTMEM_RD);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, cs0_only, CS0_ONLY);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, dis_itlv, INTLV_DISABLE); // #disable interleave
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, il_sel, INTLV_BYTES); // #bytes per interleave
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, sd_col_bits, col & 3); // column bits, 0 = 9, 1= 10, 2 or 3 = 11 bits
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, clke, CTRL_BITS); // Control Bit for CKE signal
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, use_chr_hgt, USE_CHR_HGT);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS2, row_bits, row & 1); // row size 1 is 16K for 2GB device, otherwise 0 and 8k sized
+
+		//DEBUG_PRINT(PARAMS2, data);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2,  data );
+
+		//DecSd_Ddr2Param3.
+		data = 0;
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, wr_odt_en, DIS_ODT ? 0 : 1);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, wr_odt_le_adj, EN_ODT_EARLY ? 1 : 0);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, wr_odt_te_adj, EN_ODT_LATE ? 1 : 0);
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, cmd_2t, EN_2T_TIMING ? 1: 0);  // 2T timing is disabled
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, ddr_bl, ddr3 ? 1: 0);  // 0 for DDR2, 1 for DDR3
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, wr_odt_mode, ddr3 ? 1:0);  // ddr3 preamble
+		SET_FIELD(data, BCHP_DDR23_CTL_REGS_0, PARAMS3, ddr3_reset, ddr3 ? 0:1);  // ddr3 reset
+
+		//DEBUG_PRINT(PARAMS3, data);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS3,  data );
+	} // for( port_int......)
+
+	data = 0;
+	SET_FIELD(data, BCHP_DDR23_PHY_CONTROL_REGS, DRIVE_PAD_CTL, slew, 1);
+	SET_FIELD(data, BCHP_DDR23_PHY_CONTROL_REGS, DRIVE_PAD_CTL, seltxdrv_ci, 1);
+	SET_FIELD(data, BCHP_DDR23_PHY_CONTROL_REGS, DRIVE_PAD_CTL, sel_sstl18, ddr3 ? 0 : 1);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_DRIVE_PAD_CTL, data );
+
+	data = 0;
+	SET_FIELD(data, BCHP_DDR23_PHY_BYTE_LANE_0, DRIVE_PAD_CTL, slew, 0);
+	SET_FIELD(data, BCHP_DDR23_PHY_BYTE_LANE_0, DRIVE_PAD_CTL, selrxdrv, 0);
+	SET_FIELD(data, BCHP_DDR23_PHY_BYTE_LANE_0, DRIVE_PAD_CTL, seltxdrv_ci, 0);
+	SET_FIELD(data, BCHP_DDR23_PHY_BYTE_LANE_0, DRIVE_PAD_CTL, sel_sstl18, ddr3 ? 0 : 1);
+	SET_FIELD(data, BCHP_DDR23_PHY_BYTE_LANE_0, DRIVE_PAD_CTL, rt60b, 0);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_DRIVE_PAD_CTL, data );
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_DRIVE_PAD_CTL, data );
+
+	data = 0;
+
+	if (speed_grade == DDR2_667MHZ) {
+		data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_MASK) | ((2 << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_MASK));
+	} else {
+		data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_MASK) | ((1 << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_data_dly_MASK));
+	}
+
+	data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_enable_MASK) | ((((DIS_DQS_ODT || DIS_ODT) ? 0:1) << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_enable_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_enable_MASK));
+	data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_adj_MASK) | (((EN_ODT_EARLY ? 1 : 0) << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_adj_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_adj_MASK));
+	data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_enable_MASK) | (((DIS_ODT ? 0:1) << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_enable_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_enable_MASK));
+	data = ((data & ~BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_adj_MASK) | (((EN_ODT_EARLY ? 1 : 0) << BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_adj_SHIFT) & BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_rd_enb_odt_adj_MASK));
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL, data);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_READ_CONTROL, data);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_WR_PREAMBLE_MODE, ddr3 ? 1 : 0);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_WR_PREAMBLE_MODE, ddr3 ? 1 : 0);
+
+	// Disable unused clocks
+
+	for (port_int=0; port_int<1; ++port_int) { // For Grain
+		// Changes for Grain/Flea
+		//offset = 0;
+		//arb_refresh_addr = BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0;
+		//offset += GLOBAL_REG_RBUS_START;
+		// Changes for Grain - till here
+
+		if (ddr3) {
+			data = (CWL & 0x07) << 3;
+			//DEBUG_PRINT(LOAD_EMODE2_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE2_CMD,  data );
+
+			data = 0;
+			//DEBUG_PRINT(LOAD_EMODE3_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE3_CMD,  data );
+
+			data = 6;  // was 4;
+			//DEBUG_PRINT(LOAD_EMODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE_CMD,  data );
+
+			data = 0x1100;   // Reset DLL
+			data += ((tWR-4) << 9);
+			data += ((tCAS-4) << 4);
+			//DEBUG_PRINT(LOAD_MODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_MODE_CMD,  data );
+
+
+			data = 0x0400;  // long calibration
+			//DEBUG_PRINT(ZQ_CALIBRATE, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_ZQ_CALIBRATE,  data );
+
+			msleep_interruptible(1);
+		}
+		else
+		{
+			//DecSd_RegSdPrechCmd    // Precharge
+			data = 0;
+			//DEBUG_PRINT(PRECHARGE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PRECHARGE_CMD,  data );
+
+			//DEBUG_PRINT(PRECHARGE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PRECHARGE_CMD,  data );
+
+			//DecSd_RegSdLdModeCmd   //Clear EMODE 2,3
+			data = 0;
+			//DEBUG_PRINT(LOAD_EMODE2_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE2_CMD,  data );
+
+			//DEBUG_PRINT(LOAD_EMODE3_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE3_CMD,  data );
+
+			//DecSd_RegSdLdEmodeCmd  // Enable DLL ; Rtt ; enable OCD
+			data = 0x3C0;
+			//DEBUG_PRINT(LOAD_EMODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE_CMD,  data );
+
+			//DecSd_RegSdLdModeCmd
+			data = 0x102;   // Reset DLL
+			data += ((tWR-1) << 9);
+			data += (tCAS << 4);
+			//DEBUG_PRINT(LOAD_MODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_MODE_CMD,  data );
+
+			//DecSd_RegSdPrechCmd    // Precharge
+			data = 0;
+			//DEBUG_PRINT(PRECHARGE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PRECHARGE_CMD,  data );
+
+			//DEBUG_PRINT(PRECHARGE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PRECHARGE_CMD,  data );
+
+			//DecSd_RegSdRefCmd      // Refresh
+			data = 0x69;
+			//DEBUG_PRINT(REFRESH_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_REFRESH_CMD,  data );
+
+			//DEBUG_PRINT(REFRESH_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_REFRESH_CMD,  data );
+
+			//DecSd_RegSdLdModeCmd
+			data = 0x002;   // Un-Reset DLL
+			data += ((tWR-1) << 9);
+			data += (tCAS << 4);
+			//DEBUG_PRINT(LOAD_MODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_MODE_CMD,  data );
+
+			//DecSd_RegSdLdEmodeCmd  // Enable DLL ; Rtt ; enable OCD
+			data = 0x3C0;
+			//DEBUG_PRINT(LOAD_EMODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE_CMD,  data );
+
+			//DecSd_RegSdLdEmodeCmd  // Enable DLL ; Rtt ; disable OCD
+			data = 0x40;
+			//DEBUG_PRINT(LOAD_EMODE_CMD, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE_CMD,  data );
+		}
+
+		//Enable refresh
+		data = ((0x68 << 0) |  //Refresh period
+				(0x1 << 12)    //enable refresh
+				);
+		if (tmode == 0) {
+			//MemSysRegWr(arb_refresh_addr + GLOBAL_REG_RBUS_START,data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0,data);
+		}
+
+		//offset = 0;
+		//offset += GLOBAL_REG_RBUS_START;
+
+		// Use this scratch register in DDR0 as a simple symaphore for the test
+		// to monitor if and when the Initialization of the DDR is complete. Seeing a non zero value
+		// indicates DDR init complete.  This code is ONLY for the MIPS. It has no affect in init.c
+		// The MIPS executes this code and we wait until DDR 1 is inited before setting the semaphore.
+		if ( port_int == 1)
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_SCRATCH, 0xff);
+
+		//Setup the Arbiter Data and Pict Buffer split if specified
+		if (port_int==0) { //only need to do this once
+			//where is the pict buff split (2 bits)
+			//0 = always mem_a, 1 = (<128 is mem_a), 2 = (<64 is mem_a), 3 = always mem_b
+			PSPLIT = 0;
+
+			//0 = 32MB, 1 = 64MB, 2 = 128 MB, 3 = 256MB, 4=512MB
+			DSPLIT = 4;
+
+			data = 0;
+			data += DSPLIT;
+			data += PSPLIT<< 4;
+			// MemSysRegWr (PRI_ARB_CONTROL_REGS_CONC_CTL + offset,  data );
+		}
+
+		if (DIS_LATENCY_CTRL == 1){
+			//set the work limit to the maximum
+			//DEBUG_PRINT(LATENCY, data);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LATENCY,  0x3ff );
+		}
+	} // for (port_int=0......  )
+
+ return;
+}
+
+void crystalhd_flea_ddr_arb_rts_init(struct crystalhd_hw *hw)
+{
+	uint32_t addr_cnt;
+	uint32_t addr_ctrl;
+	uint32_t i;
+
+	addr_cnt = BCHP_PRI_CLIENT_REGS_CLIENT_00_COUNT;
+	addr_ctrl = BCHP_PRI_CLIENT_REGS_CLIENT_00_CONTROL;
+
+	//Go through the various clients and program them
+	for(i=0;i<21;i++){
+		if (rts_prog_vals[i][0] > 0) {
+			hw->pfnWriteDevRegister(hw->adp, addr_cnt,
+				(rts_prog_vals[i][1]) |        //Blockout Count
+				(rts_prog_vals[i][2] << 16)    //Critical Period
+				);
+			hw->pfnWriteDevRegister(hw->adp, addr_ctrl,
+				(rts_prog_vals[i][3]) |        //Priority Level
+				(rts_prog_vals[i][4] << 8)     //Access Mode
+				);
+		}
+		addr_cnt+=8;
+		addr_ctrl+=8;
+	}
+}
diff --git a/drivers/staging/chd/crystalhd_flea_ddr.h b/drivers/staging/chd/crystalhd_flea_ddr.h
new file mode 100644
index 0000000..a2860ca
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_flea_ddr.h
@@ -0,0 +1,73 @@
+/***************************************************************************
+ * Copyright (c) 2005-2010, Broadcom Corporation.
+ *
+ *  Name: crystalhd_flea_ddr . h
+ *
+ *  Description:
+ *		BCM70015 generic DDR routines
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#undef  BRCM_ALIGN
+#define BRCM_ALIGN(c,r,f)   0
+
+#define MEM_SYS_NUM_DDR_PLLS 2;
+
+//extern uint32_t rts_prog_vals[][5];
+
+typedef enum DDR2_SPEED_GRADE {
+  DDR2_400MHZ = 0x0,
+  DDR2_333MHZ = 0x1,
+  DDR2_266MHZ = 0x2,
+  DDR2_200MHZ = 0x3,
+  DDR2_533MHZ = 0x4,
+  DDR2_667MHZ = 0x5
+} eDDR2_SPEED_GRADE;
+
+typedef enum SD_COL_SIZE {
+  COL_BITS_9  = 0x0,
+  COL_BITS_10 = 0x1,
+  COL_BITS_11 = 0x2,
+} eSD_COL_SIZE;
+
+typedef enum SD_BANK_SIZE {
+  BANK_SIZE_4  = 0x0,
+  BANK_SIZE_8  = 0x1,
+} eSD_BANK_SIZE;
+
+typedef enum SD_ROW_SIZE {
+  ROW_SIZE_8K  = 0x0,
+  ROW_SIZE_16K = 0x1,
+} eSD_ROW_SIZE;
+
+//DDR PHY PLL init routine
+void crystalhd_flea_ddr_pll_config(struct crystalhd_hw* hw, int32_t *speed_grade, int32_t num_plls, uint32_t tmode);
+
+//DDR controller init routine
+void crystalhd_flea_ddr_ctrl_init(struct crystalhd_hw *hw, 
+						int32_t port, 
+                        int32_t ddr3,
+                        int32_t speed_grade, 
+                        int32_t col, 
+                        int32_t bank, 
+                        int32_t row,
+                        uint32_t tmode );
+
+////RTS Init routines
+void crystalhd_flea_ddr_arb_rts_init(struct crystalhd_hw *hw);
diff --git a/drivers/staging/chd/crystalhd_fleafuncs.c b/drivers/staging/chd/crystalhd_fleafuncs.c
new file mode 100644
index 0000000..6f2f341
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_fleafuncs.c
@@ -0,0 +1,2954 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_fleafuncs.c
+ *
+ *  Description:
+ *		BCM70015 Linux driver HW layer.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/tsc.h>
+#include <asm/msr.h>
+#include "crystalhd_hw.h"
+#include "crystalhd_fleafuncs.h"
+#include "crystalhd_lnx.h"
+#include "bc_defines.h"
+#include "FleaDefs.h"
+#include "crystalhd_flea_ddr.h"
+
+#define OFFSETOF(_s_, _m_) ((size_t)(unsigned long)&(((_s_ *)0)->_m_))
+
+void crystalhd_flea_core_reset(struct crystalhd_hw *hw)
+{
+	unsigned int pollCnt=0,regVal=0;
+
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_core_reset]: Starting core reset\n");
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC3_RESET_CTRL,	0x01);
+
+	pollCnt=0;
+	while (1)
+	{
+		pollCnt++;
+		regVal=0;
+
+		msleep_interruptible(1);
+
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_MISC3_RESET_CTRL);
+
+		if(!(regVal & 0x01))
+		{
+			/*
+			-- Bit is 0, Reset is completed. Which means that
+			-- wait for sometime and then allow other accesses.
+			*/
+			msleep_interruptible(1);
+			break;
+		}
+
+		if(pollCnt > MAX_VALID_POLL_CNT)
+		{
+			printk("!!FATAL ERROR!! Core Reset Failure\n");
+			break;
+		}
+	}
+
+	msleep_interruptible(5);
+
+	return;
+}
+
+void crystalhd_flea_disable_interrupts(struct crystalhd_hw *hw)
+{
+	FLEA_MASK_REG IntrMaskReg;
+	/*
+	-- Mask everything except the reserved bits.
+	*/
+	IntrMaskReg.WholeReg =0xffffffff;
+	IntrMaskReg.Reserved1=0;
+	IntrMaskReg.Reserved2=0;
+	IntrMaskReg.Reserved3=0;
+	IntrMaskReg.Reserved4=0;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_MSK_SET_REG, IntrMaskReg.WholeReg);
+
+	return;
+}
+
+void crystalhd_flea_enable_interrupts(struct crystalhd_hw *hw)
+{
+	FLEA_MASK_REG IntrMaskReg;
+	/*
+	-- Clear The Mask for everything except the reserved bits.
+	*/
+	IntrMaskReg.WholeReg =0xffffffff;
+	IntrMaskReg.Reserved1=0;
+	IntrMaskReg.Reserved2=0;
+	IntrMaskReg.Reserved3=0;
+	IntrMaskReg.Reserved4=0;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_MSK_CLR_REG, IntrMaskReg.WholeReg);
+
+	return;
+}
+
+void crystalhd_flea_clear_interrupts(struct crystalhd_hw *hw)
+{
+	FLEA_INTR_STS_REG	IntrStsValue;
+
+	IntrStsValue.WholeReg = hw->pfnReadDevRegister(hw->adp, BCHP_INTR_INTR_STATUS);
+
+	if(IntrStsValue.WholeReg)
+	{
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_CLR_REG, IntrStsValue.WholeReg);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_EOI_CTRL, 1);
+	}
+
+	return;
+}
+
+bool crystalhd_flea_detect_ddr3(struct crystalhd_hw *hw)
+{
+	uint32_t regVal = 0;
+
+	/*Set the Multiplexer to select the GPIO-6*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_0);
+
+	/*Make sure that the bits-24:27 are reset*/
+	if(regVal & 0x0f000000)
+	{
+		regVal = regVal & 0xf0ffffff; /*Clear bit 24-27 for selecting GPIO_06*/
+		hw->pfnWriteDevRegister(hw->adp, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_0, regVal);
+	}
+
+	regVal=0;
+	/*Set the Direction of GPIO-6*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_GIO_IODIR_LO);
+
+	if(!(regVal & BC_BIT(6)))
+	{
+		/*Set the Bit number 6 to make the GPIO6 as input*/
+		regVal |= BC_BIT(6);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_GIO_IODIR_LO, regVal);
+	}
+
+	regVal=0;
+	regVal = hw->pfnReadDevRegister(hw->adp,	BCHP_GIO_DATA_LO);
+
+	/*If this bit is clear then have DDR-3 else we have DDR-2*/
+	if(!(regVal & BC_BIT(6)))
+	{
+		dev_dbg(&hw->adp->pdev->dev,"DDR-3 Detected\n");
+		return true;
+	}
+	dev_dbg(&hw->adp->pdev->dev,"DDR-2 Detected\n");
+	return false;
+}
+
+void crystalhd_flea_init_dram(struct crystalhd_hw *hw)
+{
+	int32_t ddr2_speed_grade[2];
+	uint32_t sd_0_col_size, sd_0_bank_size, sd_0_row_size;
+	uint32_t sd_1_col_size, sd_1_bank_size, sd_1_row_size;
+	uint32_t ddr3_mode[2];
+	uint32_t regVal;
+	bool bDDR3Detected=false; //Should be filled in using the detection logic. Default to DDR2
+
+	// On all designs we are using DDR2 or DDR3 x16 and running at a max of 400Mhz
+	// Only one bank of DDR supported. The other is a dummy
+
+	ddr2_speed_grade[0] = DDR2_400MHZ;
+	ddr2_speed_grade[1] = DDR2_400MHZ;
+	sd_0_col_size = COL_BITS_10;
+	sd_0_bank_size = BANK_SIZE_8;
+	sd_0_row_size = ROW_SIZE_8K; // DDR2
+	//	sd_0_row_size = ROW_SIZE_16K; // DDR3
+	sd_1_col_size = COL_BITS_10;
+	sd_1_bank_size = BANK_SIZE_8;
+	sd_1_row_size = ROW_SIZE_8K;
+	ddr3_mode[0] = 0;
+	ddr3_mode[1] = 0;
+
+	bDDR3Detected = crystalhd_flea_detect_ddr3(hw);
+	if(bDDR3Detected)
+	{
+		ddr3_mode[0] = 1;
+		sd_0_row_size = ROW_SIZE_16K; // DDR3
+		sd_1_row_size = ROW_SIZE_16K; // DDR3
+
+	}
+
+	// Step 1. PLL Init
+	crystalhd_flea_ddr_pll_config(hw, ddr2_speed_grade, 1, 0); // only need to configure PLLs in TM0
+
+	// Step 2. DDR CTRL Init
+	crystalhd_flea_ddr_ctrl_init(hw, 0, ddr3_mode[0], ddr2_speed_grade[0], sd_0_col_size, sd_0_bank_size, sd_0_row_size, 0);
+
+	// Step 3 RTS Init - Real time scheduling memory arbiter
+	crystalhd_flea_ddr_arb_rts_init(hw);
+
+	// NAREN turn off ODT. The REF1 and SV1 and most customer designs allow this.
+	// IF SOMEONE COMPLAINS ABOUT MEMORY OR DATA CORRUPTION LOOK HERE FIRST
+
+	//hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_LOAD_EMODE_CMD, 0x02, false);
+
+	/*regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS3);
+	regVal &= ~(BCHP_DDR23_CTL_REGS_0_PARAMS3_wr_odt_en_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS3, regVal);*/
+
+	/*regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_DRIVE_PAD_CTL);
+	regVal |= BCHP_DDR23_PHY_BYTE_LANE_1_DRIVE_PAD_CTL_seltxdrv_ci_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_DRIVE_PAD_CTL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_DRIVE_PAD_CTL);
+	regVal |= BCHP_DDR23_PHY_BYTE_LANE_0_DRIVE_PAD_CTL_seltxdrv_ci_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_DRIVE_PAD_CTL, regVal);*/
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_PAD_DISABLE);
+	regVal |= BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_PAD_DISABLE_clk_pad_dis_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_PAD_DISABLE, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL_dq_odt_enable_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_READ_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_READ_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_1_READ_CONTROL_dq_odt_enable_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_READ_CONTROL, regVal);
+
+	return;
+}
+
+uint32_t crystalhd_flea_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off)
+{
+	uint32_t baseAddr = reg_off >> 16;
+	void	*regAddr;
+
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return 0;
+	}
+
+	if(baseAddr == 0 || baseAddr == FLEA_GISB_DIRECT_BASE) // Direct Mapped Region
+	{
+		regAddr = adp->i2o_addr + (reg_off & 0x0000FFFF);
+		if(regAddr > (adp->i2o_addr + adp->pci_i2o_len)) {
+			dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+					__func__, reg_off);
+			return 0;
+		}
+		return readl(regAddr);
+	}
+	else // non directly mapped region
+	{
+		if(adp->pci_i2o_len < 0xFFFF) {
+			printk("Un-expected mapped region size\n");
+			return 0;
+		}
+		regAddr = adp->i2o_addr + FLEA_GISB_INDIRECT_ADDRESS;
+		writel(reg_off | 0x10000000, regAddr);
+		regAddr = adp->i2o_addr + FLEA_GISB_INDIRECT_DATA;
+		return readl(regAddr);
+	}
+}
+
+void crystalhd_flea_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val)
+{
+	uint32_t baseAddr = reg_off >> 16;
+	void	*regAddr;
+
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return;
+	}
+
+	if(baseAddr == 0 || baseAddr == FLEA_GISB_DIRECT_BASE) // Direct Mapped Region
+	{
+		regAddr = adp->i2o_addr + (reg_off & 0x0000FFFF);
+		if(regAddr > (adp->i2o_addr + adp->pci_i2o_len)) {
+			dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+					__func__, reg_off);
+					return ;
+		}
+		writel(val, regAddr);
+	}
+	else // non directly mapped region
+	{
+		if(adp->pci_i2o_len < 0xFFFF) {
+			printk("Un-expected mapped region size\n");
+			return;
+		}
+		regAddr = adp->i2o_addr + FLEA_GISB_INDIRECT_ADDRESS;
+		writel(reg_off | 0x10000000, regAddr);
+		regAddr = adp->i2o_addr + FLEA_GISB_INDIRECT_DATA;
+		writel(val, regAddr);
+	}
+}
+
+/**
+* crystalhd_flea_mem_rd - Read data from DRAM area.
+* @adp: Adapter instance
+* @start_off: Start offset.
+* @dw_cnt: Count in dwords.
+* @rd_buff: Buffer to copy the data from dram.
+*
+* Return:
+*	Status.
+*
+* Dram read routine.
+*/
+BC_STATUS crystalhd_flea_mem_rd(struct crystalhd_hw *hw, uint32_t start_off,
+								uint32_t dw_cnt, uint32_t *rd_buff)
+{
+	uint32_t ix = 0;
+	uint32_t addr = start_off, base;
+
+	if (!hw || !rd_buff) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if( hw->FleaPowerState == FLEA_PS_LP_COMPLETE ) {
+		//printk(KERN_ERR "%s: Flea power down, cann't read memory.\n", __func__);
+		return BC_STS_BUSY;
+	}
+
+	if((start_off + dw_cnt * 4) > FLEA_TOTAL_DRAM_SIZE) {
+		printk(KERN_ERR "Access beyond DRAM limit at Addr 0x%x and size 0x%x words\n", start_off, dw_cnt);
+		return BC_STS_ERROR;
+	}
+
+	/* Set the base addr for the 512kb window */
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC2_DIRECT_WINDOW_CONTROL,
+							(addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK) | BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_ENABLE_MASK);
+
+	for (ix = 0; ix < dw_cnt; ix++) {
+		rd_buff[ix] = readl(hw->adp->mem_addr + (addr & ~BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK));
+		base = addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK;
+		addr += 4; // DWORD access at all times
+		if (base != (addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK)) {
+			/* Set the base addr for next 512kb window */
+			hw->pfnWriteDevRegister(hw->adp, BCHP_MISC2_DIRECT_WINDOW_CONTROL,
+										(addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK) | BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_ENABLE_MASK);
+		}
+	}
+	return BC_STS_SUCCESS;
+}
+
+/**
+* crystalhd_flea_mem_wr - Write data to DRAM area.
+* @adp: Adapter instance
+* @start_off: Start offset.
+* @dw_cnt: Count in dwords.
+* @wr_buff: Data Buffer to be written.
+*
+* Return:
+*	Status.
+*
+* Dram write routine.
+*/
+BC_STATUS crystalhd_flea_mem_wr(struct crystalhd_hw *hw, uint32_t start_off,
+								uint32_t dw_cnt, uint32_t *wr_buff)
+{
+	uint32_t ix = 0;
+	uint32_t addr = start_off, base;
+	uint32_t temp;
+
+	if (!hw || !wr_buff) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if( hw->FleaPowerState == FLEA_PS_LP_COMPLETE ) {
+		//printk(KERN_ERR "%s: Flea power down, cann't write memory.\n", __func__);
+		return BC_STS_BUSY;
+	}
+
+	if((start_off + dw_cnt * 4) > FLEA_TOTAL_DRAM_SIZE) {
+		printk("Access beyond DRAM limit at Addr 0x%x and size 0x%x words\n", start_off, dw_cnt);
+		return BC_STS_ERROR;
+	}
+
+	/* Set the base addr for the 512kb window */
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC2_DIRECT_WINDOW_CONTROL,
+							(addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK) | BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_ENABLE_MASK);
+
+	for (ix = 0; ix < dw_cnt; ix++) {
+		writel(wr_buff[ix], hw->adp->mem_addr + (addr & ~BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK));
+		base = addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK;
+		addr += 4; // DWORD access at all times
+		if (base != (addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK)) {
+			/* Set the base addr for next 512kb window */
+			hw->pfnWriteDevRegister(hw->adp, BCHP_MISC2_DIRECT_WINDOW_CONTROL,
+									(addr & BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_BASE_ADDR_MASK) | BCHP_MISC2_DIRECT_WINDOW_CONTROL_DIRECT_WINDOW_ENABLE_MASK);
+		}
+	}
+
+	/*Dummy Read To Flush Memory Arbitrator*/
+	crystalhd_flea_mem_rd(hw, start_off, 1, &temp);
+	return BC_STS_SUCCESS;
+}
+
+
+static
+void crystalhd_flea_runtime_power_up(struct crystalhd_hw *hw)
+{
+	uint32_t regVal;
+	uint64_t currTick;
+	uint32_t totalTick_Hi;
+	uint32_t TickSpentInPD_Hi;
+	uint64_t temp_64;
+	long totalTick_Hi_f;
+	long TickSpentInPD_Hi_f;
+
+	//printk("RT PU \n");
+
+	// NAREN This function restores clocks and power to the DRAM and to the core to bring the decoder back up to full operation
+	/* Start the DRAM controller clocks first */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+	regVal &= ~(BCHP_CLK_PM_CTRL_DIS_DDR_108_CLK_MASK |	BCHP_CLK_PM_CTRL_DIS_DDR_216_CLK_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regVal);
+
+	// Delay to allow the DRAM clock to stabilize
+	udelay(25);
+
+	/* Power Up PHY and start clocks on DRAM device */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL_pwrdn_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+	regVal &= ~(BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG_PWRDN_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG, regVal);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL,
+		~(BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL_DIS_DDR_CLK_MASK));
+
+	// Delay to allow the PLL to lock
+	udelay(25);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_idle_MASK );
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL_pwrdn_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL_pwrdn_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_idle_MASK );
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL);
+	regVal &= ~(BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_idle_MASK );
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL, regVal);
+
+	/* Start Refresh Cycles from controller */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0);
+	regVal |= BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0_enable_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0, regVal);
+
+	/* turn off self-refresh */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2);
+	regVal &= ~(BCHP_DDR23_CTL_REGS_0_PARAMS2_clke_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2, regVal);
+
+	udelay(5);
+
+	/* Issue refresh cycle */
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_REFRESH_CMD, 0x60);
+
+	/* Enable the ARM AVD and BLINK clocks */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+
+	regVal &= ~(BCHP_CLK_PM_CTRL_DIS_ARM_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_216_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_216_CLK_MASK);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, 0x03000000);
+
+	/* Start arbiter */
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL, BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL_arb_disable_Enable);
+
+#ifdef _POWER_HANDLE_AVD_WATCHDOG_
+	/* Restore Watchdog timers */
+	// Make sure the timeouts do not happen
+	//Outer Loop Watchdog timer
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DECODE_CPUREGS_0_REG_WATCHDOG_TMR, hw->OLWatchDogTimer);
+
+	////Inner Loop Watchdog timer
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DECODE_CPUREGS2_0_REG_WATCHDOG_TMR, hw->ILWatchDogTimer);
+
+#endif
+
+	//printk("RT Power Up Flea Complete\n");
+
+	rdtscll(currTick);
+
+	hw->TickSpentInPD += (currTick - hw->TickStartInPD);
+
+	temp_64 = (hw->TickSpentInPD)>>24;
+	TickSpentInPD_Hi = (uint32_t)(temp_64);
+	TickSpentInPD_Hi_f = (long)TickSpentInPD_Hi;
+
+	temp_64 = (currTick - hw->TickCntDecodePU)>>24;
+	totalTick_Hi = (uint32_t)(temp_64);
+	totalTick_Hi_f = (long)totalTick_Hi;
+
+	if( totalTick_Hi_f <= 0 )
+	{
+		temp_64 = (hw->TickSpentInPD);
+		TickSpentInPD_Hi = (uint32_t)(temp_64);
+		TickSpentInPD_Hi_f = (long)TickSpentInPD_Hi;
+
+		temp_64 = (currTick - hw->TickCntDecodePU);
+		totalTick_Hi = (uint32_t)(temp_64);
+		totalTick_Hi_f = (long)totalTick_Hi;
+	}
+
+	if( totalTick_Hi_f <= 0 )
+	{
+		printk("totalTick_Hi_f <= 0, set hw->PDRatio = 60\n");
+		hw->PDRatio = 60;
+	}
+	else
+		hw->PDRatio = (TickSpentInPD_Hi_f * 100) / totalTick_Hi_f;
+
+	//printk("Ticks currently spent in PD: 0x%llx Total: 0x%llx Ratio %d,\n",
+	//	hw->TickSpentInPD, (currTick - hw->TickCntDecodePU), hw->PDRatio);
+
+	/* NAREN check if the PD ratio is greater than 75. If so, try to increase the PauseThreshold to improve the ratio */
+	/* never go higher than the default threshold */
+	if((hw->PDRatio > 75) && (hw->PauseThreshold < hw->DefaultPauseThreshold))
+	{
+		//printk("Current PDRatio:%u, PauseThreshold:%u, DefaultPauseThreshold:%u, incress PauseThreshold.\n",
+		//		hw->PDRatio, hw->PauseThreshold, hw->DefaultPauseThreshold);
+		hw->PauseThreshold++;
+	}
+	else
+	{
+		//printk("Current PDRatio:%u, PauseThreshold:%u, DefaultPauseThreshold:%u, don't incress PauseThreshold.\n",
+		//		hw->PDRatio, hw->PauseThreshold, hw->DefaultPauseThreshold);
+	}
+
+	return;
+}
+
+static
+void crystalhd_flea_runtime_power_dn(struct crystalhd_hw *hw)
+{
+	uint32_t regVal;
+	uint32_t pollCnt;
+
+	//printk("RT PD \n");
+
+	hw->DrvPauseCnt++;
+
+	// NAREN This function stops the decoder clocks including the AVD, ARM and DRAM
+	// It powers down the DRAM device and places the DRAM into self-refresh
+
+#ifdef _POWER_HANDLE_AVD_WATCHDOG_
+	// Make sure the timeouts do not happen
+	// Because the AVD drops to a debug prompt and stops decoding if it hits any watchdogs
+	//Outer Loop Watchdog timer
+	regVal = hw->pfnReadDevRegister(hw->adp,
+		BCHP_DECODE_CPUREGS_0_REG_WATCHDOG_TMR);
+
+	hw->OLWatchDogTimer = regVal;
+	hw->pfnWriteDevRegister(hw->adp,
+		BCHP_DECODE_CPUREGS_0_REG_WATCHDOG_TMR,
+		0xffffffff);
+
+	//Inner Loop Watchdog timer
+	regVal = hw->pfnReadDevRegister(hw->adp,
+		BCHP_DECODE_CPUREGS2_0_REG_WATCHDOG_TMR);
+
+	hw->ILWatchDogTimer = regVal;
+	hw->pfnWriteDevRegister(hw->adp,
+		BCHP_DECODE_CPUREGS2_0_REG_WATCHDOG_TMR,
+		0xffffffff);
+#endif
+
+	// Stop memory arbiter first to freese memory access
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL, BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL_arb_disable_Disable);
+
+	// delay at least 15us for memory transactions to complete
+	// udelay(15);
+
+	/* Wait for MEMC to become idle. Continue even if we are no since worst case this would just mean higher power consumption */
+	pollCnt=0;
+	while (pollCnt++ <= 400) //200
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_CTL_STATUS);
+
+		if(regVal & BCHP_DDR23_CTL_REGS_0_CTL_STATUS_idle_MASK)
+		{
+			// udelay(10);
+			break;
+		}
+		udelay(10);
+	}
+
+	/*If we failed Start the arbiter and return*/
+	if(!(regVal & BCHP_DDR23_CTL_REGS_0_CTL_STATUS_idle_MASK))
+	{
+		printk("RT PD : failed Start the arbiter and return.\n");
+		hw->pfnWriteDevRegister(hw->adp,
+			BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL,
+			BCHP_PRI_ARB_CONTROL_REGS_MASTER_CTL_arb_disable_Enable);
+		return;
+	}
+
+	/* Disable the AVD, ARM and BLINK clocks*/
+	/*regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+
+	regVal |=	BCHP_CLK_PM_CTRL_DIS_ARM_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_216_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_216_CLK_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regValE);*/
+
+	/* turn on self-refresh */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2);
+	regVal |= BCHP_DDR23_CTL_REGS_0_PARAMS2_clke_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2, regVal);
+
+	/* Issue refresh cycle */
+	hw->pfnWriteDevRegister(hw->adp,	BCHP_DDR23_CTL_REGS_0_REFRESH_CMD, 0x60);
+
+	/* Stop Refresh Cycles from controller */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0);
+	regVal &= ~(BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0_enable_MASK);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0, regVal);
+
+	/* Check if we are in self-refresh. Continue even if we are no since worst case this would just mean higher power consumption */
+	pollCnt=0;
+	while(pollCnt++ < 100)
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_CTL_STATUS);
+
+		if(!(regVal & BCHP_DDR23_CTL_REGS_0_CTL_STATUS_clke_MASK))
+			break;
+	}
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+
+	regVal |=	BCHP_CLK_PM_CTRL_DIS_ARM_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_108_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_BLINK_216_CLK_MASK |
+				BCHP_CLK_PM_CTRL_DIS_AVD_216_CLK_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regVal);
+
+	/* Power down PHY and stop clocks on DRAM */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL);
+
+	regVal |=	BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_idle_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dm_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dq_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_read_enb_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dqs_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_clk_iddq_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL);
+
+	regVal |=	BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_idle_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dm_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dq_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_read_enb_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dqs_iddq_MASK |
+				BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_clk_iddq_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL);
+	regVal |= BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL_pwrdn_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL);
+	regVal |= BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL_pwrdn_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL);
+	regVal |=	BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_idle_MASK |
+				BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_ctl_iddq_MASK |
+				BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_rxenb_MASK |
+				BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_cke_reb_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL, regVal);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL, BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL_DIS_DDR_CLK_MASK);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+	regVal |= BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG_PWRDN_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG, regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL);
+	regVal |= BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL_pwrdn_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL, regVal);
+
+	/* Finally clock off the DRAM controller */
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+	regVal |=	BCHP_CLK_PM_CTRL_DIS_DDR_108_CLK_MASK |	BCHP_CLK_PM_CTRL_DIS_DDR_216_CLK_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regVal);
+
+	// udelay(20);
+
+	//printk("RT Power Down Flea Complete\n");
+
+	// Measure how much time we spend in idle
+	rdtscll(hw->TickStartInPD);
+
+	return;
+}
+
+bool crystalhd_flea_detect_fw_alive(struct crystalhd_hw *hw)
+{
+	uint32_t pollCnt		= 0;
+	uint32_t hbCnt			= 0;
+	uint32_t heartBeatReg1	= 0;
+	uint32_t heartBeatReg2	= 0;
+	bool	 bRetVal		= false;
+
+	heartBeatReg1 = hw->pfnReadDevRegister(hw->adp, HEART_BEAT_REGISTER);
+	while(1)
+	{
+		heartBeatReg2 = hw->pfnReadDevRegister(hw->adp, HEART_BEAT_REGISTER);
+		if(heartBeatReg1 != heartBeatReg2) {
+			hbCnt++;
+			heartBeatReg1 = heartBeatReg2;
+		}
+
+		if(hbCnt >= HEART_BEAT_POLL_CNT) {
+			bRetVal = true;
+			break;
+		}
+
+		pollCnt++;
+		if(pollCnt >= FLEA_MAX_POLL_CNT) {
+			bRetVal = false;
+			break;
+		}
+
+		msleep_interruptible(1);
+	}
+
+	return bRetVal;
+}
+
+void crystalhd_flea_handle_PicQSts_intr(struct crystalhd_hw *hw)
+{
+	uint32_t	newChBitmap=0;
+
+	newChBitmap = hw->pfnReadDevRegister(hw->adp, RX_DMA_PIC_QSTS_MBOX);
+
+	hw->PicQSts = newChBitmap;
+
+	/* -- For link we were enabling the capture on format change
+	   -- For Flea, we will get a PicQSts interrupt where we will
+	   -- enable the capture. */
+
+	if(hw->RxCaptureState != 1)
+	{
+		hw->RxCaptureState = 1;
+	}
+}
+
+void crystalhd_flea_update_tx_buff_info(struct crystalhd_hw *hw)
+{
+	TX_INPUT_BUFFER_INFO	TxBuffInfo;
+	uint32_t ReadSzInDWords=0;
+
+	ReadSzInDWords = (sizeof(TxBuffInfo) - sizeof(TxBuffInfo.Reserved))/4;
+	hw->pfnDevDRAMRead(hw, hw->TxBuffInfoAddr, ReadSzInDWords, (uint32_t*)&TxBuffInfo);
+
+	if(TxBuffInfo.DramBuffAdd % 4)
+	{
+		printk("Tx Err:: DWORD UNAligned Tx Addr. Not Updating\n");
+		return;
+	}
+
+	hw->TxFwInputBuffInfo.DramBuffAdd			= TxBuffInfo.DramBuffAdd;
+	hw->TxFwInputBuffInfo.DramBuffSzInBytes		= TxBuffInfo.DramBuffSzInBytes;
+	hw->TxFwInputBuffInfo.Flags					= TxBuffInfo.Flags;
+	hw->TxFwInputBuffInfo.HostXferSzInBytes		= TxBuffInfo.HostXferSzInBytes;
+	hw->TxFwInputBuffInfo.SeqNum				= TxBuffInfo.SeqNum;
+
+	return;
+}
+
+// was HWFleaNotifyFllChange
+void crystalhd_flea_notify_fll_change(struct crystalhd_hw *hw, bool bCleanupContext)
+{
+	unsigned long flags = 0;
+	uint32_t freeListLen = 0;
+	/*
+	* When we are doing the cleanup we should update DRAM only if the
+	* firmware is running. So Detect the heart beat.
+	*/
+	if(bCleanupContext && (!crystalhd_flea_detect_fw_alive(hw)))
+		return;
+
+	spin_lock_irqsave(&hw->lock, flags);
+	freeListLen = crystalhd_dioq_count(hw->rx_freeq);
+	hw->pfnDevDRAMWrite(hw, hw->FleaFLLUpdateAddr, 1, &freeListLen);
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return;
+}
+
+
+static
+void crystalhd_flea_init_power_state(struct crystalhd_hw *hw)
+{
+	hw->FleaEnablePWM = false;	// disable by default
+	hw->FleaPowerState = FLEA_PS_NONE;
+}
+
+static
+bool crystalhd_flea_set_power_state(struct crystalhd_hw *hw,
+					FLEA_POWER_STATES	NewState)
+{
+	bool StChangeSuccess=false;
+	uint32_t tempFLL = 0;
+	uint32_t freeListLen = 0;
+	BC_STATUS sts;
+	crystalhd_rx_dma_pkt *rx_pkt = NULL;
+
+	freeListLen = crystalhd_dioq_count(hw->rx_freeq);
+
+	switch(NewState)
+	{
+		case FLEA_PS_ACTIVE:
+		{
+			/*Transition to Active State*/
+			if(hw->FleaPowerState == FLEA_PS_LP_PENDING)
+			{
+				StChangeSuccess = true;
+				hw->FleaPowerState = FLEA_PS_ACTIVE;
+				/* Write the correct FLL to FW */
+				hw->pfnDevDRAMWrite(hw,
+									hw->FleaFLLUpdateAddr,
+									1,
+									&freeListLen);
+				// We need to check to post here because we may never get a context to post otherwise
+				if(hw->PicQSts != 0)
+				{
+					rx_pkt = crystalhd_dioq_fetch(hw->rx_freeq);
+					if (rx_pkt)
+						sts = hw->pfnPostRxSideBuff(hw, rx_pkt);
+				}
+				//printk(" Success\n");
+
+			}else if(hw->FleaPowerState == FLEA_PS_LP_COMPLETE){
+				crystalhd_flea_runtime_power_up(hw);
+				StChangeSuccess = true;
+				hw->FleaPowerState = FLEA_PS_ACTIVE;
+				/* Write the correct FLL to FW */
+				hw->pfnDevDRAMWrite(hw,
+										hw->FleaFLLUpdateAddr,
+										1,
+										&freeListLen);
+				/* Now check if we missed processing PiQ and TXFIFO interrupts when we were in power down */
+				if (hw->PwrDwnPiQIntr)
+				{
+					crystalhd_flea_handle_PicQSts_intr(hw);
+					hw->PwrDwnPiQIntr = false;
+				}
+				// We need to check to post here because we may never get a context to post otherwise
+				if(hw->PicQSts != 0)
+				{
+					rx_pkt = crystalhd_dioq_fetch(hw->rx_freeq);
+					if (rx_pkt)
+						sts = hw->pfnPostRxSideBuff(hw, rx_pkt);
+				}
+				if (hw->PwrDwnTxIntr)
+				{
+					crystalhd_flea_update_tx_buff_info(hw);
+					hw->PwrDwnTxIntr = false;
+				}
+
+			}
+			break;
+		}
+
+		case FLEA_PS_LP_PENDING:
+		{
+			if(hw->FleaPowerState != FLEA_PS_ACTIVE)
+			{
+				break;
+			}
+
+			//printk(" Success\n");
+
+			StChangeSuccess = true;
+			/* Write 0 FLL to FW to prevent it from sending PQ*/
+			hw->pfnDevDRAMWrite(hw,
+									hw->FleaFLLUpdateAddr,
+									1,
+									&tempFLL);
+			hw->FleaPowerState = FLEA_PS_LP_PENDING;
+			break;
+		}
+
+		case FLEA_PS_LP_COMPLETE:
+		{
+			if( (hw->FleaPowerState == FLEA_PS_ACTIVE) ||
+			    (hw->FleaPowerState == FLEA_PS_LP_PENDING)) {
+				/* Write 0 FLL to FW to prevent it from sending PQ*/
+				hw->pfnDevDRAMWrite(hw,
+									hw->FleaFLLUpdateAddr,
+									1,
+									&tempFLL);
+				crystalhd_flea_runtime_power_dn(hw);
+				StChangeSuccess = true;
+				hw->FleaPowerState = FLEA_PS_LP_COMPLETE;
+
+			}
+			break;
+		}
+		default:
+			break;
+	}
+
+	return StChangeSuccess;
+}
+
+/*
+* Look At Different States and List Status and decide on
+* Next Logical State To Be In.
+*/
+static
+void crystalhd_flea_set_next_power_state(struct crystalhd_hw *hw,
+						FLEA_STATE_CH_EVENT		PowerEvt)
+{
+	FLEA_POWER_STATES NextPS;
+	NextPS = hw->FleaPowerState;
+
+	if( hw->FleaEnablePWM == false )
+	{
+		hw->FleaPowerState = FLEA_PS_ACTIVE;
+		return;
+	}
+
+// 	printk("Trying Power State Transition from %x Because Of Event:%d \n",
+// 			hw->FleaPowerState,
+// 			PowerEvt);
+
+	if(PowerEvt == FLEA_EVT_STOP_DEVICE)
+	{
+		hw->FleaPowerState = FLEA_PS_STOPPED;
+		return;
+	}
+
+	if(PowerEvt == FLEA_EVT_START_DEVICE)
+	{
+		hw->FleaPowerState = FLEA_PS_ACTIVE;
+		return;
+	}
+
+	switch(hw->FleaPowerState)
+	{
+		case FLEA_PS_ACTIVE:
+		{
+			if(PowerEvt == FLEA_EVT_FLL_CHANGE)
+			{
+				/*Ready List Was Decremented. */
+				//printk("1:TxL0Sts:%x TxL1Sts:%x EmptyCnt:%x RxL0Sts:%x RxL1Sts:%x FwCmdCnt:%x\n",
+				//	hw->TxList0Sts,
+				//	hw->TxList1Sts,
+				//	hw->EmptyCnt,
+				//	hw->rx_list_sts[0],
+				//	hw->rx_list_sts[1],
+				//	hw->FwCmdCnt);
+
+				if( (hw->TxList0Sts == ListStsFree)	&&
+					(hw->TxList1Sts == ListStsFree) &&
+					(!hw->EmptyCnt) && /*We have Not Indicated Any Empty Fifo to Application*/
+					(!hw->SingleThreadAppFIFOEmpty) && /*for single threaded apps*/
+					(!(hw->rx_list_sts[0] && rx_waiting_y_intr)) &&
+					(!(hw->rx_list_sts[1] && rx_waiting_y_intr)) &&
+					(!hw->FwCmdCnt))
+				{
+					NextPS = FLEA_PS_LP_COMPLETE;
+				}else{
+					NextPS = FLEA_PS_LP_PENDING;
+				}
+			}
+
+			break;
+		}
+
+		case FLEA_PS_LP_PENDING:
+		{
+			if( (PowerEvt == FLEA_EVT_FW_CMD_POST) ||
+				(PowerEvt == FLEA_EVT_FLL_CHANGE))
+			{
+				NextPS = FLEA_PS_ACTIVE;
+			}else if(PowerEvt == FLEA_EVT_CMD_COMP){
+
+				//printk("2:TxL0Sts:%x TxL1Sts:%x EmptyCnt:%x STAppFIFOEmpty:%x RxL0Sts:%x RxL1Sts:%x FwCmdCnt:%x\n",
+				//	hw->TxList0Sts,
+				//	hw->TxList1Sts,
+				//	hw->EmptyCnt,
+				//	hw->SingleThreadAppFIFOEmpty,
+				//	hw->rx_list_sts[0],
+				//	hw->rx_list_sts[1],
+				//	hw->FwCmdCnt);
+
+				if( (hw->TxList0Sts == ListStsFree)	&&
+					(hw->TxList1Sts == ListStsFree) &&
+					(!hw->EmptyCnt) &&	/*We have Not Indicated Any Empty Fifo to Application*/
+					(!hw->SingleThreadAppFIFOEmpty) && /*for single threaded apps*/
+					(!(hw->rx_list_sts[0] && rx_waiting_y_intr)) &&
+					(!(hw->rx_list_sts[1] && rx_waiting_y_intr)) &&
+					(!hw->FwCmdCnt))
+				{
+					NextPS = FLEA_PS_LP_COMPLETE;
+				}
+			}
+			break;
+		}
+		case FLEA_PS_LP_COMPLETE:
+		{
+			if( (PowerEvt == FLEA_EVT_FLL_CHANGE) ||
+				(PowerEvt == FLEA_EVT_FW_CMD_POST))
+			{
+				NextPS = FLEA_PS_ACTIVE;
+			}
+
+			break;
+		}
+		default:
+		{
+			printk("Invalid Flea Power State %x\n",
+				hw->FleaPowerState);
+
+			break;
+		}
+	}
+
+	if(hw->FleaPowerState != NextPS)
+	{
+		//printk("%s:State Transition [FromSt:%x ToSt:%x] Because Of Event:%d \n",
+		//	__FUNCTION__,
+		//	hw->FleaPowerState,
+		//	NextPS,
+		//	PowerEvt);
+
+		crystalhd_flea_set_power_state(hw,NextPS);
+	}
+
+	return;
+}
+
+//// was FleaSetRxPicFireAddr
+//static
+//void crystalhd_flea_set_rx_pic_fire_addr(struct crystalhd_hw *hw, uint32_t BorshContents)
+//{
+//	hw->FleaRxPicDelAddr = BorshContents + 1 + HOST_TO_FW_PIC_DEL_INFO_ADDR;
+//	hw->FleaFLLUpdateAddr = BorshContents + 1 + HOST_TO_FW_FLL_ADDR;
+//
+//	return;
+//}
+
+void crystalhd_flea_init_temperature_measure (struct crystalhd_hw *hw, bool bTurnOn)
+{
+	hw->TemperatureRegVal=0;
+
+	if(bTurnOn) {
+		hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_TEMP_MON_CTRL, 0x3);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_TEMP_MON_CTRL, 0x203);
+	} else {
+		hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_TEMP_MON_CTRL, 0x103);
+	}
+
+	return;
+}
+
+// was HwFleaUpdateTempInfo
+void crystalhd_flea_update_temperature(struct crystalhd_hw *hw)
+{
+	uint32_t	regVal = 0;
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_TEMP_MON_STATUS);
+	hw->TemperatureRegVal = regVal;
+
+	return;
+}
+
+/**
+* crystalhd_flea_download_fw - Write data to DRAM area.
+* @adp: Adapter instance
+* @pBuffer: Buffer pointer for the FW data.
+* @buffSz: data size in bytes.
+*
+* Return:
+*	Status.
+*
+* Flea firmware download routine.
+*/
+BC_STATUS crystalhd_flea_download_fw(struct crystalhd_hw *hw, uint8_t *pBuffer, uint32_t buffSz)
+{
+	uint32_t pollCnt=0,regVal=0;
+	uint32_t borchStachAddr=0;
+	uint32_t *pCmacSig=NULL,cmacOffset=0,i=0;
+	//uint32_t BuffSz = (BuffSzInDWords * 4);
+	//uint32_t HBCnt=0;
+
+	bool bRetVal = true;
+
+	dev_dbg(&hw->adp->pdev->dev, "[%s]: Sz:%d\n", __func__, buffSz);
+
+///*
+//-- Step 1. Enable the SRCUBBING and DRAM SCRAMBLING
+//-- Step 2. Poll for SCRAM_KEY_DONE_INT.
+//-- Step 3. Write the BORCH and STARCH addresses.
+//-- Step 4. Write the firmware to DRAM.
+//-- Step 5. Write the CMAC to SCRUB->CMAC registers.
+//-- Step 6. Write the ARM run bit to 1.
+//-- Step 7. Poll for BOOT verification done interrupt.
+//*/
+
+//	/* First validate that we got data in the FW buffer */
+	if (buffSz == 0)
+		return BC_STS_ERROR;
+
+//-- Step 1. Enable the SRCUBBING and DRAM SCRAMBLING.
+//   Can we set both the bits at the same time?? Security Arch Doc describes the steps
+//   and the first step is to enable scrubbing and then scrambling.
+
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 1. Enable scrubbing\n");
+
+	//Enable Scrubbing
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_SCRUB_CTRL_SCRUB_ENABLE);
+	regVal |= SCRUB_ENABLE_BIT;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SCRUB_CTRL_SCRUB_ENABLE, regVal);
+
+	//Enable Scrambling
+	regVal |= DRAM_SCRAM_ENABLE_BIT;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SCRUB_CTRL_SCRUB_ENABLE, regVal);
+
+
+//-- Step 2. Poll for SCRAM_KEY_DONE_INT.
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 2. Poll for SCRAM_KEY_DONE_INT\n");
+
+	pollCnt=0;
+	while(pollCnt < FLEA_MAX_POLL_CNT)
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_WRAP_MISC_INTR2_PCI_STATUS);
+
+		if(regVal & SCRAM_KEY_DONE_INT_BIT)
+			break;
+
+		pollCnt++;
+		msleep_interruptible(1); /*1 Milli Sec delay*/
+	}
+
+	//-- Will Assert when we do not see SCRAM_KEY_DONE_INTTERRUPT
+	if(!(regVal & SCRAM_KEY_DONE_INT_BIT))
+	{
+		dev_err(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 2. Did not get scram key done interrupt.\n");
+		return BC_STS_ERROR;
+	}
+
+	/*Clear the interrupts by writing the register value back*/
+	regVal &= 0x00FFFFFF; //Mask off the reserved bits.[24-31]
+	hw->pfnWriteDevRegister(hw->adp, BCHP_WRAP_MISC_INTR2_PCI_CLEAR, regVal);
+
+//-- Step 3. Write the BORCH and STARCH addresses.
+	borchStachAddr = GetScrubEndAddr(buffSz);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SCRUB_CTRL_BORCH_END_ADDRESS, borchStachAddr);
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SCRUB_CTRL_STARCH_END_ADDRESS, borchStachAddr);
+
+	/*
+	 *	Now the command address is
+	 *	relative to firmware file size.
+	 */
+	//FWIFSetFleaCmdAddr(pHWExt->pFwExt,
+	//		borchStachAddr+1+DDRADDR_4_FWCMDS);
+
+	hw->fwcmdPostAddr = borchStachAddr+1+DDRADDR_4_FWCMDS;
+	hw->fwcmdPostMbox = FW_CMD_POST_MBOX;
+	hw->fwcmdRespMbox = FW_CMD_RES_MBOX;
+	//FleaSetRxPicFireAddr(pHWExt,borchStachAddr);
+	hw->FleaRxPicDelAddr = borchStachAddr + 1 + HOST_TO_FW_PIC_DEL_INFO_ADDR;
+	hw->FleaFLLUpdateAddr = borchStachAddr + 1 + HOST_TO_FW_FLL_ADDR;
+
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 3. Write the BORCH and STARCH addresses. %x:%x, %x:%x\n",
+			BCHP_SCRUB_CTRL_BORCH_END_ADDRESS,
+			borchStachAddr,
+			BCHP_SCRUB_CTRL_STARCH_END_ADDRESS,
+			borchStachAddr );
+
+//-- Step 4. Write the firmware to DRAM. [Without the Signature, 32-bit access to DRAM]
+
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 4. Write the firmware to DRAM. Sz:%d Bytes\n",
+			buffSz - FLEA_FW_SIG_LEN_IN_BYTES - LENGTH_FIELD_SIZE);
+
+	hw->pfnDevDRAMWrite(hw, FW_DOWNLOAD_START_ADDR, (buffSz - FLEA_FW_SIG_LEN_IN_BYTES - LENGTH_FIELD_SIZE)/4, (uint32_t *)pBuffer);
+
+// -- Step 5. Write the signature to CMAC register.
+/*
+-- This is what we need to write to CMAC registers.
+==================================================================================
+Register							Offset				Boot Image CMAC
+														Value
+==================================================================================
+BCHP_SCRUB_CTRL_BI_CMAC_31_0		0x000f600c			CMAC Bits[31:0]
+BCHP_SCRUB_CTRL_BI_CMAC_63_32		0x000f6010			CMAC Bits[63:32]
+BCHP_SCRUB_CTRL_BI_CMAC_95_64		0x000f6014			CMAC Bits[95:64]
+BCHP_SCRUB_CTRL_BI_CMAC_127_96		0x000f6018			CMAC Bits[127:96]
+==================================================================================
+*/
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 5. Write the signature to CMAC register.\n");
+	cmacOffset = buffSz - FLEA_FW_SIG_LEN_IN_BYTES;
+	pCmacSig = (uint32_t *) &pBuffer[cmacOffset];
+
+	for(i=0;i < FLEA_FW_SIG_LEN_IN_DWORD;i++)
+	{
+		uint32_t offSet = (BCHP_SCRUB_CTRL_BI_CMAC_127_96 - (i * 4));
+
+		hw->pfnWriteDevRegister(hw->adp, offSet, bswap_32_1(*pCmacSig));
+
+		pCmacSig++;
+	}
+
+//-- Step 6. Write the ARM run bit to 1.
+//   We need a write back because we do not want to change other bits
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 6. Write the ARM run bit to 1.\n");
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_ARMCR4_BRIDGE_REG_BRIDGE_CTL);
+	regVal |= ARM_RUN_REQ_BIT;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_ARMCR4_BRIDGE_REG_BRIDGE_CTL, regVal);
+
+//-- Step 7. Poll for Boot Verification done/failure interrupt.
+	dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 7. Poll for Boot Verification done/failure interrupt.\n");
+
+	pollCnt=0;
+	while(1)
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_WRAP_MISC_INTR2_PCI_STATUS);
+
+		if(regVal & BOOT_VER_FAIL_BIT ) //|| regVal & SHARF_ERR_INTR)
+		{
+			dev_err(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 7. Error bit occured. RetVal:%x\n", regVal);
+
+			bRetVal = false;
+			break;
+		}
+
+		if(regVal & BOOT_VER_DONE_BIT)
+		{
+			dev_dbg(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 7. Done  RetVal:%x\n", regVal);
+
+			bRetVal = true; /*This is the only place we return TRUE from*/
+			break;
+		}
+
+		pollCnt++;
+		if( pollCnt >= FLEA_MAX_POLL_CNT )
+		{
+			dev_err(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 7. Both done and failure bits are not set.\n");
+			bRetVal = false;
+			break;
+		}
+
+		msleep_interruptible(1); /*1 Milli Sec delay*/
+	}
+
+	if( !bRetVal )
+	{
+		dev_info(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 7. Firmware image signature failure.\n");
+		return BC_STS_ERROR;
+	}
+
+	/*Clear the interrupts by writing the register value back*/
+	regVal &= 0x00FFFFFF; //Mask off the reserved bits.[24-31]
+	hw->pfnWriteDevRegister(hw->adp, BCHP_WRAP_MISC_INTR2_PCI_CLEAR, regVal);
+
+	msleep_interruptible(10); /*10 Milli Sec delay*/
+
+/*
+-- It was seen on Dell390 systems that the firmware command was fired before the
+-- firmware was actually ready to accept the firmware commands. The driver did
+-- not recieve a response for the firmware commands and this was causing the DIL to timeout
+-- ,reclaim the resources and crash. The following code looks for the heartbeat and
+-- to make sure that we return from this function only when we get the heart beat making sure
+-- that the firmware is running.
+*/
+
+	/*
+	 * By default enable everything except the RX_MBOX_WRITE_WRKARND [scratch workaround]
+	 * to be backward compatible. The firmware will enable the workaround
+	 * by writing to scratch 5. In future the firmware can disable the workarounds
+	 * and we will not have to WHQL the driver at all.
+	 */
+	//hw->EnWorkArounds = RX_PIC_Q_STS_WRKARND | RX_DRAM_WRITE_WRKARND;
+	bRetVal = crystalhd_flea_detect_fw_alive(hw);
+	if( !bRetVal )
+	{
+		dev_info(&hw->adp->pdev->dev,"[crystalhd_flea_download_fw]: step 8. Detect firmware heart beat failed.\n");
+		return BC_STS_ERROR;
+	}
+
+	/*if(bRetVal == TRUE)
+	{
+		ULONG EnaWorkArnds;
+		hw->pfnReadDevRegister(hw->adp,
+			RX_POST_CONFIRM_SCRATCH,
+			&EnaWorkArnds);
+
+		if( ((EnaWorkArnds & 0xffff0000) >> 16) ==	FLEA_WORK_AROUND_SIG)
+		{
+			pHWExt->EnWorkArounds = EnaWorkArnds & 0xffff;
+			DebugPrint(BRCM_COMP_ID,
+				BRCM_DBG_LEVEL,
+				"WorkArounds Enable Value[%x]\n",pHWExt->EnWorkArounds);
+		}
+	}*/
+
+	dev_info(&hw->adp->pdev->dev, "[%s]: Complete.\n", __func__);
+	return BC_STS_SUCCESS;
+}
+
+bool crystalhd_flea_start_device(struct crystalhd_hw *hw)
+{
+	uint32_t	regVal	= 0;
+	bool		bRetVal = false;
+
+	/*
+	-- Issue Core reset to bring in the default values in place
+	*/
+	crystalhd_flea_core_reset(hw);
+
+	/*
+	-- If the gisb arbitar register is not set to some other value
+	-- and the firmware crashes, we see a NMI since the hardware did
+	-- not respond to a register read at all. The PCI-E trace confirms the problem.
+	-- Right now we are setting the register values to 0x7e00 and will check later
+	-- what should be the correct value to program.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SUN_GISB_ARB_TIMER, 0xd80);
+
+	/*
+	-- Disable all interrupts
+	*/
+	crystalhd_flea_clear_interrupts(hw);
+	crystalhd_flea_disable_interrupts(hw);
+
+	/*
+	-- Enable the option for getting the done count in
+	-- Rx DMA engine.
+	*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_DMA_DEBUG_OPTIONS_REG);
+	regVal |= 0x10;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_DMA_DEBUG_OPTIONS_REG, regVal);
+
+	/*
+	-- Enable the TX DMA Engine once on startup.
+	-- This is a new bit added.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_TX_DMA_CTRL, 0x01);
+
+	/*
+	-- Enable the RX3 DMA Engine once on startup.
+	-- This is a new bit added.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_HIF_DMA_CTRL, 0x01);
+
+	/*
+	-- Set the Run bit for RX-Y and RX-UV DMA engines.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_Y_RX_SW_DESC_LIST_CTRL_STS, 0x01);
+
+	/*
+	-- Make sure Early L1 is disabled - NAREN - This will not prevent the device from entering L1 under active mode
+	*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_MISC_PERST_CLOCK_CTRL);
+	regVal &= ~BCHP_MISC_PERST_CLOCK_CTRL_EARLY_L1_EXIT_MASK;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC_PERST_CLOCK_CTRL, regVal);
+
+	crystalhd_flea_init_dram(hw);
+
+	msleep_interruptible(5);
+
+	// Enable the Single Shot Transaction on PCI by disabling the
+	// bit 29 of transaction configuration register
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_PCIE_TL_TRANSACTION_CONFIGURATION);
+	regVal &= (~(BC_BIT(29)));
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PCIE_TL_TRANSACTION_CONFIGURATION, regVal);
+
+	crystalhd_flea_init_temperature_measure(hw,true);
+
+	crystalhd_flea_init_power_state(hw);
+	crystalhd_flea_set_next_power_state(hw, FLEA_EVT_START_DEVICE);
+
+	/*
+	-- Enable all interrupts
+	*/
+	crystalhd_flea_clear_interrupts(hw);
+	crystalhd_flea_enable_interrupts(hw);
+
+	/*
+	-- This is the only time we set this pointer for Flea.
+	-- Since there is no stop the pointer is not reset anytime....
+	-- except for fatal errors.
+	*/
+	hw->rx_list_post_index = 0;
+	hw->RxCaptureState = 0;
+
+	msleep_interruptible(1);
+
+	return bRetVal;
+}
+
+
+bool crystalhd_flea_stop_device(struct crystalhd_hw *hw)
+{
+	uint32_t regVal=0, pollCnt=0;
+
+	/*
+	-- Issue the core reset so that we
+	-- make sure there is nothing running.
+	*/
+	crystalhd_flea_core_reset(hw);
+
+	crystalhd_flea_init_temperature_measure(hw, false);
+
+	/*
+	-- If the gisb arbitrater register is not set to some other value
+	-- and the firmware crashes, we see a NMI since the hardware did
+	-- not respond to a register read at all. The PCI-E trace confirms the problem.
+	-- Right now we are setting the register values to 0x7e00 and will check later
+	-- what should be the correct value to program.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_SUN_GISB_ARB_TIMER, 0xd80);
+
+	/*
+	-- Disable the TX DMA Engine once on shutdown.
+	-- This is a new bit added.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_TX_DMA_CTRL, 0x0);
+
+	/*
+	-- Disable the RX3 DMA Engine once on Stop.
+	-- This is a new bit added.
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_HIF_DMA_CTRL, 0x0);
+
+	/*
+	-- Clear the RunStop Bit For RX DMA Control
+	*/
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_Y_RX_SW_DESC_LIST_CTRL_STS, 0x0);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_PRI_ARB_CONTROL_REGS_REFRESH_CTL_0, 0x0);
+
+	// * Wait for MEMC to become idle
+	pollCnt=0;
+	while (1)
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_CTL_STATUS);
+
+		if(regVal & BCHP_DDR23_CTL_REGS_0_CTL_STATUS_idle_MASK)
+			break;
+
+		pollCnt++;
+		if(pollCnt >= 100)
+			break;
+
+		msleep_interruptible(1);
+	}
+
+	/*First Disable the AVD and ARM before disabling the DRAM*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+
+	regVal = BCHP_CLK_PM_CTRL_DIS_ARM_CLK_MASK |
+			 BCHP_CLK_PM_CTRL_DIS_AVD_CLK_MASK |
+			 BCHP_CLK_PM_CTRL_DIS_AVD_108_CLK_MASK |
+			 BCHP_CLK_PM_CTRL_DIS_AVD_216_CLK_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regVal);
+
+	/*
+	-- Disable the interrupt after disabling the ARM and AVD.
+	-- We should be able to access the registers because we still
+	-- have not disabled the clock for blink block. We disable the
+	-- blick 108 abd 216 clock at the end of this function.
+	*/
+	crystalhd_flea_clear_interrupts(hw);
+	crystalhd_flea_disable_interrupts(hw);
+
+	/*Now try disabling the DRAM.*/
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2);
+
+	regVal |= BCHP_DDR23_CTL_REGS_0_PARAMS2_clke_MASK;
+
+	// * disable CKE
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_PARAMS2, regVal);
+
+	// * issue refresh command
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_REFRESH_CMD, 0x60);
+
+	pollCnt=0;
+	while(1)
+	{
+		regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_CTL_REGS_0_CTL_STATUS);
+
+		if(!(regVal & BCHP_DDR23_CTL_REGS_0_CTL_STATUS_clke_MASK))
+			break;
+
+		pollCnt++;
+		if(pollCnt >= 100)
+			break;
+
+		msleep_interruptible(1);
+	}
+
+	// * Enable DDR clock, DM and READ_ENABLE pads power down and force into the power down
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL,
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_idle_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dm_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dq_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_read_enb_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_dqs_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_0_IDLE_PAD_CONTROL_clk_iddq_MASK);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL,
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_idle_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dm_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dq_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_read_enb_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_dqs_iddq_MASK |
+							BCHP_DDR23_PHY_BYTE_LANE_1_IDLE_PAD_CONTROL_clk_iddq_MASK);
+
+	// * Power down BL LDO cells
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL,
+							BCHP_DDR23_PHY_BYTE_LANE_0_CLOCK_REG_CONTROL_pwrdn_MASK);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL,
+							BCHP_DDR23_PHY_BYTE_LANE_1_CLOCK_REG_CONTROL_pwrdn_MASK);
+
+	// * Enable DDR control signal pad power down and force into the power down
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL,
+							BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_idle_MASK |
+							BCHP_DDR23_PHY_CONTROL_REGS_IDLE_PAD_CONTROL_ctl_iddq_MASK);
+
+	// * Disable ddr phy clock
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL,
+							BCHP_DDR23_PHY_CONTROL_REGS_CLK_PM_CTRL_DIS_DDR_CLK_MASK);
+
+	// * Disable PLL output
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG,
+							regVal & ~BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG_ENB_CLKOUT_MASK);
+
+	// * Power down addr_ctl LDO cells
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL,
+							BCHP_DDR23_PHY_CONTROL_REGS_CLOCK_REG_CONTROL_pwrdn_MASK);
+
+	// * Power down the PLL
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG,
+							regVal | BCHP_DDR23_PHY_CONTROL_REGS_PLL_CONFIG_PWRDN_MASK);
+
+	// shut down the PLL1
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PLL1_CTRL);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PLL1_CTRL,
+							regVal | BCHP_CLK_PLL1_CTRL_POWERDOWN_MASK);
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PLL0_ARM_DIV,	0xff);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, BCHP_CLK_PM_CTRL);
+
+	regVal |= BCHP_CLK_PM_CTRL_DIS_SUN_27_LOW_PWR_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_SUN_108_LOW_PWR_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_MISC_OTP_9_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_ARM_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_AVD_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_AVD_108_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_BLINK_108_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_MISC_108_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_BLINK_216_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_DDR_108_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_DDR_216_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_AVD_216_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_MISC_216_CLK_MASK |
+			  BCHP_CLK_PM_CTRL_DIS_SUN_216_CLK_MASK;
+
+	hw->pfnWriteDevRegister(hw->adp, BCHP_CLK_PM_CTRL, regVal);
+
+	crystalhd_flea_set_next_power_state(hw, FLEA_EVT_STOP_DEVICE);
+	return true;
+}
+
+bool
+crystalhd_flea_wake_up_hw(struct crystalhd_hw *hw)
+{
+	if(hw->FleaPowerState != FLEA_PS_ACTIVE)
+	{
+		crystalhd_flea_set_next_power_state(hw,	FLEA_EVT_FLL_CHANGE);
+	}
+
+	// Now notify HW of the number of entries in the Free List
+	// This starts up the channel bitmap delivery
+	crystalhd_flea_notify_fll_change(hw, false);
+
+	hw->WakeUpDecodeDone = true;
+
+	return true;
+}
+
+bool crystalhd_flea_check_input_full(struct crystalhd_hw *hw, uint32_t needed_sz, uint32_t *empty_sz, bool b_188_byte_pkts, uint8_t *flags)
+{
+	uint32_t				regVal=0;
+	TX_INPUT_BUFFER_INFO	*pTxBuffInfo;
+	uint32_t				FlagsAddr=0;
+
+	*empty_sz = 0;
+//	*DramAddrOut=0;
+
+
+	/* Add condition here to wake up the HW in case some application is trying to do TX before starting RX - like FP */
+	/* To prevent deadlocks. We are called here from Synchronized context so we can safely call this directly */
+
+	if(hw->WakeUpDecodeDone != true)
+	{
+		// Only wake up the HW if we are either being called from a single threaded app - like FP
+		// or if we are not checking for the input buffer size as just a test
+		if(*flags == 0)
+			crystalhd_flea_wake_up_hw(hw);
+		else {
+			*empty_sz = 2 * 1024 * 1024; // FW Buffer size
+			//*DramAddrOut=0;
+			*flags=0;
+			return false;
+		}
+	}
+
+	/* if we have told the app that we have buffer empty then we cannot go to low power */
+	if((hw->FleaPowerState != FLEA_PS_ACTIVE) && !hw->SingleThreadAppFIFOEmpty)
+	{
+		//*TxBuffSzOut=0;
+		//*DramAddrOut=0;
+		*empty_sz = 0;
+		*flags=0;
+		//printk("PD can't Tx\n");
+		return true; /*Indicate FULL*/
+	}
+
+
+	if(hw->TxFwInputBuffInfo.Flags & DFW_FLAGS_TX_ABORT)
+	{
+		*empty_sz=0;
+		//*DramAddrOut=0;
+		*flags |= DFW_FLAGS_TX_ABORT;
+		return true;
+	}
+
+	if( (hw->TxFwInputBuffInfo.DramBuffSzInBytes < needed_sz)
+		||(!hw->TxFwInputBuffInfo.DramBuffAdd))
+	{
+		*empty_sz=0;
+		//*DramAddrOut=0;
+		*flags=0;
+		return true; /*Indicate FULL*/
+	}
+
+	if(hw->TxFwInputBuffInfo.DramBuffAdd % 4)
+	{
+		/*
+		-- Indicate Full if we get a non-dowrd aligned address.
+		-- This will avoid us posting the command to firmware and
+		-- The TX will timeout and we will close the application properly.
+		-- This avoids a illegal operation as far as the TX is concerned.
+		*/
+		printk("TxSDRAM-Destination Address Not DWORD Aligned:%x\n",hw->TxFwInputBuffInfo.DramBuffAdd);
+		return true;
+	}
+
+	/*
+	-- We got everything correctly from the firmware and hence we should be
+	-- able to do the DMA. Indicate what app wants to hear.
+	-- Firmware SAYS: I AM HUNGRY, GIVE ME FOOD. :)
+	*/
+	*empty_sz=hw->TxFwInputBuffInfo.DramBuffSzInBytes;
+	//*dramAddrOut=pHWExt->TxFwInputBuffInfo.DramBuffAdd;
+//	printk("empty size is %d\n", *empty_sz);
+
+	/* If we are just checking stats and are not actually going to DMA, don't increment */
+	/* But we have to account for single threaded apps */
+	if((*flags & 0x08) == 0x08)
+	{
+		// This is a synchronized function
+		// NAREN - In single threaded mode, if we have less than a defined size of buffer
+		// ask the firmware to wrap around. To prevent deadlocks.
+		if(hw->TxFwInputBuffInfo.DramBuffSzInBytes < TX_WRAP_THRESHOLD)
+		{
+			pTxBuffInfo = (TX_INPUT_BUFFER_INFO *) (0);
+			FlagsAddr = hw->TxBuffInfoAddr + ((uintptr_t) (&pTxBuffInfo->Flags));
+			// Read Modify the Flags to ask the FW to WRAP
+			hw->pfnDevDRAMRead(hw,FlagsAddr,1,&regVal);
+			regVal |= DFW_FLAGS_WRAP;
+			hw->pfnDevDRAMWrite(hw,FlagsAddr,1,&regVal);
+
+			// Indicate Busy to the application because we have to get new buffers from FW
+			*empty_sz=0;
+			// *DramAddrOut=0;
+			*flags=0;
+			// Wait for the next interrupt from the HW
+			hw->TxFwInputBuffInfo.DramBuffSzInBytes = 0;
+			hw->TxFwInputBuffInfo.DramBuffAdd = 0;
+			return true;
+		}
+		else
+			hw->SingleThreadAppFIFOEmpty = true;
+	}
+	else if((*flags & 0x04) != 0x04)
+		hw->EmptyCnt++;		//OS_INTERLOCK_INCREMENT(&pHWExt->EmptyCnt);
+
+	// Different from our Windows implementation
+	// set bit 7 of the flags field to indicate that we have to use the destination address for TX
+	*flags |= BC_BIT(7);
+
+	return false; /*Indicate Empty*/
+}
+
+BC_STATUS crystalhd_flea_fw_cmd_post_proc(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+	DecRspChannelStartVideo *st_rsp = NULL;
+	C011_TS_RSP				*pGenRsp = NULL;
+	DecRspChannelChannelOpen *pRsp  = NULL;
+
+	pGenRsp = (C011_TS_RSP *) fw_cmd->rsp;
+
+	switch (fw_cmd->cmd[0]) {
+		case eCMD_C011_DEC_CHAN_STREAM_OPEN:
+			hw->channelNum = pGenRsp->ulParams[2];
+
+			dev_dbg(&hw->adp->pdev->dev, "Snooped Stream Open Cmd For ChNo:%x\n", hw->channelNum);
+			break;
+		case eCMD_C011_DEC_CHAN_OPEN:
+			pRsp = (DecRspChannelChannelOpen *)pGenRsp;
+			hw->channelNum = pRsp->ChannelID;
+
+			/* used in Flea to update the Tx Buffer stats */
+			hw->TxBuffInfoAddr = pRsp->transportStreamCaptureAddr;
+			hw->TxFwInputBuffInfo.DramBuffAdd=0;
+			hw->TxFwInputBuffInfo.DramBuffSzInBytes=0;
+			hw->TxFwInputBuffInfo.Flags=0;
+			hw->TxFwInputBuffInfo.HostXferSzInBytes=0;
+			hw->TxFwInputBuffInfo.SeqNum=0;
+
+			/* NAREN Init power management states here when we start the channel */
+			hw->PwrDwnTxIntr = false;
+			hw->PwrDwnPiQIntr = false;
+			hw->EmptyCnt = 0;
+			hw->SingleThreadAppFIFOEmpty = false;
+
+			dev_dbg(&hw->adp->pdev->dev, "Snooped ChOpen Cmd For ChNo:%x TxBuffAddr:%x\n",
+					hw->channelNum,
+					hw->TxBuffInfoAddr);
+			break;
+		case eCMD_C011_DEC_CHAN_START_VIDEO:
+			st_rsp = (DecRspChannelStartVideo *)fw_cmd->rsp;
+			hw->pib_del_Q_addr = st_rsp->picInfoDeliveryQ;
+			hw->pib_rel_Q_addr = st_rsp->picInfoReleaseQ;
+
+			dev_dbg(&hw->adp->pdev->dev, "Snooping CHAN_START_VIDEO command to get the Addr of Del/Rel Queue\n");
+			dev_dbg(&hw->adp->pdev->dev, "DelQAddr:%x RelQAddr:%x\n",
+					hw->pib_del_Q_addr, hw->pib_rel_Q_addr);
+			break;
+		default:
+			break;
+	}
+	return sts;
+}
+
+BC_STATUS crystalhd_flea_do_fw_cmd(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd)
+{
+	struct device *dev;
+	uint32_t cnt = 0, cmd_res_addr;
+	uint32_t *cmd_buff, *res_buff;
+	wait_queue_head_t fw_cmd_event;
+	int rc = 0;
+	BC_STATUS sts;
+	unsigned long flags;
+
+	crystalhd_create_event(&fw_cmd_event);
+
+	if (!hw || !fw_cmd) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "%s entered\n", __func__);
+
+	cmd_buff = fw_cmd->cmd;
+	res_buff = fw_cmd->rsp;
+
+	if (!cmd_buff || !res_buff) {
+		dev_err(dev, "Invalid Parameters for F/W Command\n");
+		return BC_STS_INV_ARG;
+	}
+
+	hw->fwcmd_evt_sts = 0;
+	hw->pfw_cmd_event = &fw_cmd_event;
+	hw->FwCmdCnt++;
+
+	if(hw->FleaPowerState != FLEA_PS_ACTIVE)
+	{
+		crystalhd_flea_set_next_power_state(hw,	FLEA_EVT_FW_CMD_POST);
+	}
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	/*Write the command to the memory*/
+	hw->pfnDevDRAMWrite(hw, hw->fwcmdPostAddr, FW_CMD_BUFF_SZ, cmd_buff);
+
+	/*Memory Read for memory arbitrator flush*/
+	hw->pfnDevDRAMRead(hw, hw->fwcmdPostAddr, 1, &cnt);
+
+	/* Write the command address to mailbox */
+	hw->pfnWriteDevRegister(hw->adp, hw->fwcmdPostMbox, hw->fwcmdPostAddr);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	msleep_interruptible(50);
+
+	// FW commands should complete even if we got a signal from the upper layer
+	crystalhd_wait_on_event(&fw_cmd_event, hw->fwcmd_evt_sts,
+							20000, rc, true);
+
+	if (!rc) {
+		sts = BC_STS_SUCCESS;
+	} else if (rc == -EBUSY) {
+		dev_err(dev, "Firmware command T/O\n");
+		sts = BC_STS_TIMEOUT;
+	} else if (rc == -EINTR) {
+		dev_info(dev, "FwCmd Wait Signal - Can Never Happen\n");
+		sts = BC_STS_IO_USER_ABORT;
+	} else {
+		dev_err(dev, "FwCmd IO Error.\n");
+		sts = BC_STS_IO_ERROR;
+	}
+
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "FwCmd Failed.\n");
+		return sts;
+	}
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	/*Get the Responce Address*/
+	cmd_res_addr = hw->pfnReadDevRegister(hw->adp, hw->fwcmdRespMbox);
+
+	/*Read the Response*/
+	hw->pfnDevDRAMRead(hw, cmd_res_addr, FW_CMD_BUFF_SZ, res_buff);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	if (res_buff[2] != 0) {
+		dev_err(dev, "res_buff[2] != C011_RET_SUCCESS\n");
+		return BC_STS_FW_CMD_ERR;
+	}
+
+	sts = crystalhd_flea_fw_cmd_post_proc(hw, fw_cmd);
+	if (sts != BC_STS_SUCCESS)
+		dev_err(dev, "crystalhd_fw_cmd_post_proc Failed.\n");
+
+	return sts;
+
+}
+
+void crystalhd_flea_get_dnsz(struct crystalhd_hw *hw, uint32_t list_index, uint32_t *y_dw_dnsz, uint32_t *uv_dw_dnsz)
+{
+	uint32_t y_dn_sz_reg, uv_dn_sz_reg;
+
+	if (!list_index) {
+		y_dn_sz_reg  = BCHP_MISC1_Y_RX_LIST0_CUR_BYTE_CNT;
+		uv_dn_sz_reg = BCHP_MISC1_HIF_RX_LIST0_CUR_BYTE_CNT;
+	} else {
+		y_dn_sz_reg  = BCHP_MISC1_Y_RX_LIST1_CUR_BYTE_CNT;
+		uv_dn_sz_reg = BCHP_MISC1_HIF_RX_LIST1_CUR_BYTE_CNT;
+	}
+
+	*y_dw_dnsz  = hw->pfnReadFPGARegister(hw->adp, y_dn_sz_reg);
+	*uv_dw_dnsz = hw->pfnReadFPGARegister(hw->adp, uv_dn_sz_reg);
+
+	return ;
+}
+
+BC_STATUS crystalhd_flea_hw_pause(struct crystalhd_hw *hw, bool state)
+{
+	//printk("%s: Set flea to power down.\n", __func__);
+	crystalhd_flea_set_next_power_state(hw,	FLEA_EVT_FLL_CHANGE);
+	return BC_STS_SUCCESS;
+}
+
+bool crystalhd_flea_peek_next_decoded_frame(struct crystalhd_hw *hw, uint64_t *meta_payload, uint32_t *picNumFlags, uint32_t PicWidth)
+{
+	unsigned long flags = 0;
+	crystalhd_dioq_t *ioq;
+	crystalhd_elem_t *tmp;
+	crystalhd_rx_dma_pkt *rpkt;
+
+	*meta_payload = 0;
+
+	ioq = hw->rx_rdyq;
+	spin_lock_irqsave(&ioq->lock, flags);
+
+	if ((ioq->count > 0) && (ioq->head != (crystalhd_elem_t *)&ioq->head)) {
+		tmp = ioq->head;
+		spin_unlock_irqrestore(&ioq->lock, flags);
+		rpkt = (crystalhd_rx_dma_pkt *)tmp->data;
+		if (rpkt) {
+			flea_GetPictureInfo(hw, rpkt, picNumFlags, meta_payload);
+			//printk("%s: flea_GetPictureInfo Pic#:%d\n", __func__, PicNumber);
+		}
+		return true;
+	}
+	spin_unlock_irqrestore(&ioq->lock, flags);
+
+	return false;
+
+}
+
+void crystalhd_flea_clear_rx_errs_intrs(struct crystalhd_hw *hw)
+/*
+-- Clears all the errors and interrupt on RX DMA engine.
+*/
+{
+	uint32_t ulRegVal;
+	FLEA_INTR_STS_REG	IntrToClear,IntrSts;
+
+	IntrToClear.WholeReg = 0;
+	IntrSts.WholeReg = 0;
+
+	IntrSts.WholeReg = hw->pfnReadDevRegister(hw->adp, BCHP_INTR_INTR_STATUS);
+	if(IntrSts.WholeReg)
+	{
+		ulRegVal = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_Y_RX_ERROR_STATUS);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_Y_RX_ERROR_STATUS, ulRegVal);
+		ulRegVal = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_HIF_RX_ERROR_STATUS);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_HIF_RX_ERROR_STATUS, ulRegVal);
+
+		IntrToClear.L0UVRxDMADone	=	IntrSts.L0UVRxDMADone;
+		IntrToClear.L0UVRxDMAErr	=	IntrSts.L0UVRxDMAErr;
+		IntrToClear.L0YRxDMADone	=	IntrSts.L0YRxDMADone;
+		IntrToClear.L0YRxDMAErr		=	IntrSts.L0YRxDMAErr;
+		IntrToClear.L1UVRxDMADone	=	IntrSts.L1UVRxDMADone;
+		IntrToClear.L1UVRxDMAErr	=	IntrSts.L1UVRxDMAErr;
+		IntrToClear.L1YRxDMADone	=	IntrSts.L1YRxDMADone;
+		IntrToClear.L1YRxDMAErr		=	IntrSts.L1YRxDMAErr;
+
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_CLR_REG, IntrToClear.WholeReg);
+
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_EOI_CTRL, 1);
+	}
+	return;
+}
+
+
+void crystalhd_flea_stop_rx_dma_engine(struct crystalhd_hw *hw)
+{
+	FLEA_INTR_STS_REG	IntrStsValue;
+	bool failedL0 = true, failedL1 = true;
+	uint32_t pollCnt = 0;
+
+	hw->RxCaptureState = 2;
+
+	if((hw->rx_list_sts[0] == sts_free) && (hw->rx_list_sts[1] == sts_free)) {
+		hw->RxCaptureState = 0;
+		return; // Nothing to be done
+	}
+
+	if(hw->rx_list_sts[0] == sts_free)
+		failedL0 = false;
+	if(hw->rx_list_sts[1] == sts_free)
+		failedL1 = false;
+
+	while(1)
+	{
+		IntrStsValue.WholeReg = hw->pfnReadDevRegister(hw->adp, BCHP_INTR_INTR_STATUS);
+
+		if(hw->rx_list_sts[0] != sts_free) {
+			if( (IntrStsValue.L0YRxDMADone)  || (IntrStsValue.L0YRxDMAErr) ||
+				(IntrStsValue.L0UVRxDMADone) || (IntrStsValue.L0UVRxDMAErr) )
+			{
+				failedL0 = false;
+			}
+		}
+		else
+			failedL0 = false;
+
+		if(hw->rx_list_sts[1] != sts_free) {
+			if( (IntrStsValue.L1YRxDMADone)  || (IntrStsValue.L1YRxDMAErr) ||
+				(IntrStsValue.L1UVRxDMADone) || (IntrStsValue.L1UVRxDMAErr) )
+			{
+				failedL1 = false;
+			}
+		}
+		else
+			failedL1 = false;
+
+		msleep_interruptible(10);
+
+		if(pollCnt >= MAX_VALID_POLL_CNT)
+			break;
+
+		if((failedL0 == false) && (failedL1 == false))
+			break;
+
+		pollCnt++;
+	}
+
+	if(failedL0 || failedL1)
+		printk("Failed to stop RX DMA\n");
+
+	hw->RxCaptureState = 0;
+
+	crystalhd_flea_clear_rx_errs_intrs(hw);
+}
+
+BC_STATUS crystalhd_flea_hw_fire_rxdma(struct crystalhd_hw *hw,
+									   crystalhd_rx_dma_pkt *rx_pkt)
+{
+	struct device *dev;
+	addr_64 desc_addr;
+	unsigned long flags;
+	PIC_DELIVERY_HOST_INFO	PicDeliInfo;
+	uint32_t BuffSzInDwords;
+
+	if (!hw || !rx_pkt) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	if (hw->rx_list_post_index >= DMA_ENGINE_CNT) {
+		dev_err(dev, "List Out Of bounds %x\n", hw->rx_list_post_index);
+		return BC_STS_INV_ARG;
+	}
+
+	if(hw->RxCaptureState != 1) {
+		printk("Capture not enabled\n");
+		return BC_STS_BUSY;
+	}
+
+	spin_lock_irqsave(&hw->rx_lock, flags);
+	if (hw->rx_list_sts[hw->rx_list_post_index]) {
+		spin_unlock_irqrestore(&hw->rx_lock, flags);
+		return BC_STS_BUSY;
+	}
+
+	if (!TEST_BIT(hw->PicQSts, hw->channelNum)) {
+		// NO pictures available for this channel
+		spin_unlock_irqrestore(&hw->rx_lock, flags);
+		return BC_STS_BUSY;
+	}
+
+	CLEAR_BIT(hw->PicQSts, hw->channelNum);
+
+	desc_addr.full_addr = rx_pkt->desc_mem.phy_addr;
+
+	PicDeliInfo.ListIndex = hw->rx_list_post_index;
+	PicDeliInfo.RxSeqNumber = hw->RxSeqNum;
+	PicDeliInfo.HostDescMemLowAddr_Y = desc_addr.low_part;
+	PicDeliInfo.HostDescMemHighAddr_Y = desc_addr.high_part;
+
+	if (rx_pkt->uv_phy_addr) {
+		/* Program the UV descriptor */
+		desc_addr.full_addr = rx_pkt->uv_phy_addr;
+		PicDeliInfo.HostDescMemLowAddr_UV = desc_addr.low_part;
+		PicDeliInfo.HostDescMemHighAddr_UV = desc_addr.high_part;
+	}
+
+	rx_pkt->pkt_tag = hw->rx_pkt_tag_seed + hw->rx_list_post_index;
+	hw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_y_intr;
+	if (rx_pkt->uv_phy_addr)
+		hw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_uv_intr;
+	hw->rx_list_post_index = (hw->rx_list_post_index + 1) % DMA_ENGINE_CNT;
+
+	spin_unlock_irqrestore(&hw->rx_lock, flags);
+
+	crystalhd_dioq_add(hw->rx_actq, (void *)rx_pkt, false, rx_pkt->pkt_tag);
+
+	BuffSzInDwords = (sizeof (PicDeliInfo) - sizeof(PicDeliInfo.Reserved))/4;
+
+	/*
+	-- Write the parameters in DRAM.
+	*/
+	spin_lock_irqsave(&hw->lock, flags);
+	hw->pfnDevDRAMWrite(hw, hw->FleaRxPicDelAddr, BuffSzInDwords, (uint32_t*)&PicDeliInfo);
+	hw->pfnWriteDevRegister(hw->adp, RX_POST_MAILBOX, hw->channelNum);
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	hw->RxSeqNum++;
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_flea_hw_post_cap_buff(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt *rx_pkt)
+{
+	BC_STATUS sts = crystalhd_flea_hw_fire_rxdma(hw, rx_pkt);
+
+	if (sts != BC_STS_SUCCESS)
+		crystalhd_dioq_add(hw->rx_freeq, (void *)rx_pkt, false, rx_pkt->pkt_tag);
+
+	hw->pfnNotifyFLLChange(hw, false);
+
+	return sts;
+}
+
+void crystalhd_flea_start_tx_dma_engine(struct crystalhd_hw *hw, uint8_t list_id, addr_64 desc_addr)
+{
+	uint32_t dma_cntrl;
+	uint32_t first_desc_u_addr, first_desc_l_addr;
+	TX_INPUT_BUFFER_INFO	TxBuffInfo;
+	uint32_t WrAddr=0, WrSzInDWords=0;
+
+	hw->EmptyCnt--;
+	hw->SingleThreadAppFIFOEmpty = false;
+
+	// For FLEA, first update the HW with the DMA parameters
+	WrSzInDWords = (sizeof(TxBuffInfo.DramBuffAdd) +
+					sizeof(TxBuffInfo.DramBuffSzInBytes) +
+					sizeof(TxBuffInfo.HostXferSzInBytes))/4;
+
+	/*Make the DramBuffSz as Zero skip first ULONG*/
+	WrAddr = hw->TxBuffInfoAddr;
+	hw->TxFwInputBuffInfo.DramBuffAdd = TxBuffInfo.DramBuffAdd = 0;
+	hw->TxFwInputBuffInfo.DramBuffSzInBytes =  TxBuffInfo.DramBuffSzInBytes = 0;
+	TxBuffInfo.HostXferSzInBytes = hw->TxFwInputBuffInfo.HostXferSzInBytes;
+
+	hw->pfnDevDRAMWrite(hw,	WrAddr,	WrSzInDWords, (uint32_t *)&TxBuffInfo);
+
+	if (list_id == 0) {
+		first_desc_u_addr = BCHP_MISC1_TX_FIRST_DESC_U_ADDR_LIST0;
+		first_desc_l_addr = BCHP_MISC1_TX_FIRST_DESC_L_ADDR_LIST0;
+	} else {
+		first_desc_u_addr = BCHP_MISC1_TX_FIRST_DESC_U_ADDR_LIST1;
+		first_desc_l_addr = BCHP_MISC1_TX_FIRST_DESC_L_ADDR_LIST1;
+	}
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS);
+	if (!(dma_cntrl & BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK)) {
+		dma_cntrl |= BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK;
+		hw->pfnWriteFPGARegister(hw->adp, BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS,
+								 dma_cntrl);
+	}
+
+	hw->pfnWriteFPGARegister(hw->adp, first_desc_u_addr, desc_addr.high_part);
+
+	hw->pfnWriteFPGARegister(hw->adp, first_desc_l_addr, desc_addr.low_part | 0x01);
+	/* Be sure we set the valid bit ^^^^ */
+
+	return;
+}
+
+BC_STATUS crystalhd_flea_stop_tx_dma_engine(struct crystalhd_hw *hw)
+{
+	struct device *dev;
+	uint32_t dma_cntrl, cnt = 30;
+	uint32_t l1 = 1, l2 = 1;
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS);
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "Stopping TX DMA Engine..\n");
+
+	if (!(dma_cntrl & BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK)) {
+		dev_dbg(dev, "Already Stopped\n");
+		return BC_STS_SUCCESS;
+	}
+
+	crystalhd_flea_disable_interrupts(hw);
+
+	/* Issue stop to HW */
+	dma_cntrl &= ~BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK;
+	hw->pfnWriteFPGARegister(hw->adp, BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS, dma_cntrl);
+
+	dev_dbg(dev, "Cleared the DMA Start bit\n");
+
+	/* Poll for 3seconds (30 * 100ms) on both the lists..*/
+	while ((l1 || l2) && cnt) {
+
+		if (l1) {
+			l1 = hw->pfnReadFPGARegister(hw->adp,
+										 BCHP_MISC1_TX_FIRST_DESC_L_ADDR_LIST0);
+			l1 &= BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK;
+		}
+
+		if (l2) {
+			l2 = hw->pfnReadFPGARegister(hw->adp,
+										 BCHP_MISC1_TX_FIRST_DESC_L_ADDR_LIST1);
+			l2 &= BCHP_MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK;
+		}
+
+		msleep_interruptible(100);
+
+		cnt--;
+	}
+
+	if (!cnt) {
+		dev_err(dev, "Failed to stop TX DMA.. l1 %d, l2 %d\n", l1, l2);
+		crystalhd_flea_enable_interrupts(hw);
+		return BC_STS_ERROR;
+	}
+
+	hw->TxList0Sts = ListStsFree;
+	hw->TxList1Sts = ListStsFree;
+
+	hw->tx_list_post_index = 0;
+	dev_dbg(dev, "stopped TX DMA..\n");
+	crystalhd_flea_enable_interrupts(hw);
+
+	return BC_STS_SUCCESS;
+}
+
+static void crystalhd_flea_update_tx_done_to_fw(struct crystalhd_hw *hw)
+{
+	struct device *dev;
+	uint32_t				regVal		= 0;
+	uint32_t				seqNumAddr	= 0;
+	uint32_t				seqVal		= 0;
+	TX_INPUT_BUFFER_INFO	*pTxBuffInfo;
+
+	dev = &hw->adp->pdev->dev;
+	/*
+	-- first update the sequence number and then update the
+	-- scratch.
+	*/
+	pTxBuffInfo = (TX_INPUT_BUFFER_INFO *) (0);
+	seqNumAddr = hw->TxBuffInfoAddr + ((uintptr_t) (&pTxBuffInfo->SeqNum));
+
+	//Read the seqnece number
+	hw->pfnDevDRAMRead(hw, seqNumAddr, 1, &regVal);
+
+	seqVal = regVal;
+	regVal++;
+
+	//Increment and Write back to same memory location.
+	hw->pfnDevDRAMWrite(hw,	seqNumAddr, 1, &regVal);
+
+	regVal = hw->pfnReadDevRegister(hw->adp, INDICATE_TX_DONE_REG);
+	regVal++;
+	hw->pfnWriteDevRegister(hw->adp, INDICATE_TX_DONE_REG, regVal);
+
+	dev_dbg(dev, "TxUpdate[SeqNum DRAM Addr:%x] SeqNum:%x ScratchValue:%x\n",
+		seqNumAddr, seqVal, regVal);
+
+	return;
+}
+
+bool crystalhd_flea_tx_list0_handler(struct crystalhd_hw *hw, uint32_t err_sts)
+{
+	uint32_t err_mask, tmp;
+
+	err_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L0_DESC_TX_ABORT_ERRORS_MASK |
+	MISC1_TX_DMA_ERROR_STATUS_TX_L0_DMA_DATA_TX_ABORT_ERRORS_MASK |
+	MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;
+
+	if (!(err_sts & err_mask))
+		return false;
+
+	dev_err(&hw->adp->pdev->dev, "Error on Tx-L0 %x\n", err_sts);
+
+	tmp = err_mask;
+
+	if (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK)
+		tmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;
+
+	if (tmp) {
+		/* reset list index.*/
+		hw->tx_list_post_index = 0;
+	}
+
+	tmp = err_sts & err_mask;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_TX_DMA_ERROR_STATUS, tmp);
+
+	return true;
+}
+
+bool crystalhd_flea_tx_list1_handler(struct crystalhd_hw *hw, uint32_t err_sts)
+{
+	uint32_t err_mask, tmp;
+
+	err_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L1_DESC_TX_ABORT_ERRORS_MASK |
+	MISC1_TX_DMA_ERROR_STATUS_TX_L1_DMA_DATA_TX_ABORT_ERRORS_MASK |
+	MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;
+
+	if (!(err_sts & err_mask))
+		return false;
+
+	dev_err(&hw->adp->pdev->dev, "Error on Tx-L1 %x\n", err_sts);
+
+	tmp = err_mask;
+
+	if (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK)
+		tmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;
+
+	if (tmp) {
+		/* reset list index.*/
+		hw->tx_list_post_index = 0;
+	}
+
+	tmp = err_sts & err_mask;
+	hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_TX_DMA_ERROR_STATUS, tmp);
+
+	return true;
+}
+
+void crystalhd_flea_tx_isr(struct crystalhd_hw *hw, FLEA_INTR_STS_REG int_sts)
+{
+	uint32_t err_sts;
+
+	if (int_sts.L0TxDMADone) {
+		hw->TxList0Sts &= ~TxListWaitingForIntr;
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0, BC_STS_SUCCESS);
+	}
+
+	if (int_sts.L1TxDMADone) {
+		hw->TxList1Sts &= ~TxListWaitingForIntr;
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1, BC_STS_SUCCESS);
+	}
+
+	if (!(int_sts.L0TxDMAErr || int_sts.L1TxDMAErr))
+		/* No error mask set.. */
+		return;
+
+	/* Handle Tx errors. */
+	err_sts = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_TX_DMA_ERROR_STATUS);
+
+	if (crystalhd_flea_tx_list0_handler(hw, err_sts))
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0, BC_STS_ERROR);
+
+	if (crystalhd_flea_tx_list1_handler(hw, err_sts))
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1, BC_STS_ERROR);
+
+	hw->stats.tx_errors++;
+}
+
+bool crystalhd_flea_rx_list0_handler(struct crystalhd_hw *hw,
+									 FLEA_INTR_STS_REG int_sts,
+									 uint32_t y_err_sts,
+									 uint32_t uv_err_sts)
+{
+	uint32_t tmp;
+	list_sts tmp_lsts;
+
+	if (!(y_err_sts & GET_Y0_ERR_MSK) && !(uv_err_sts & GET_UV0_ERR_MSK))
+		return false;
+
+	tmp_lsts = hw->rx_list_sts[0];
+
+	/* Y0 - DMA */
+	tmp = y_err_sts & GET_Y0_ERR_MSK;
+	if (int_sts.L0YRxDMADone)
+		hw->rx_list_sts[0] &= ~rx_waiting_y_intr;
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[0] &= ~rx_waiting_y_intr;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;
+	}
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {
+		// Can never happen for Flea
+		printk("FLEA fifo full - impossible\n");
+		hw->rx_list_sts[0] &= ~rx_y_mask;
+		hw->rx_list_sts[0] |= rx_y_error;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[0] &= ~rx_y_mask;
+		hw->rx_list_sts[0] |= rx_y_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	/* UV0 - DMA */
+	tmp = uv_err_sts & GET_UV0_ERR_MSK;
+	if (int_sts.L0UVRxDMADone)
+		hw->rx_list_sts[0] &= ~rx_waiting_uv_intr;
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[0] &= ~rx_waiting_uv_intr;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;
+	}
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {
+		// Can never happen for Flea
+		printk("FLEA fifo full - impossible\n");
+		hw->rx_list_sts[0] &= ~rx_uv_mask;
+		hw->rx_list_sts[0] |= rx_uv_error;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[0] &= ~rx_uv_mask;
+		hw->rx_list_sts[0] |= rx_uv_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	if (y_err_sts & GET_Y0_ERR_MSK) {
+		tmp = y_err_sts & GET_Y0_ERR_MSK;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_Y_RX_ERROR_STATUS, tmp);
+	}
+
+	if (uv_err_sts & GET_UV0_ERR_MSK) {
+		tmp = uv_err_sts & GET_UV0_ERR_MSK;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_HIF_RX_ERROR_STATUS, tmp);
+	}
+
+	return (tmp_lsts != hw->rx_list_sts[0]);
+}
+
+bool crystalhd_flea_rx_list1_handler(struct crystalhd_hw *hw,
+									 FLEA_INTR_STS_REG int_sts,
+									 uint32_t y_err_sts,
+									 uint32_t uv_err_sts)
+{
+	uint32_t tmp;
+	list_sts tmp_lsts;
+
+	if (!(y_err_sts & GET_Y1_ERR_MSK) && !(uv_err_sts & GET_UV1_ERR_MSK))
+		return false;
+
+	tmp_lsts = hw->rx_list_sts[1];
+
+	/* Y1 - DMA */
+	tmp = y_err_sts & GET_Y1_ERR_MSK;
+	if (int_sts.L1YRxDMADone)
+		hw->rx_list_sts[1] &= ~rx_waiting_y_intr;
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[1] &= ~rx_waiting_y_intr;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;
+	}
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {
+		// Can never happen for Flea
+		printk("FLEA fifo full - impossible\n");
+		hw->rx_list_sts[1] &= ~rx_y_mask;
+		hw->rx_list_sts[1] |= rx_y_error;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[1] &= ~rx_y_mask;
+		hw->rx_list_sts[1] |= rx_y_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	/* UV1 - DMA */
+	tmp = uv_err_sts & GET_UV1_ERR_MSK;
+	if (int_sts.L1UVRxDMADone)
+		hw->rx_list_sts[1] &= ~rx_waiting_uv_intr;
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[1] &= ~rx_waiting_uv_intr;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;
+	}
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {
+		// Can never happen for Flea
+		printk("FLEA fifo full - impossible\n");
+		hw->rx_list_sts[1] &= ~rx_uv_mask;
+		hw->rx_list_sts[1] |= rx_uv_error;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[1] &= ~rx_uv_mask;
+		hw->rx_list_sts[1] |= rx_uv_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	if (y_err_sts & GET_Y1_ERR_MSK) {
+		tmp = y_err_sts & GET_Y1_ERR_MSK;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_Y_RX_ERROR_STATUS, tmp);
+	}
+
+	if (uv_err_sts & GET_UV1_ERR_MSK) {
+		tmp = uv_err_sts & GET_UV1_ERR_MSK;
+		hw->pfnWriteDevRegister(hw->adp, BCHP_MISC1_HIF_RX_ERROR_STATUS, tmp);
+	}
+
+	return (tmp_lsts != hw->rx_list_sts[1]);
+}
+
+void crystalhd_flea_rx_isr(struct crystalhd_hw *hw, FLEA_INTR_STS_REG intr_sts)
+{
+	unsigned long flags;
+	uint32_t i, list_avail = 0;
+	BC_STATUS comp_sts = BC_STS_NO_DATA;
+	uint32_t y_err_sts, uv_err_sts, y_dn_sz = 0, uv_dn_sz = 0;
+	bool ret = 0;
+
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return;
+	}
+
+	if (!(intr_sts.L0YRxDMADone || intr_sts.L1YRxDMADone || intr_sts.L0UVRxDMADone || intr_sts.L1UVRxDMADone ||
+		intr_sts.L0YRxDMAErr || intr_sts.L1YRxDMAErr || intr_sts.L0UVRxDMAErr || intr_sts.L1UVRxDMAErr))
+		return;
+
+	spin_lock_irqsave(&hw->rx_lock, flags);
+
+	y_err_sts = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_Y_RX_ERROR_STATUS);
+	uv_err_sts = hw->pfnReadDevRegister(hw->adp, BCHP_MISC1_HIF_RX_ERROR_STATUS);
+
+	for (i = 0; i < DMA_ENGINE_CNT; i++) {
+		/* Update States..*/
+		if (i == 0)
+			ret = crystalhd_flea_rx_list0_handler(hw, intr_sts, y_err_sts, uv_err_sts);
+		else
+			ret = crystalhd_flea_rx_list1_handler(hw, intr_sts, y_err_sts, uv_err_sts);
+		if (ret) {
+			switch (hw->rx_list_sts[i]) {
+				case sts_free:
+					comp_sts = BC_STS_SUCCESS;
+					list_avail = 1;
+					hw->stats.rx_success++;
+					break;
+				case rx_y_error:
+				case rx_uv_error:
+				case rx_sts_error:
+					/* We got error on both or Y or uv. */
+					hw->stats.rx_errors++;
+					hw->pfnHWGetDoneSize(hw, i, &y_dn_sz, &uv_dn_sz);
+					dev_info(&hw->adp->pdev->dev, "list_index:%x "
+					"rx[%d] rxtot[%d] Y:%x UV:%x Int:%x YDnSz:%x "
+					"UVDnSz:%x\n", i, hw->stats.rx_errors,
+							 hw->stats.rx_errors + hw->stats.rx_success,
+							 y_err_sts, uv_err_sts, intr_sts.WholeReg,
+							 y_dn_sz, uv_dn_sz);
+							 hw->rx_list_sts[i] = sts_free;
+							 comp_sts = BC_STS_ERROR;
+							 break;
+				default:
+					/* Wait for completion..*/
+					comp_sts = BC_STS_NO_DATA;
+					break;
+			}
+		}
+		/* handle completion...*/
+		if (comp_sts != BC_STS_NO_DATA) {
+			crystalhd_rx_pkt_done(hw, i, comp_sts);
+			comp_sts = BC_STS_NO_DATA;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->rx_lock, flags);
+
+	if (list_avail)
+		crystalhd_hw_start_capture(hw);
+}
+
+bool crystalhd_flea_hw_interrupt_handle(struct crystalhd_adp *adp, struct crystalhd_hw *hw)
+{
+	FLEA_INTR_STS_REG	IntrStsValue;
+	bool				bIntFound		= false;
+	bool				bPostRxBuff		= false;
+	bool				bSomeCmdDone	= false;
+	crystalhd_rx_dma_pkt *rx_pkt;
+
+	bool	rc = false;
+
+	if (!adp || !hw->dev_started)
+		return rc;
+
+	IntrStsValue.WholeReg=0;
+
+	IntrStsValue.WholeReg = hw->pfnReadDevRegister(hw->adp, BCHP_INTR_INTR_STATUS);
+
+	if(!IntrStsValue.WholeReg)
+		return rc;	/*Not Our interrupt*/
+
+	/*If any of the bit is set we have a problem*/
+	if(IntrStsValue.HaltIntr || IntrStsValue.PcieTgtCaAttn || IntrStsValue.PcieTgtUrAttn)
+	{
+		printk("Bad HW Error in CrystalHD Driver\n");
+		return rc;
+	}
+
+	// Our interrupt
+	hw->stats.num_interrupts++;
+	rc = true;
+
+	/* NAREN When In Power Down state, only interrupts possible are TXFIFO and PiQ       */
+	/* Save the state of these interrupts to process them when we resume from power down */
+	if(hw->FleaPowerState == FLEA_PS_LP_COMPLETE)
+	{
+		if(IntrStsValue.ArmMbox1Int)
+		{
+			hw->PwrDwnPiQIntr = true;
+			bIntFound = true;
+		}
+
+		if(IntrStsValue.ArmMbox2Int)
+		{
+			hw->PwrDwnTxIntr = true;
+			bIntFound = true;
+		}
+
+		/*Write End Of Interrupt for PCIE*/
+		if(bIntFound)
+		{
+			hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_CLR_REG, IntrStsValue.WholeReg);
+			hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_EOI_CTRL, 1);
+		}
+		return (bIntFound);
+	}
+
+	/*
+	-- Arm Mail box Zero interrupt is
+	-- BCHP_ARMCR4_BRIDGE_REG_MBOX_ARM1
+	*/
+	if(IntrStsValue.ArmMbox0Int)
+	{
+		//HWFWCmdComplete(pHWExt,IntrBmp);
+		/*Set the Event and the status flag*/
+		if (hw->pfw_cmd_event) {
+			hw->fwcmd_evt_sts = 1;
+			crystalhd_set_event(hw->pfw_cmd_event);
+		}
+		bIntFound = true;
+		bSomeCmdDone = true;
+		hw->FwCmdCnt--;
+	}
+
+	/* Rx interrupts */
+	crystalhd_flea_rx_isr(hw, IntrStsValue);
+
+	if( IntrStsValue.L0YRxDMADone || IntrStsValue.L1YRxDMADone || IntrStsValue.L0UVRxDMADone || IntrStsValue.L1UVRxDMADone || IntrStsValue.L0YRxDMAErr || IntrStsValue.L1YRxDMAErr )
+	{
+		bSomeCmdDone = true;
+	}
+
+
+	/* Tx interrupts*/
+	crystalhd_flea_tx_isr(hw, IntrStsValue);
+
+	/*
+	-- Indicate the TX Done to Flea Firmware.
+	*/
+	if(IntrStsValue.L0TxDMADone || IntrStsValue.L1TxDMADone || IntrStsValue.L0TxDMAErr || IntrStsValue.L1TxDMAErr)
+	{
+		crystalhd_flea_update_tx_done_to_fw(hw);
+		bSomeCmdDone = true;
+	}
+	/*
+	-- We are doing this here because we processed the interrupts.
+	-- We might want to change the PicQSts bitmap in any of the interrupts.
+	-- This should be done before trying to post the next RX buffer.
+	-- NOTE: ArmMbox1Int is BCHP_ARMCR4_BRIDGE_REG_MBOX_ARM2
+	*/
+	if(IntrStsValue.ArmMbox1Int)
+	{
+		//pHWExt->FleaBmpIntrCnt++;
+		crystalhd_flea_update_temperature(hw);
+		crystalhd_flea_handle_PicQSts_intr(hw);
+		bPostRxBuff = true;
+		bIntFound = true;
+	}
+
+	if(IntrStsValue.ArmMbox2Int)
+	{
+		crystalhd_flea_update_temperature(hw);
+		crystalhd_flea_update_tx_buff_info(hw);
+		bIntFound = true;
+	}
+
+	/*Write End Of Interrupt for PCIE*/
+	if(rc)
+	{
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_INTR_CLR_REG, IntrStsValue.WholeReg);
+		hw->pfnWriteDevRegister(hw->adp, BCHP_INTR_EOI_CTRL, 1);
+	}
+
+	// Try to post RX Capture buffer from ISR context
+	if(bPostRxBuff) {
+		rx_pkt = crystalhd_dioq_fetch(hw->rx_freeq);
+		if (rx_pkt)
+			hw->pfnPostRxSideBuff(hw, rx_pkt);
+	}
+
+	if( (hw->FleaPowerState == FLEA_PS_LP_PENDING) && (bSomeCmdDone))
+	{
+		//printk("interrupt_handle: current PS:%d, bSomeCmdDone%d\n", hw->FleaPowerState,bSomeCmdDone);
+		crystalhd_flea_set_next_power_state(hw, FLEA_EVT_CMD_COMP);
+	}
+
+	///* NAREN place the device in low power mode if we have not started playing video */
+	//if((hw->FleaPowerState == FLEA_PS_ACTIVE) && (hw->WakeUpDecodeDone != true))
+	//{
+	//	if((hw->ReadyListLen == 0) && (hw->FreeListLen == 0))
+	//	{
+	//		crystalhd_flea_set_next_power_state(hw, FLEA_EVT_FLL_CHANGE);
+	//		printk("ISR Idle\n");
+	//	}
+	//}
+
+	return rc;
+}
+
+/* This function cannot be called from ISR context since it uses APIs that can sleep */
+bool flea_GetPictureInfo(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt * rx_pkt,
+							uint32_t *PicNumber, uint64_t *PicMetaData)
+{
+	struct device *dev = &hw->adp->pdev->dev;
+	uint32_t PicInfoLineNum = 0, offset = 0, size = 0;
+	PBC_PIC_INFO_BLOCK pPicInfoLine = NULL;
+	uint32_t tmpYBuffData;
+	unsigned long res = 0;
+	uint32_t widthField = 0;
+	bool rtVal = true;
+
+	void *tmpPicInfo = NULL;
+	crystalhd_dio_req *dio = rx_pkt->dio_req;
+	*PicNumber = 0;
+	*PicMetaData = 0;
+
+	if (!dio)
+		goto getpictureinfo_err_nosem;
+
+// 	if(down_interruptible(&hw->fetch_sem))
+// 		goto getpictureinfo_err_nosem;
+
+	tmpPicInfo = kmalloc(2 * sizeof(BC_PIC_INFO_BLOCK) + 16, GFP_KERNEL); // since copy_from_user can sleep anyway
+	if(tmpPicInfo == NULL)
+		goto getpictureinfo_err;
+	dio->pib_va = kmalloc(32, GFP_KERNEL); // temp buffer of 32 bytes for the rest;
+	if(dio->pib_va == NULL)
+		goto getpictureinfo_err;
+
+	offset = (rx_pkt->dio_req->uinfo.y_done_sz * 4) - PIC_PIB_DATA_OFFSET_FROM_END;
+	res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff + offset), 4);
+	if (res != 0)
+		goto getpictureinfo_err;
+	PicInfoLineNum = *(uint32_t*)(dio->pib_va);
+	if (PicInfoLineNum > 1092) {
+/*
+		dev_err(dev, "Invalid Line Number[%x], DoneSz:0x%x Bytes\n",
+			(int)PicInfoLineNum, rx_pkt->dio_req->uinfo.y_done_sz * 4);
+*/
+		goto getpictureinfo_err;
+	}
+
+	offset = (rx_pkt->dio_req->uinfo.y_done_sz * 4) - PIC_WIDTH_OFFSET_FROM_END;
+	res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff + offset), 4);
+	if (res != 0)
+		goto getpictureinfo_err;
+	widthField = *(uint32_t*)(dio->pib_va);
+
+	hw->PICWidth = widthField & 0x3FFFFFFF; // bit 31 is FMT Change, bit 30 is EOS
+	if (hw->PICWidth > 2048) {
+		dev_err(dev, "Invalid width [%d]\n", hw->PICWidth);
+		goto getpictureinfo_err;
+	}
+
+	/* calc pic info line offset */
+	if (dio->uinfo.b422mode) {
+		size = 2 * sizeof(BC_PIC_INFO_BLOCK);
+		offset = (PicInfoLineNum * hw->PICWidth * 2) + 4;
+	} else {
+		size = sizeof(BC_PIC_INFO_BLOCK);
+		offset = (PicInfoLineNum * hw->PICWidth) + 4;
+	}
+
+	res = copy_from_user(tmpPicInfo, (void *)(dio->uinfo.xfr_buff+offset), size);
+	if (res != 0)
+		goto getpictureinfo_err;
+
+	pPicInfoLine = (PBC_PIC_INFO_BLOCK)(tmpPicInfo);
+
+	*PicMetaData = pPicInfoLine->timeStamp;
+
+	if(widthField & PIB_EOS_DETECTED_BIT)
+	{
+		dev_dbg(dev, "Got EOS flag.\n");
+		hw->DrvEosDetected = 1;
+		*(uint32_t *)(dio->pib_va) = 0xFFFFFFFF;
+		res = copy_to_user((void *)(dio->uinfo.xfr_buff), dio->pib_va, 4);
+		if (res != 0)
+			goto getpictureinfo_err;
+	}
+	else
+	{
+		if( hw->DrvEosDetected == 1 )
+			hw->DrvCancelEosFlag = 1;
+
+		hw->DrvEosDetected = 0;
+		res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff), 4);
+		if (res != 0)
+			goto getpictureinfo_err;
+
+		tmpYBuffData = *(uint32_t *)(dio->pib_va);
+		pPicInfoLine->ycom = tmpYBuffData;
+		res = copy_to_user((void *)(dio->uinfo.xfr_buff+offset), tmpPicInfo, size);
+		if (res != 0)
+			goto getpictureinfo_err;
+
+		*(uint32_t *)(dio->pib_va) = PicInfoLineNum;
+		res = copy_to_user((void *)(dio->uinfo.xfr_buff), dio->pib_va, 4);
+		if (res != 0)
+			goto getpictureinfo_err;
+	}
+
+	if(widthField & PIB_FORMAT_CHANGE_BIT)
+	{
+		rx_pkt->flags = 0;
+		rx_pkt->flags |= COMP_FLAG_PIB_VALID | COMP_FLAG_FMT_CHANGE;
+
+		rx_pkt->pib.picture_number			= pPicInfoLine->picture_number;
+		rx_pkt->pib.width					= pPicInfoLine->width;
+		rx_pkt->pib.height					= pPicInfoLine->height;
+		rx_pkt->pib.chroma_format			= pPicInfoLine->chroma_format;
+		rx_pkt->pib.pulldown				= pPicInfoLine->pulldown;
+		rx_pkt->pib.flags					= pPicInfoLine->flags;
+		rx_pkt->pib.sess_num				= pPicInfoLine->sess_num;
+		rx_pkt->pib.aspect_ratio			= pPicInfoLine->aspect_ratio;
+		rx_pkt->pib.colour_primaries		= pPicInfoLine->colour_primaries;
+		rx_pkt->pib.picture_meta_payload	= pPicInfoLine->picture_meta_payload;
+		rx_pkt->pib.frame_rate 				= pPicInfoLine->frame_rate;
+		rx_pkt->pib.custom_aspect_ratio_width_height = pPicInfoLine->custom_aspect_ratio_width_height;
+		rx_pkt->pib.n_drop				= pPicInfoLine->n_drop;
+		rx_pkt->pib.ycom				= pPicInfoLine->ycom;
+		hw->PICHeight = rx_pkt->pib.height;
+		hw->PICWidth = rx_pkt->pib.width;
+		hw->LastPicNo=0;
+		hw->LastTwoPicNo=0;
+		hw->PDRatio = 0; // NAREN - reset PD ratio to start measuring for new clip
+		hw->PauseThreshold = hw->DefaultPauseThreshold;
+		hw->TickSpentInPD = 0;
+		rdtscll(hw->TickCntDecodePU);
+
+		dev_dbg(dev, "[FMT CH] DoneSz:0x%x, PIB:%x %x %x %x %x %x %x %x %x %x\n",
+			rx_pkt->dio_req->uinfo.y_done_sz * 4,
+				 rx_pkt->pib.picture_number,
+				 rx_pkt->pib.aspect_ratio,
+				 rx_pkt->pib.chroma_format,
+				 rx_pkt->pib.colour_primaries,
+				 rx_pkt->pib.frame_rate,
+				 rx_pkt->pib.height,
+				 rx_pkt->pib.width,
+				 rx_pkt->pib.n_drop,
+				 rx_pkt->pib.pulldown,
+				 rx_pkt->pib.ycom);
+		rtVal = false;
+	}
+
+	if(pPicInfoLine->flags & FLEA_DECODE_ERROR_FLAG)
+	{
+		*PicNumber = 0;
+	} else {
+		/* get pic number and flags */
+		if (dio->uinfo.b422mode)
+			offset = (PicInfoLineNum * hw->PICWidth * 2);
+		else
+			offset = (PicInfoLineNum * hw->PICWidth);
+
+		res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff+offset), 4);
+		if (res != 0)
+			goto getpictureinfo_err;
+
+		*PicNumber = *(uint32_t *)(dio->pib_va);
+	}
+
+	if(dio->pib_va)
+		kfree(dio->pib_va);
+	if(tmpPicInfo)
+		kfree(tmpPicInfo);
+
+// 	up(&hw->fetch_sem);
+
+	return rtVal;
+
+getpictureinfo_err:
+// 	up(&hw->fetch_sem);
+
+getpictureinfo_err_nosem:
+	if(dio->pib_va)
+		kfree(dio->pib_va);
+	if(tmpPicInfo)
+		kfree(tmpPicInfo);
+
+	*PicNumber = 0;
+	*PicMetaData = 0;
+
+	return false;
+}
+
+uint32_t flea_GetRptDropParam(struct crystalhd_hw *hw, void* pRxDMAReq)
+{
+	uint32_t PicNumber = 0,result = 0;
+	uint64_t PicMetaData = 0;
+
+	if(flea_GetPictureInfo(hw, (crystalhd_rx_dma_pkt *)pRxDMAReq,
+		&PicNumber, &PicMetaData))
+		result = PicNumber;
+
+	return result;
+}
+
+bool crystalhd_flea_notify_event(struct crystalhd_hw *hw, BRCM_EVENT EventCode)
+{
+	switch(EventCode)
+	{
+		case BC_EVENT_START_CAPTURE:
+		{
+			crystalhd_flea_wake_up_hw(hw);
+			break;
+		}
+		default:
+			break;
+	}
+
+	return true;
+}
diff --git a/drivers/staging/chd/crystalhd_fleafuncs.h b/drivers/staging/chd/crystalhd_fleafuncs.h
new file mode 100644
index 0000000..a70958f
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_fleafuncs.h
@@ -0,0 +1,62 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_fleafuncs . h
+ *
+ *  Description:
+ *		BCM70015 Linux driver hardware layer.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_FLEAFUNCS_H_
+#define _CRYSTALHD_FLEAFUNCS_H_
+
+#include "FleaDefs.h"
+
+#define FW_CMD_BUFF_SZ		64
+
+bool crystalhd_flea_start_device(struct crystalhd_hw *hw);
+bool crystalhd_flea_stop_device(struct crystalhd_hw *hw);
+bool crystalhd_flea_hw_interrupt_handle(struct crystalhd_adp *adp, struct crystalhd_hw *hw);
+uint32_t crystalhd_flea_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off);											// Done
+void crystalhd_flea_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val);									// Done
+bool crystalhd_flea_check_input_full(struct crystalhd_hw *hw, uint32_t needed_sz, uint32_t *empty_sz, bool b_188_byte_pkts, uint8_t *flags);
+BC_STATUS crystalhd_flea_mem_rd(struct crystalhd_hw *hw, uint32_t start_off, uint32_t dw_cnt, uint32_t *rd_buff);		// Done
+BC_STATUS crystalhd_flea_mem_wr(struct crystalhd_hw *hw, uint32_t start_off, uint32_t dw_cnt, uint32_t *wr_buff);		// Done
+BC_STATUS crystalhd_flea_do_fw_cmd(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd);
+BC_STATUS crystalhd_flea_download_fw(struct crystalhd_hw* hw, uint8_t* buffer, uint32_t sz);
+void crystalhd_flea_get_dnsz(struct crystalhd_hw *hw, uint32_t list_index, uint32_t *y_dw_dnsz, uint32_t *uv_dw_dnsz);
+BC_STATUS crystalhd_flea_hw_pause(struct crystalhd_hw *hw, bool state);
+bool crystalhd_flea_peek_next_decoded_frame(struct crystalhd_hw *hw, uint64_t *meta_payload, uint32_t *picNumFlags, uint32_t PicWidth);
+BC_STATUS crystalhd_flea_hw_post_cap_buff(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt *rx_pkt);
+void crystalhd_flea_start_tx_dma_engine(struct crystalhd_hw *hw, uint8_t list_id, addr_64 desc_addr);
+void crystalhd_flea_stop_rx_dma_engine(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_flea_stop_tx_dma_engine(struct crystalhd_hw *hw);
+bool crystalhd_flea_tx_list0_handler(struct crystalhd_hw *hw, uint32_t err_sts);
+bool crystalhd_flea_tx_list1_handler(struct crystalhd_hw *hw, uint32_t err_sts);
+void crystalhd_flea_tx_isr(struct crystalhd_hw *hw, FLEA_INTR_STS_REG int_sts);
+bool crystalhd_flea_rx_list0_handler(struct crystalhd_hw *hw,FLEA_INTR_STS_REG int_sts,uint32_t y_err_sts,uint32_t uv_err_sts);
+bool crystalhd_flea_rx_list1_handler(struct crystalhd_hw *hw,FLEA_INTR_STS_REG int_sts,uint32_t y_err_sts,uint32_t uv_err_sts);
+void crystalhd_flea_rx_isr(struct crystalhd_hw *hw, FLEA_INTR_STS_REG intr_sts);
+void crystalhd_flea_notify_fll_change(struct crystalhd_hw *hw, bool bCleanupContext);
+bool crystalhd_flea_notify_event(struct crystalhd_hw *hw, BRCM_EVENT EventCode);
+
+bool flea_GetPictureInfo(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt * rx_pkt,
+						 uint32_t *PicNumber, uint64_t *PicMetaData);
+#endif
diff --git a/drivers/staging/chd/crystalhd_fw_if.h b/drivers/staging/chd/crystalhd_fw_if.h
new file mode 100644
index 0000000..f887992
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_fw_if.h
@@ -0,0 +1,390 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_fw_if . h
+ *
+ *  Description:
+ *		BCM70012 Firmware interface definitions.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_FW_IF_H_
+#define _CRYSTALHD_FW_IF_H_
+
+#include <linux/types.h>
+
+/* TBD: Pull in only required defs into this file.. */
+
+/* User Data Header */
+typedef struct user_data {
+   struct user_data	*next;
+   uint32_t		type;
+   uint32_t		size;
+} UD_HDR;
+
+
+
+/*------------------------------------------------------*
+ *    MPEG Extension to the PPB			 *
+ *------------------------------------------------------*/
+typedef struct {
+   uint32_t		to_be_defined;
+   uint32_t		valid;
+
+   /* Always valid, defaults to picture size if no
+      sequence display extension in the stream. */
+   uint32_t		display_horizontal_size;
+   uint32_t		display_vertical_size;
+
+   /* MPEG_VALID_PANSCAN
+      Offsets are a copy values from the MPEG stream. */
+   uint32_t		offset_count;
+   int32_t		horizontal_offset[3];
+   int32_t		vertical_offset[3];
+
+   /* MPEG_VALID_USERDATA
+      User data is in the form of a linked list. */
+   int32_t		userDataSize;
+   UD_HDR		*userData;
+
+} PPB_MPEG;
+
+
+/*------------------------------------------------------*
+ *    VC1 Extension to the PPB			  *
+ *------------------------------------------------------*/
+typedef struct {
+   uint32_t		to_be_defined;
+   uint32_t		valid;
+
+   /* Always valid, defaults to picture size if no
+      sequence display extension in the stream. */
+   uint32_t		display_horizontal_size;
+   uint32_t		display_vertical_size;
+
+  /* VC1 pan scan windows */
+   uint32_t		num_panscan_windows;
+   int32_t		ps_horiz_offset[4];
+   int32_t		ps_vert_offset[4];
+   int32_t		ps_width[4];
+   int32_t		ps_height[4];
+
+   /* VC1_VALID_USERDATA
+      User data is in the form of a linked list. */
+   int32_t		userDataSize;
+   UD_HDR		*userData;
+
+} PPB_VC1;
+
+/*------------------------------------------------------*
+ *    H.264 Extension to the PPB			*
+ *------------------------------------------------------*/
+
+/**
+ * @brief Film grain SEI message.
+ *
+ * Content of the film grain SEI message.
+ */
+
+/* maximum number of model-values as for Thomson spec(standard says 5) */
+#define MAX_FGT_MODEL_VALUE	 (3)
+
+/* maximum number of intervals(as many as 256 intervals?) */
+#define MAX_FGT_VALUE_INTERVAL	(256)
+
+typedef struct FGT_SEI {
+    struct FGT_SEI *next;
+    unsigned char model_values[3][MAX_FGT_VALUE_INTERVAL][MAX_FGT_MODEL_VALUE];
+    unsigned char upper_bound[3][MAX_FGT_VALUE_INTERVAL];
+    unsigned char lower_bound[3][MAX_FGT_VALUE_INTERVAL];
+
+    unsigned char cancel_flag;	/* Cancel flag: 1 no film grain. */
+    unsigned char model_id;	/* Model id. */
+
+    /* +unused SE based on Thomson spec */
+    unsigned char color_desc_flag;	/* Separate color descrition flag. */
+    unsigned char bit_depth_luma;	/* Bit depth luma minus 8. */
+    unsigned char bit_depth_chroma;	/* Bit depth chroma minus 8. */
+    unsigned char full_range_flag;	/* Full range flag. */
+    unsigned char color_primaries;	/* Color primaries. */
+    unsigned char transfer_charact;	/* Transfer characteristics. */
+    unsigned char matrix_coeff;		/*< Matrix coefficients. */
+    /* -unused SE based on Thomson spec */
+
+    unsigned char blending_mode_id;	/* Blending mode. */
+    unsigned char log2_scale_factor;	/* Log2 scale factor (2-7). */
+    unsigned char comp_flag[3];		/* Components [0,2] parameters present flag. */
+    unsigned char num_intervals_minus1[3]; /* Number of intensity level intervals. */
+    unsigned char num_model_values[3];	/* Number of model values. */
+    uint16_t      repetition_period;	/* Repetition period (0-16384) */
+
+} FGT_SEI;
+
+typedef struct {
+   /* 'valid' specifies which fields (or sets of
+    * fields) below are valid.  If the corresponding
+    * bit in 'valid' is NOT set then that field(s)
+    * is (are) not initialized. */
+   uint32_t	valid;
+
+   int32_t		poc_top;	/* POC for Top Field/Frame */
+   int32_t		poc_bottom;	/* POC for Bottom Field    */
+   uint32_t		idr_pic_id;
+
+   /* H264_VALID_PANSCAN */
+   uint32_t		pan_scan_count;
+   int32_t		pan_scan_left[3];
+   int32_t		pan_scan_right[3];
+   int32_t		pan_scan_top[3];
+   int32_t		pan_scan_bottom[3];
+
+   /* H264_VALID_CT_TYPE */
+   uint32_t		ct_type_count;
+   uint32_t		ct_type[3];
+
+   /* H264_VALID_SPS_CROP */
+   int32_t		sps_crop_left;
+   int32_t		sps_crop_right;
+   int32_t		sps_crop_top;
+   int32_t		sps_crop_bottom;
+
+   /* H264_VALID_VUI */
+   uint32_t		chroma_top;
+   uint32_t		chroma_bottom;
+
+   /* H264_VALID_USER */
+   uint32_t		user_data_size;
+   UD_HDR		*user_data;
+
+   /* H264 VALID FGT */
+   FGT_SEI		*pfgt;
+
+} PPB_H264;
+
+typedef struct {
+   /* Common fields. */
+   uint32_t	picture_number;	/* Ordinal display number */
+   uint32_t	video_buffer;	/* Video (picbuf) number */
+   uint32_t	video_address;	/* Address of picbuf Y */
+   uint32_t	video_address_uv; /* Address of picbuf UV */
+   uint32_t	video_stripe;	/* Picbuf stripe */
+   uint32_t	video_width;	/* Picbuf width */
+   uint32_t	video_height;	/* Picbuf height */
+
+   uint32_t	channel_id;	/* Decoder channel ID */
+   uint32_t	status;		/* reserved */
+   uint32_t	width;		/* pixels */
+   uint32_t	height;		/* pixels */
+   uint32_t	chroma_format;	/* see above */
+   uint32_t	pulldown;	/* see above */
+   uint32_t	flags;		/* see above */
+   uint32_t	pts;		/* 32 LSBs of PTS */
+   uint32_t	protocol;	/* protocolXXX (above) */
+
+   uint32_t	frame_rate;	/* see above */
+   uint32_t	matrix_coeff;	/* see above */
+   uint32_t	aspect_ratio;	/* see above */
+   uint32_t	colour_primaries; /* see above */
+   uint32_t	transfer_char;	/* see above */
+   uint32_t	pcr_offset;	/* 45kHz if PCR type; else 27MHz */
+   uint32_t	n_drop;		/* Number of pictures to be dropped */
+
+   uint32_t	custom_aspect_ratio_width_height;
+			/* upper 16-bits is Y and lower 16-bits is X */
+
+   uint32_t	picture_tag;	/* Indexing tag from BUD packets */
+   uint32_t	picture_done_payload;
+   uint32_t	picture_meta_payload;
+   uint32_t	reserved[1];
+
+   /* Protocol-specific extensions. */
+   union {
+      PPB_H264	h264;
+      PPB_MPEG	mpeg;
+      PPB_VC1	 vc1;
+   } other;
+
+} PPB;
+
+typedef struct {
+   uint32_t	bFormatChange;
+   uint32_t	resolution;
+   uint32_t	channelId;
+   uint32_t	ppbPtr;
+   int32_t	ptsStcOffset;
+   uint32_t	zeroPanscanValid;
+   uint32_t	dramOutBufAddr;
+   uint32_t	yComponent;
+   PPB			ppb;
+
+} C011_PIB;
+
+typedef struct
+{
+	uint32_t	eCmd; // eC011_TS_CMD
+	uint32_t	ulParams[63];
+} C011_TS_CMD, C011_TS_RSP;
+
+typedef struct {
+    uint32_t	command;
+    uint32_t	sequence;
+    uint32_t	status;
+    uint32_t	picBuf;
+    uint32_t	picRelBuf;
+    uint32_t	picInfoDeliveryQ;
+    uint32_t	picInfoReleaseQ;
+    uint32_t	channelStatus;
+    uint32_t	userDataDeliveryQ;
+    uint32_t	userDataReleaseQ;
+    uint32_t	transportStreamCaptureAddr;
+    uint32_t	asyncEventQ;
+
+} DecRspChannelStartVideo;
+
+typedef struct
+{
+	uint32_t command;
+	uint32_t sequence;
+	uint32_t status;
+	uint32_t ChannelID;
+	uint32_t picBuf;
+	uint32_t picRelBuf;
+	uint32_t picInfoDeliveryQ;
+	uint32_t picInfoReleaseQ;
+	uint32_t channelStatus;
+	uint32_t userDataDeliveryQ;
+	uint32_t userDataReleaseQ;
+	uint32_t transportStreamCaptureAddr;
+	uint32_t asyncEventQ;
+}DecRspChannelChannelOpen;
+
+#define eCMD_C011_CMD_BASE	  (0x73763000)
+
+/* host commands */
+typedef enum {
+    eCMD_TS_GET_NEXT_PIC	= 0x7376F100, /* debug get next picture */
+    eCMD_TS_GET_LAST_PIC	= 0x7376F102, /* debug get last pic status */
+    eCMD_TS_READ_WRITE_MEM	= 0x7376F104, /* debug read write memory */
+
+    /* New API commands */
+    /* General commands */
+    eCMD_C011_INIT		= eCMD_C011_CMD_BASE + 0x01,
+    eCMD_C011_RESET		= eCMD_C011_CMD_BASE + 0x02,
+    eCMD_C011_SELF_TEST		= eCMD_C011_CMD_BASE + 0x03,
+    eCMD_C011_GET_VERSION	= eCMD_C011_CMD_BASE + 0x04,
+    eCMD_C011_GPIO		= eCMD_C011_CMD_BASE + 0x05,
+    eCMD_C011_DEBUG_SETUP	= eCMD_C011_CMD_BASE + 0x06,
+
+    /* Decoding commands */
+    eCMD_C011_DEC_CHAN_OPEN			= eCMD_C011_CMD_BASE + 0x100,
+    eCMD_C011_DEC_CHAN_CLOSE			= eCMD_C011_CMD_BASE + 0x101,
+    eCMD_C011_DEC_CHAN_ACTIVATE			= eCMD_C011_CMD_BASE + 0x102,
+    eCMD_C011_DEC_CHAN_STATUS			= eCMD_C011_CMD_BASE + 0x103,
+    eCMD_C011_DEC_CHAN_FLUSH			= eCMD_C011_CMD_BASE + 0x104,
+    eCMD_C011_DEC_CHAN_TRICK_PLAY		= eCMD_C011_CMD_BASE + 0x105,
+    eCMD_C011_DEC_CHAN_TS_PIDS			= eCMD_C011_CMD_BASE + 0x106,
+    eCMD_C011_DEC_CHAN_PS_STREAM_ID		= eCMD_C011_CMD_BASE + 0x107,
+    eCMD_C011_DEC_CHAN_INPUT_PARAMS		= eCMD_C011_CMD_BASE + 0x108,
+    eCMD_C011_DEC_CHAN_VIDEO_OUTPUT		= eCMD_C011_CMD_BASE + 0x109,
+    eCMD_C011_DEC_CHAN_OUTPUT_FORMAT		= eCMD_C011_CMD_BASE + 0x10A,
+    eCMD_C011_DEC_CHAN_SCALING_FILTERS		= eCMD_C011_CMD_BASE + 0x10B,
+    eCMD_C011_DEC_CHAN_OSD_MODE			= eCMD_C011_CMD_BASE + 0x10D,
+    eCMD_C011_DEC_CHAN_DROP			= eCMD_C011_CMD_BASE + 0x10E,
+    eCMD_C011_DEC_CHAN_RELEASE			= eCMD_C011_CMD_BASE + 0x10F,
+    eCMD_C011_DEC_CHAN_STREAM_SETTINGS		= eCMD_C011_CMD_BASE + 0x110,
+    eCMD_C011_DEC_CHAN_PAUSE_OUTPUT		= eCMD_C011_CMD_BASE + 0x111,
+    eCMD_C011_DEC_CHAN_CHANGE			= eCMD_C011_CMD_BASE + 0x112,
+    eCMD_C011_DEC_CHAN_SET_STC			= eCMD_C011_CMD_BASE + 0x113,
+    eCMD_C011_DEC_CHAN_SET_PTS			= eCMD_C011_CMD_BASE + 0x114,
+    eCMD_C011_DEC_CHAN_CC_MODE			= eCMD_C011_CMD_BASE + 0x115,
+    eCMD_C011_DEC_CREATE_AUDIO_CONTEXT		= eCMD_C011_CMD_BASE + 0x116,
+    eCMD_C011_DEC_COPY_AUDIO_CONTEXT		= eCMD_C011_CMD_BASE + 0x117,
+    eCMD_C011_DEC_DELETE_AUDIO_CONTEXT		= eCMD_C011_CMD_BASE + 0x118,
+    eCMD_C011_DEC_CHAN_SET_DECYPTION		= eCMD_C011_CMD_BASE + 0x119,
+    eCMD_C011_DEC_CHAN_START_VIDEO		= eCMD_C011_CMD_BASE + 0x11A,
+    eCMD_C011_DEC_CHAN_STOP_VIDEO		= eCMD_C011_CMD_BASE + 0x11B,
+    eCMD_C011_DEC_CHAN_PIC_CAPTURE		= eCMD_C011_CMD_BASE + 0x11C,
+    eCMD_C011_DEC_CHAN_PAUSE			= eCMD_C011_CMD_BASE + 0x11D,
+    eCMD_C011_DEC_CHAN_PAUSE_STATE		= eCMD_C011_CMD_BASE + 0x11E,
+    eCMD_C011_DEC_CHAN_SET_SLOWM_RATE		= eCMD_C011_CMD_BASE + 0x11F,
+    eCMD_C011_DEC_CHAN_GET_SLOWM_RATE		= eCMD_C011_CMD_BASE + 0x120,
+    eCMD_C011_DEC_CHAN_SET_FF_RATE		= eCMD_C011_CMD_BASE + 0x121,
+    eCMD_C011_DEC_CHAN_GET_FF_RATE		= eCMD_C011_CMD_BASE + 0x122,
+    eCMD_C011_DEC_CHAN_FRAME_ADVANCE		= eCMD_C011_CMD_BASE + 0x123,
+    eCMD_C011_DEC_CHAN_SET_SKIP_PIC_MODE	= eCMD_C011_CMD_BASE + 0x124,
+    eCMD_C011_DEC_CHAN_GET_SKIP_PIC_MODE	= eCMD_C011_CMD_BASE + 0x125,
+    eCMD_C011_DEC_CHAN_FILL_PIC_BUF		= eCMD_C011_CMD_BASE + 0x126,
+    eCMD_C011_DEC_CHAN_SET_CONTINUITY_CHECK	= eCMD_C011_CMD_BASE + 0x127,
+    eCMD_C011_DEC_CHAN_GET_CONTINUITY_CHECK	= eCMD_C011_CMD_BASE + 0x128,
+    eCMD_C011_DEC_CHAN_SET_BRCM_TRICK_MODE	= eCMD_C011_CMD_BASE + 0x129,
+    eCMD_C011_DEC_CHAN_GET_BRCM_TRICK_MODE	= eCMD_C011_CMD_BASE + 0x12A,
+    eCMD_C011_DEC_CHAN_REVERSE_FIELD_STATUS	= eCMD_C011_CMD_BASE + 0x12B,
+    eCMD_C011_DEC_CHAN_I_PICTURE_FOUND		= eCMD_C011_CMD_BASE + 0x12C,
+    eCMD_C011_DEC_CHAN_SET_PARAMETER		= eCMD_C011_CMD_BASE + 0x12D,
+    eCMD_C011_DEC_CHAN_SET_USER_DATA_MODE	= eCMD_C011_CMD_BASE + 0x12E,
+    eCMD_C011_DEC_CHAN_SET_PAUSE_DISPLAY_MODE	= eCMD_C011_CMD_BASE + 0x12F,
+    eCMD_C011_DEC_CHAN_SET_SLOW_DISPLAY_MODE	= eCMD_C011_CMD_BASE + 0x130,
+    eCMD_C011_DEC_CHAN_SET_FF_DISPLAY_MODE	= eCMD_C011_CMD_BASE + 0x131,
+    eCMD_C011_DEC_CHAN_SET_DISPLAY_TIMING_MODE	= eCMD_C011_CMD_BASE + 0x132,
+    eCMD_C011_DEC_CHAN_SET_DISPLAY_MODE		= eCMD_C011_CMD_BASE + 0x133,
+    eCMD_C011_DEC_CHAN_GET_DISPLAY_MODE		= eCMD_C011_CMD_BASE + 0x134,
+    eCMD_C011_DEC_CHAN_SET_REVERSE_FIELD	= eCMD_C011_CMD_BASE + 0x135,
+    eCMD_C011_DEC_CHAN_STREAM_OPEN		= eCMD_C011_CMD_BASE + 0x136,
+    eCMD_C011_DEC_CHAN_SET_PCR_PID		= eCMD_C011_CMD_BASE + 0x137,
+    eCMD_C011_DEC_CHAN_SET_VID_PID		= eCMD_C011_CMD_BASE + 0x138,
+    eCMD_C011_DEC_CHAN_SET_PAN_SCAN_MODE	= eCMD_C011_CMD_BASE + 0x139,
+    eCMD_C011_DEC_CHAN_START_DISPLAY_AT_PTS	= eCMD_C011_CMD_BASE + 0x140,
+    eCMD_C011_DEC_CHAN_STOP_DISPLAY_AT_PTS	= eCMD_C011_CMD_BASE + 0x141,
+    eCMD_C011_DEC_CHAN_SET_DISPLAY_ORDER	= eCMD_C011_CMD_BASE + 0x142,
+    eCMD_C011_DEC_CHAN_GET_DISPLAY_ORDER	= eCMD_C011_CMD_BASE + 0x143,
+    eCMD_C011_DEC_CHAN_SET_HOST_TRICK_MODE	= eCMD_C011_CMD_BASE + 0x144,
+    eCMD_C011_DEC_CHAN_SET_OPERATION_MODE	= eCMD_C011_CMD_BASE + 0x145,
+    eCMD_C011_DEC_CHAN_DISPLAY_PAUSE_UNTO_PTS	= eCMD_C011_CMD_BASE + 0x146,
+    eCMD_C011_DEC_CHAN_SET_PTS_STC_DIFF_THRESHOLD = eCMD_C011_CMD_BASE + 0x147,
+    eCMD_C011_DEC_CHAN_SEND_COMPRESSED_BUF	= eCMD_C011_CMD_BASE + 0x148,
+    eCMD_C011_DEC_CHAN_SET_CLIPPING		= eCMD_C011_CMD_BASE + 0x149,
+    eCMD_C011_DEC_CHAN_SET_PARAMETERS_FOR_HARD_RESET_INTERRUPT_TO_HOST
+						= eCMD_C011_CMD_BASE + 0x150,
+
+    /* Decoder RevD commands */
+    eCMD_C011_DEC_CHAN_SET_CSC	= eCMD_C011_CMD_BASE + 0x180, /* color space conversion */
+    eCMD_C011_DEC_CHAN_SET_RANGE_REMAP	= eCMD_C011_CMD_BASE + 0x181,
+    eCMD_C011_DEC_CHAN_SET_FGT		= eCMD_C011_CMD_BASE + 0x182,
+    /* Note: 0x183 not implemented yet in Rev D main */
+    eCMD_C011_DEC_CHAN_SET_LASTPICTURE_PADDING = eCMD_C011_CMD_BASE + 0x183,
+
+    /* Decoder 7412 commands (7412-only) */
+    eCMD_C011_DEC_CHAN_SET_CONTENT_KEY	= eCMD_C011_CMD_BASE + 0x190,
+    eCMD_C011_DEC_CHAN_SET_SESSION_KEY	= eCMD_C011_CMD_BASE + 0x191,
+    eCMD_C011_DEC_CHAN_FMT_CHANGE_ACK	= eCMD_C011_CMD_BASE + 0x192,
+
+    eCMD_C011_DEC_CHAN_CUSTOM_VIDOUT    = eCMD_C011_CMD_BASE + 0x1FF,
+
+    /* Encoding commands */
+    eCMD_C011_ENC_CHAN_OPEN		= eCMD_C011_CMD_BASE + 0x200,
+    eCMD_C011_ENC_CHAN_CLOSE		= eCMD_C011_CMD_BASE + 0x201,
+    eCMD_C011_ENC_CHAN_ACTIVATE		= eCMD_C011_CMD_BASE + 0x202,
+    eCMD_C011_ENC_CHAN_CONTROL		= eCMD_C011_CMD_BASE + 0x203,
+    eCMD_C011_ENC_CHAN_STATISTICS	= eCMD_C011_CMD_BASE + 0x204,
+
+    eNOTIFY_C011_ENC_CHAN_EVENT		= eCMD_C011_CMD_BASE + 0x210,
+
+} eC011_TS_CMD;
+
+#endif
diff --git a/drivers/staging/chd/crystalhd_hw.c b/drivers/staging/chd/crystalhd_hw.c
new file mode 100644
index 0000000..cb46836
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_hw.c
@@ -0,0 +1,1048 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_hw . c
+ *
+ *  Description:
+ *		BCM70012/BCM70015 Linux driver hardware layer.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/tsc.h>
+#include <asm/msr.h>
+#include "crystalhd_lnx.h"
+#include "crystalhd_linkfuncs.h"
+#include "crystalhd_fleafuncs.h"
+
+#define OFFSETOF(_s_, _m_) ((size_t)(unsigned long)&(((_s_ *)0)->_m_))
+
+BC_STATUS crystalhd_hw_open(struct crystalhd_hw *hw, struct crystalhd_adp *adp)
+{
+	struct device *dev;
+	if (!hw || !adp) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (hw->dev_started)
+		return BC_STS_SUCCESS;
+
+	dev = &adp->pdev->dev;
+	hw->PauseThreshold = BC_RX_LIST_CNT - 2;
+	hw->DefaultPauseThreshold = BC_RX_LIST_CNT - 2;
+	hw->ResumeThreshold = 3;
+
+	// Setup HW specific functions appropriately
+	if (adp->pdev->device == BC_PCI_DEVID_FLEA) {
+		dev_dbg(dev, "crystalhd_hw_open: setting up functions, device = Flea\n");
+		hw->pfnStartDevice = crystalhd_flea_start_device;
+		hw->pfnStopDevice = crystalhd_flea_stop_device;
+		hw->pfnFindAndClearIntr = crystalhd_flea_hw_interrupt_handle;
+		hw->pfnReadDevRegister = crystalhd_flea_reg_rd;					// Done
+		hw->pfnWriteDevRegister = crystalhd_flea_reg_wr;				// Done
+		hw->pfnReadFPGARegister = crystalhd_flea_reg_rd;				// Done
+		hw->pfnWriteFPGARegister = crystalhd_flea_reg_wr;				// Done
+		hw->pfnCheckInputFIFO = crystalhd_flea_check_input_full;
+		hw->pfnDevDRAMRead = crystalhd_flea_mem_rd;						// Done
+		hw->pfnDevDRAMWrite = crystalhd_flea_mem_wr;					// Done
+		hw->pfnDoFirmwareCmd = crystalhd_flea_do_fw_cmd;
+		hw->pfnFWDwnld = crystalhd_flea_download_fw;
+		hw->pfnHWGetDoneSize = crystalhd_flea_get_dnsz;
+		hw->pfnIssuePause = crystalhd_flea_hw_pause;
+		hw->pfnPeekNextDeodedFr = crystalhd_flea_peek_next_decoded_frame;
+		hw->pfnPostRxSideBuff = crystalhd_flea_hw_post_cap_buff;
+		hw->pfnStartTxDMA = crystalhd_flea_start_tx_dma_engine;
+		hw->pfnStopTxDMA = crystalhd_flea_stop_tx_dma_engine;
+		hw->pfnStopRXDMAEngines = crystalhd_flea_stop_rx_dma_engine;
+		hw->pfnNotifyFLLChange = crystalhd_flea_notify_fll_change;
+		hw->pfnNotifyHardware = crystalhd_flea_notify_event;
+	} else {
+		dev_dbg(dev, "crystalhd_hw_open: setting up functions, device = Link\n");
+		hw->pfnStartDevice = crystalhd_link_start_device;
+		hw->pfnStopDevice = crystalhd_link_stop_device;
+		hw->pfnFindAndClearIntr = crystalhd_link_hw_interrupt_handle;
+		hw->pfnReadDevRegister = link_dec_reg_rd;
+		hw->pfnWriteDevRegister = link_dec_reg_wr;
+		hw->pfnReadFPGARegister = crystalhd_link_reg_rd;
+		hw->pfnWriteFPGARegister = crystalhd_link_reg_wr;
+		hw->pfnCheckInputFIFO = crystalhd_link_check_input_full;
+		hw->pfnDevDRAMRead = crystalhd_link_mem_rd;
+		hw->pfnDevDRAMWrite = crystalhd_link_mem_wr;
+		hw->pfnDoFirmwareCmd = crystalhd_link_do_fw_cmd;
+		hw->pfnFWDwnld = crystalhd_link_download_fw;
+		hw->pfnHWGetDoneSize = crystalhd_link_get_dnsz;
+		hw->pfnIssuePause = crystalhd_link_hw_pause;
+		hw->pfnPeekNextDeodedFr = crystalhd_link_peek_next_decoded_frame;
+		hw->pfnPostRxSideBuff = crystalhd_link_hw_post_cap_buff;
+		hw->pfnStartTxDMA = crystalhd_link_start_tx_dma_engine;
+		hw->pfnStopTxDMA = crystalhd_link_stop_tx_dma_engine;
+		hw->pfnStopRXDMAEngines = crystalhd_link_stop_rx_dma_engine;
+		hw->pfnNotifyFLLChange = crystalhd_link_notify_fll_change;
+		hw->pfnNotifyHardware = crystalhd_link_notify_event;
+	}
+
+	hw->adp = adp;
+	spin_lock_init(&hw->lock);
+	spin_lock_init(&hw->rx_lock);
+	sema_init(&hw->fetch_sem, 1);
+
+	// Seed for error checking and debugging. Random numbers */
+	hw->tx_ioq_tag_seed = 0x70023070;
+	hw->rx_pkt_tag_seed = 0x70029070;
+
+	hw->stop_pending = 0;
+	hw->pfnStartDevice(hw);
+	hw->dev_started = true;
+
+	dev_dbg(dev, "Opening HW. hw:0x%lx, hw->adp:0x%lx\n",
+		(uintptr_t)hw, (uintptr_t)(hw->adp));
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_close(struct crystalhd_hw *hw, struct crystalhd_adp *adp)
+{
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_SUCCESS;
+	}
+
+	if (!hw->dev_started)
+		return BC_STS_SUCCESS;
+
+	/* Stop and DDR sleep will happen in here */
+	// Only stop the HW if we are the last user
+	if(adp->cfg_users == 1)
+		crystalhd_hw_suspend(hw);
+
+	hw->dev_started = false;
+
+	return BC_STS_SUCCESS;
+}
+
+crystalhd_rx_dma_pkt *crystalhd_hw_alloc_rx_pkt(struct crystalhd_hw *hw)
+{
+	unsigned long flags = 0;
+	crystalhd_rx_dma_pkt *temp = NULL;
+
+	if (!hw)
+		return NULL;
+
+	spin_lock_irqsave(&hw->lock, flags);
+	temp = hw->rx_pkt_pool_head;
+	if (temp) {
+		hw->rx_pkt_pool_head = hw->rx_pkt_pool_head->next;
+		temp->dio_req = NULL;
+		temp->pkt_tag = 0;
+		temp->flags = 0;
+	}
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return temp;
+}
+
+void crystalhd_hw_free_rx_pkt(struct crystalhd_hw *hw,
+				   crystalhd_rx_dma_pkt *pkt)
+{
+	unsigned long flags = 0;
+
+	if (!hw || !pkt)
+		return;
+
+	spin_lock_irqsave(&hw->lock, flags);
+	pkt->next = hw->rx_pkt_pool_head;
+	hw->rx_pkt_pool_head = pkt;
+	spin_unlock_irqrestore(&hw->lock, flags);
+}
+
+/*
+ * Call back from TX - IOQ deletion.
+ *
+ * This routine will release the TX DMA rings allocated
+ * druing setup_dma rings interface.
+ *
+ * Memory is allocated per DMA ring basis. This is just
+ * a place holder to be able to create the dio queues.
+ */
+void crystalhd_tx_desc_rel_call_back(void *context, void *data)
+{
+}
+
+/*
+ * Rx Packet release callback..
+ *
+ * Release All user mapped capture buffers and Our DMA packets
+ * back to our free pool. The actual cleanup of the DMA
+ * ring descriptors happen during dma ring release.
+ */
+void crystalhd_rx_pkt_rel_call_back(void *context, void *data)
+{
+	struct crystalhd_hw *hw = (struct crystalhd_hw *)context;
+	crystalhd_rx_dma_pkt *pkt = (crystalhd_rx_dma_pkt *)data;
+
+	if (!pkt || !hw) {
+		printk(KERN_ERR "%s: Invalid arg - %p %p\n", __func__, hw, pkt);
+		return;
+	}
+
+	if (pkt->dio_req)
+		crystalhd_unmap_dio(hw->adp, pkt->dio_req);
+
+	crystalhd_hw_free_rx_pkt(hw, pkt);
+}
+
+#define crystalhd_hw_delete_ioq(adp, q)		\
+	if (q) {				\
+		crystalhd_delete_dioq(adp, q);	\
+		q = NULL;			\
+	}
+
+void crystalhd_hw_delete_ioqs(struct crystalhd_hw *hw)
+{
+	if (!hw)
+		return;
+
+	crystalhd_hw_delete_ioq(hw->adp, hw->tx_actq);
+	crystalhd_hw_delete_ioq(hw->adp, hw->tx_freeq);
+	crystalhd_hw_delete_ioq(hw->adp, hw->rx_actq);
+	crystalhd_hw_delete_ioq(hw->adp, hw->rx_freeq);
+	crystalhd_hw_delete_ioq(hw->adp, hw->rx_rdyq);
+}
+
+#define crystalhd_hw_create_ioq(sts, hw, q, cb)			\
+do {								\
+	sts = crystalhd_create_dioq(hw->adp, &q, cb, hw);	\
+	if (sts != BC_STS_SUCCESS)				\
+		goto hw_create_ioq_err;				\
+} while (0)
+
+/*
+ * Create IOQs..
+ *
+ * TX - Active & Free
+ * RX - Active, Ready and Free.
+ */
+BC_STATUS crystalhd_hw_create_ioqs(struct crystalhd_hw *hw)
+{
+	BC_STATUS   sts = BC_STS_SUCCESS;
+
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arg!!\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	crystalhd_hw_create_ioq(sts, hw, hw->tx_freeq,
+			      crystalhd_tx_desc_rel_call_back);
+	crystalhd_hw_create_ioq(sts, hw, hw->tx_actq,
+			      crystalhd_tx_desc_rel_call_back);
+
+	crystalhd_hw_create_ioq(sts, hw, hw->rx_freeq,
+			      crystalhd_rx_pkt_rel_call_back);
+	crystalhd_hw_create_ioq(sts, hw, hw->rx_rdyq,
+			      crystalhd_rx_pkt_rel_call_back);
+	crystalhd_hw_create_ioq(sts, hw, hw->rx_actq,
+			      crystalhd_rx_pkt_rel_call_back);
+
+	return sts;
+
+hw_create_ioq_err:
+	crystalhd_hw_delete_ioqs(hw);
+
+	return sts;
+}
+
+BC_STATUS crystalhd_hw_setup_dma_rings(struct crystalhd_hw *hw)
+{
+	struct device *dev;
+	unsigned int i;
+	void *mem;
+	size_t mem_len;
+	dma_addr_t phy_addr;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	crystalhd_rx_dma_pkt *rpkt;
+
+	if (!hw || !hw->adp) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	sts = crystalhd_hw_create_ioqs(hw);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "Failed to create IOQs..\n");
+		return sts;
+	}
+
+	mem_len = BC_LINK_MAX_SGLS * sizeof(dma_descriptor);
+
+	for (i = 0; i < BC_TX_LIST_CNT; i++) {
+		mem = bc_kern_dma_alloc(hw->adp, mem_len, &phy_addr);
+		if (mem) {
+			memset(mem, 0, mem_len);
+		} else {
+			dev_err(dev, "Insufficient Memory For TX\n");
+			crystalhd_hw_free_dma_rings(hw);
+			return BC_STS_INSUFF_RES;
+		}
+		/* rx_pkt_pool -- static memory allocation  */
+		hw->tx_pkt_pool[i].desc_mem.pdma_desc_start = mem;
+		hw->tx_pkt_pool[i].desc_mem.phy_addr = phy_addr;
+		hw->tx_pkt_pool[i].desc_mem.sz = BC_LINK_MAX_SGLS *
+						 sizeof(dma_descriptor);
+		hw->tx_pkt_pool[i].list_tag = 0;
+
+		/* Add TX dma requests to Free Queue..*/
+		sts = crystalhd_dioq_add(hw->tx_freeq,
+				       &hw->tx_pkt_pool[i], false, 0);
+		if (sts != BC_STS_SUCCESS) {
+			crystalhd_hw_free_dma_rings(hw);
+			return sts;
+		}
+	}
+
+	for (i = 0; i < BC_RX_LIST_CNT; i++) {
+		rpkt = kzalloc(sizeof(*rpkt), GFP_KERNEL);
+		if (!rpkt) {
+			dev_err(dev, "Insufficient Memory For RX\n");
+			crystalhd_hw_free_dma_rings(hw);
+			return BC_STS_INSUFF_RES;
+		}
+
+		mem = bc_kern_dma_alloc(hw->adp, mem_len, &phy_addr);
+		if (mem) {
+			memset(mem, 0, mem_len);
+		} else {
+			dev_err(dev, "Insufficient Memory For RX\n");
+			crystalhd_hw_free_dma_rings(hw);
+			return BC_STS_INSUFF_RES;
+		}
+		rpkt->desc_mem.pdma_desc_start = mem;
+		rpkt->desc_mem.phy_addr = phy_addr;
+		rpkt->desc_mem.sz  = BC_LINK_MAX_SGLS * sizeof(dma_descriptor);
+		rpkt->pkt_tag = hw->rx_pkt_tag_seed + i;
+		crystalhd_hw_free_rx_pkt(hw, rpkt);
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_free_dma_rings(struct crystalhd_hw *hw)
+{
+	unsigned int i;
+	crystalhd_rx_dma_pkt *rpkt = NULL;
+
+	if (!hw || !hw->adp) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	/* Delete all IOQs.. */
+	crystalhd_hw_delete_ioqs(hw);
+
+	for (i = 0; i < BC_TX_LIST_CNT; i++) {
+		if (hw->tx_pkt_pool[i].desc_mem.pdma_desc_start) {
+			bc_kern_dma_free(hw->adp,
+				hw->tx_pkt_pool[i].desc_mem.sz,
+				hw->tx_pkt_pool[i].desc_mem.pdma_desc_start,
+				hw->tx_pkt_pool[i].desc_mem.phy_addr);
+
+			hw->tx_pkt_pool[i].desc_mem.pdma_desc_start = NULL;
+		}
+	}
+
+	dev_dbg(&hw->adp->pdev->dev, "Releasing RX Pkt pool\n");
+	for (i = 0; i < BC_RX_LIST_CNT; i++) {
+		rpkt = crystalhd_hw_alloc_rx_pkt(hw);
+		if (!rpkt)
+			break;
+		bc_kern_dma_free(hw->adp, rpkt->desc_mem.sz,
+				 rpkt->desc_mem.pdma_desc_start,
+				 rpkt->desc_mem.phy_addr);
+		kfree(rpkt);
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_tx_req_complete(struct crystalhd_hw *hw,
+											  uint32_t list_id, BC_STATUS cs)
+{
+	tx_dma_pkt *tx_req;
+
+	if (!hw || !list_id) {
+		printk(KERN_ERR "%s: Invalid Arg!!\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	tx_req = (tx_dma_pkt *)crystalhd_dioq_find_and_fetch(hw->tx_actq, list_id);
+	if (!tx_req) {
+		if (cs != BC_STS_IO_USER_ABORT)
+			dev_err(&hw->adp->pdev->dev, "Find/Fetch: no req!\n");
+		return BC_STS_NO_DATA;
+	}
+
+	if (tx_req->call_back) {
+		tx_req->call_back(tx_req->dio_req, tx_req->cb_event, cs);
+		tx_req->dio_req   = NULL;
+		tx_req->cb_event  = NULL;
+		tx_req->call_back = NULL;
+	} else {
+		dev_dbg(&hw->adp->pdev->dev, "Missing Tx Callback - %X\n",
+		tx_req->list_tag);
+	}
+
+	/* Now put back the tx_list back in FreeQ */
+	tx_req->list_tag = 0;
+
+	return crystalhd_dioq_add(hw->tx_freeq, tx_req, false, 0);
+}
+
+BC_STATUS crystalhd_hw_fill_desc(crystalhd_dio_req *ioreq,
+										dma_descriptor *desc,
+										dma_addr_t desc_paddr_base,
+										uint32_t sg_cnt, uint32_t sg_st_ix,
+										uint32_t sg_st_off, uint32_t xfr_sz,
+										struct device *dev, uint32_t destDRAMaddr)
+{
+	uint32_t count = 0, ix = 0, sg_ix = 0, len = 0, last_desc_ix = 0;
+	dma_addr_t desc_phy_addr = desc_paddr_base;
+	addr_64 addr_temp;
+	uint32_t curDRAMaddr = destDRAMaddr;
+
+	if (!ioreq || !desc || !desc_paddr_base || !xfr_sz ||
+		(!sg_cnt && !ioreq->uinfo.dir_tx)) {
+		dev_err(dev, "%s: Invalid Args\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	for (ix = 0; ix < sg_cnt; ix++) {
+
+		/* Setup SGLE index. */
+		sg_ix = ix + sg_st_ix;
+
+		/* Get SGLE length */
+		len = crystalhd_get_sgle_len(ioreq, sg_ix);
+		if (len % 4) {
+			dev_err(dev, "unsupported len in sg %d %d %d\n",
+			len, sg_ix, sg_cnt);
+			return BC_STS_NOT_IMPL;
+		}
+		/* Setup DMA desc with Phy addr & Length at current index. */
+		addr_temp.full_addr = crystalhd_get_sgle_paddr(ioreq, sg_ix);
+		if (sg_ix == sg_st_ix) {
+			addr_temp.full_addr += sg_st_off;
+			len -= sg_st_off;
+		}
+		memset(&desc[ix], 0, sizeof(desc[ix]));
+		desc[ix].buff_addr_low  = addr_temp.low_part;
+		desc[ix].buff_addr_high = addr_temp.high_part;
+		desc[ix].dma_dir        = ioreq->uinfo.dir_tx; // RX dma_dir = 0, TX dma_dir = 1
+
+		/* Chain DMA descriptor.  */
+		addr_temp.full_addr = desc_phy_addr + sizeof(dma_descriptor);
+		desc[ix].next_desc_addr_low = addr_temp.low_part;
+		desc[ix].next_desc_addr_high = addr_temp.high_part;
+
+		if ((count + len) > xfr_sz)
+			len = xfr_sz - count;
+
+		/* Debug.. */
+		if ((!len) || (len > crystalhd_get_sgle_len(ioreq, sg_ix))) {
+			dev_err(dev, "inv-len(%x) Ix(%d) count:%x xfr_sz:%x "
+			"sg_cnt:%d\n", len, ix, count, xfr_sz, sg_cnt);
+			return BC_STS_ERROR;
+		}
+		/* Length expects Multiple of 4 */
+		desc[ix].xfer_size = (len / 4);
+
+		count += len;
+		// If TX fill in the destination DRAM address if needed
+		if(ioreq->uinfo.dir_tx) {
+			desc[ix].sdram_buff_addr = curDRAMaddr;
+			curDRAMaddr = destDRAMaddr + count;
+		}
+		else
+			desc[ix].sdram_buff_addr = 0;
+
+		desc_phy_addr += sizeof(dma_descriptor);
+	}
+
+	last_desc_ix = ix - 1;
+
+	if (ioreq->fb_size) {
+		memset(&desc[ix], 0, sizeof(desc[ix]));
+		addr_temp.full_addr     = ioreq->fb_pa;
+		desc[ix].buff_addr_low  = addr_temp.low_part;
+		desc[ix].buff_addr_high = addr_temp.high_part;
+		desc[ix].dma_dir        = ioreq->uinfo.dir_tx;
+		desc[ix].xfer_size	= 1;
+		desc[ix].fill_bytes	= 4 - ioreq->fb_size;
+		count += ioreq->fb_size;
+		// If TX fill in the destination DRAM address if needed
+		if(ioreq->uinfo.dir_tx) {
+			desc[ix].sdram_buff_addr = curDRAMaddr;
+			curDRAMaddr = destDRAMaddr + count;
+		}
+		else
+			desc[ix].sdram_buff_addr = 0;
+		last_desc_ix++;
+	}
+
+	/* setup last descriptor..*/
+	desc[last_desc_ix].last_rec_indicator  = 1;
+	desc[last_desc_ix].next_desc_addr_low  = 0;
+	desc[last_desc_ix].next_desc_addr_high = 0;
+	desc[last_desc_ix].intr_enable = 1;
+
+	if (count != xfr_sz) {
+		dev_err(dev, "interal error sz curr:%x exp:%x\n",
+		count, xfr_sz);
+		return BC_STS_ERROR;
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_xlat_sgl_to_dma_desc(crystalhd_dio_req *ioreq,
+												pdma_desc_mem pdesc_mem,
+												uint32_t *uv_desc_index,
+												struct device *dev, uint32_t destDRAMaddr)
+{
+	dma_descriptor *desc = NULL;
+	dma_addr_t desc_paddr_base = 0;
+	uint32_t sg_cnt = 0, sg_st_ix = 0, sg_st_off = 0;
+	uint32_t xfr_sz = 0;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	/* Check params.. */
+	if (!ioreq || !pdesc_mem || !uv_desc_index) {
+		dev_err(dev, "%s: Invalid Args\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (!pdesc_mem->sz || !pdesc_mem->pdma_desc_start ||
+		!ioreq->sg || (!ioreq->sg_cnt && !ioreq->uinfo.dir_tx)) {
+		dev_err(dev, "%s: Invalid Args\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if ((ioreq->uinfo.dir_tx) && (ioreq->uinfo.uv_offset)) {
+		dev_err(dev, "%s: UV offset for TX??\n", __func__);
+		return BC_STS_INV_ARG;
+
+	}
+
+	desc = pdesc_mem->pdma_desc_start;
+	desc_paddr_base = pdesc_mem->phy_addr;
+
+	if (ioreq->uinfo.dir_tx || (ioreq->uinfo.uv_offset == 0)) {
+		sg_cnt = ioreq->sg_cnt;
+		xfr_sz = ioreq->uinfo.xfr_len;
+	} else {
+		sg_cnt = ioreq->uinfo.uv_sg_ix + 1;
+		xfr_sz = ioreq->uinfo.uv_offset;
+	}
+
+	sts = crystalhd_hw_fill_desc(ioreq, desc, desc_paddr_base, sg_cnt,
+									sg_st_ix, sg_st_off, xfr_sz, dev, destDRAMaddr);
+
+	if ((sts != BC_STS_SUCCESS) || !ioreq->uinfo.uv_offset)
+		return sts;
+
+	/* Prepare for UV mapping.. */
+	desc = &pdesc_mem->pdma_desc_start[sg_cnt];
+	desc_paddr_base = pdesc_mem->phy_addr +
+	(sg_cnt * sizeof(dma_descriptor));
+
+	/* Done with desc addr.. now update sg stuff.*/
+	sg_cnt    = ioreq->sg_cnt - ioreq->uinfo.uv_sg_ix;
+	xfr_sz    = ioreq->uinfo.xfr_len - ioreq->uinfo.uv_offset;
+	sg_st_ix  = ioreq->uinfo.uv_sg_ix;
+	sg_st_off = ioreq->uinfo.uv_sg_off;
+
+	sts = crystalhd_hw_fill_desc(ioreq, desc, desc_paddr_base, sg_cnt,
+								sg_st_ix, sg_st_off, xfr_sz, dev, destDRAMaddr);
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	*uv_desc_index = sg_st_ix;
+
+	return sts;
+}
+
+BC_STATUS crystalhd_rx_pkt_done(struct crystalhd_hw *hw,
+									   uint32_t list_index,
+									   BC_STATUS comp_sts)
+{
+	crystalhd_rx_dma_pkt *rx_pkt = NULL;
+	uint32_t y_dw_dnsz, uv_dw_dnsz;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	uint64_t currTick;
+
+	uint32_t totalTick_Hi;
+	uint32_t TickSpentInPD_Hi;
+	uint64_t temp_64;
+	int32_t totalTick_Hi_f;
+	int32_t TickSpentInPD_Hi_f;
+
+	if (!hw || list_index >= DMA_ENGINE_CNT) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	rx_pkt = crystalhd_dioq_find_and_fetch(hw->rx_actq,
+	hw->rx_pkt_tag_seed + list_index);
+	if (!rx_pkt) {
+		dev_err(&hw->adp->pdev->dev, "Act-Q: PostIx:%x L0Sts:%x "
+		"L1Sts:%x current L:%x tag:%x comp:%x\n",
+				hw->rx_list_post_index, hw->rx_list_sts[0],
+				hw->rx_list_sts[1], list_index,
+				hw->rx_pkt_tag_seed + list_index, comp_sts);
+				return BC_STS_INV_ARG;
+	}
+
+	if (comp_sts == BC_STS_SUCCESS)
+	{
+		hw->DrvTotalFrmCaptured++;
+
+		hw->pfnHWGetDoneSize(hw, list_index, &y_dw_dnsz, &uv_dw_dnsz);
+		rx_pkt->dio_req->uinfo.y_done_sz = y_dw_dnsz;
+		rx_pkt->flags = COMP_FLAG_DATA_VALID;
+		if (rx_pkt->uv_phy_addr)
+			rx_pkt->dio_req->uinfo.uv_done_sz = uv_dw_dnsz;
+		crystalhd_dioq_add(hw->rx_rdyq, rx_pkt, true,
+							hw->rx_pkt_tag_seed + list_index);
+
+		if( hw->adp->pdev->device == BC_PCI_DEVID_FLEA)
+		{
+			//printk("pre-PD state %x RLL %x Ptsh %x ratio %d currentPS %d\n",
+			//	hw->FleaPowerState, crystalhd_dioq_count(hw->rx_rdyq) , hw->PauseThreshold, hw->PDRatio, hw->FleaPowerState);
+			if(hw->FleaPowerState == FLEA_PS_ACTIVE)
+			{
+				if(crystalhd_dioq_count(hw->rx_rdyq) >= hw->PauseThreshold)
+				{
+					hw->pfnIssuePause(hw, true);
+					hw->hw_pause_issued = true;
+				}
+				/* NAREN check if the PD ratio is less than 50. If so, try to reduce the PauseThreshold to improve the ratio */
+				/* never go lower than 6 pictures */
+				/* Only do this when we have some data to determine PDRatio */
+				/* For now assume that if we have captured 100 pictures then we should have enough data for the analysis to start */
+				if((hw->PDRatio < 50) && (hw->PauseThreshold > 6) && (hw->DrvTotalFrmCaptured > 100))
+				{
+					//printk("Current PDRatio:%u, PauseThreshold:%u, DrvTotalFrmCaptured:%u  decress PauseThreshold\n",
+					//	hw->PDRatio, hw->PauseThreshold, hw->DrvTotalFrmCaptured);
+					hw->PauseThreshold--;
+				}
+				else {
+					rdtscll(currTick);
+
+					temp_64 = (hw->TickSpentInPD)>>24;
+					TickSpentInPD_Hi = (uint32_t)(temp_64);
+					TickSpentInPD_Hi_f = (int32_t)TickSpentInPD_Hi;
+
+					temp_64 = (currTick - hw->TickCntDecodePU)>>24;
+					totalTick_Hi = (uint32_t)(temp_64);
+					totalTick_Hi_f = (int32_t)totalTick_Hi;
+
+					if( totalTick_Hi_f <= 0 )
+					{
+						temp_64 = (hw->TickSpentInPD);
+						TickSpentInPD_Hi = (uint32_t)(temp_64);
+						TickSpentInPD_Hi_f = (int32_t)TickSpentInPD_Hi;
+
+						temp_64 = (currTick - hw->TickCntDecodePU);
+						totalTick_Hi = (uint32_t)(temp_64);
+						totalTick_Hi_f = (int32_t)totalTick_Hi;
+					}
+
+					if( totalTick_Hi_f <= 0 )
+					{
+						printk("totalTick_Hi_f <= 0, set hw->PDRatio = 60\n");
+						hw->PDRatio = 60;
+					}
+					else
+						hw->PDRatio = (TickSpentInPD_Hi_f * 100) / totalTick_Hi_f;
+
+					//printk("Current PDRatio:%u, PauseThreshold:%u, DrvTotalFrmCaptured:%u  don't decress PauseThreshold\n",
+					//	hw->PDRatio, hw->PauseThreshold, hw->DrvTotalFrmCaptured);
+
+					//hw->PDRatio = ((uint32_t)(hw->TickSpentInPD))/((uint32_t)(currTick - hw->TickCntDecodePU)/100);
+				}
+			}
+		}
+		else if( hw->hw_pause_issued == false )
+		{
+// 			if(crystalhd_dioq_count(hw->rx_rdyq) > hw->PauseThreshold)//HW_PAUSE_THRESHOLD
+// 			{
+// 				dev_info(&hw->adp->pdev->dev, "HW PAUSE\n");
+// 				hw->pfnIssuePause(hw, true);
+// 				hw->hw_pause_issued = true;
+// 			}
+		}
+
+		return sts;
+	}
+	/* Check if we can post this DIO again. */
+	return hw->pfnPostRxSideBuff(hw, rx_pkt);
+}
+
+BC_STATUS crystalhd_hw_post_tx(struct crystalhd_hw *hw, crystalhd_dio_req *ioreq,
+			     hw_comp_callback call_back,
+			     wait_queue_head_t *cb_event, uint32_t *list_id,
+			     uint8_t data_flags)
+{
+	struct device *dev;
+	tx_dma_pkt *tx_dma_packet = NULL;
+	uint32_t low_addr, high_addr;
+	addr_64 desc_addr;
+	BC_STATUS sts, add_sts;
+	uint32_t dummy_index = 0;
+	unsigned long flags;
+	uint8_t list_posted;
+	uint8_t local_flags = data_flags;
+	bool rc;
+	uint32_t destDRAMaddr = 0;
+
+	if (!hw || !ioreq || !call_back || !cb_event || !list_id) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	/*
+	 * Since we hit code in busy condition very frequently,
+	 * we will check the code in status first before
+	 * checking the availability of free elem.
+	 *
+	 * This will avoid the Q fetch/add in normal condition.
+	 */
+
+	rc = hw->pfnCheckInputFIFO(hw, ioreq->uinfo.xfr_len,
+					   &dummy_index, false, &local_flags);
+
+	if (rc) {
+		hw->stats.cin_busy++;
+		return BC_STS_BUSY;
+	}
+
+	if(local_flags & BC_BIT(7))
+		destDRAMaddr = hw->TxFwInputBuffInfo.DramBuffAdd;
+
+	/* Get a list from TxFreeQ */
+	tx_dma_packet = (tx_dma_pkt *)crystalhd_dioq_fetch(hw->tx_freeq);
+	if (!tx_dma_packet) {
+		dev_err(dev, "No empty elements..\n");
+		return BC_STS_ERR_USAGE;
+	}
+
+	sts = crystalhd_xlat_sgl_to_dma_desc(ioreq,
+					     &tx_dma_packet->desc_mem,
+					     &dummy_index, dev, destDRAMaddr);
+	if (sts != BC_STS_SUCCESS) {
+		add_sts = crystalhd_dioq_add(hw->tx_freeq, tx_dma_packet,
+					   false, 0);
+		if (add_sts != BC_STS_SUCCESS)
+			dev_err(dev, "double fault..\n");
+
+		return sts;
+	}
+
+	desc_addr.full_addr = tx_dma_packet->desc_mem.phy_addr;
+	low_addr = desc_addr.low_part;
+	high_addr = desc_addr.high_part;
+
+	tx_dma_packet->call_back = call_back;
+	tx_dma_packet->cb_event  = cb_event;
+	tx_dma_packet->dio_req   = ioreq;
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	list_posted = hw->tx_list_post_index;
+
+	*list_id = tx_dma_packet->list_tag = hw->tx_ioq_tag_seed +
+					     hw->tx_list_post_index;
+
+
+	if( hw->tx_list_post_index % DMA_ENGINE_CNT) {
+		hw->TxList1Sts |= TxListWaitingForIntr;
+	}
+	else {
+		hw->TxList0Sts |= TxListWaitingForIntr;
+	}
+
+	hw->tx_list_post_index = (hw->tx_list_post_index + 1) % DMA_ENGINE_CNT;
+
+	/* Insert in Active Q..*/
+	crystalhd_dioq_add(hw->tx_actq, tx_dma_packet, false,
+			 tx_dma_packet->list_tag);
+
+	/*
+	 * Interrupt will come as soon as you write
+	 * the valid bit. So be ready for that. All
+	 * the initialization should happen before that.
+	 */
+
+	// Save the transfer length
+	hw->TxFwInputBuffInfo.HostXferSzInBytes = ioreq->uinfo.xfr_len;
+
+	hw->pfnStartTxDMA(hw, list_posted, desc_addr);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return BC_STS_SUCCESS;
+}
+
+/*
+ * This is a force cancel and we are racing with ISR.
+ *
+ * Will try to remove the req from ActQ before ISR gets it.
+ * If ISR gets it first then the completion happens in the
+ * normal path and we will return _STS_NO_DATA from here.
+ *
+ * FIX_ME: Not Tested the actual condition..
+ */
+BC_STATUS crystalhd_hw_cancel_tx(struct crystalhd_hw *hw, uint32_t list_id)
+{
+	unsigned long flags;
+	if (!hw || !list_id) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	spin_lock_irqsave(&hw->lock, flags);
+	hw->pfnStopTxDMA(hw);
+	spin_unlock_irqrestore(&hw->lock, flags);
+	crystalhd_hw_tx_req_complete(hw, list_id, BC_STS_IO_USER_ABORT);
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_add_cap_buffer(struct crystalhd_hw *hw,
+				    crystalhd_dio_req *ioreq, bool en_post)
+{
+	crystalhd_rx_dma_pkt *rpkt;
+	uint32_t tag, uv_desc_ix = 0;
+	BC_STATUS sts;
+
+	if (!hw || !ioreq) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	rpkt = crystalhd_hw_alloc_rx_pkt(hw);
+	if (!rpkt) {
+		dev_err(&hw->adp->pdev->dev, "Insufficient resources\n");
+		return BC_STS_INSUFF_RES;
+	}
+
+	rpkt->dio_req = ioreq;
+	tag = rpkt->pkt_tag;
+
+	sts = crystalhd_xlat_sgl_to_dma_desc(ioreq, &rpkt->desc_mem,
+					     &uv_desc_ix, &hw->adp->pdev->dev, 0);
+	if (sts != BC_STS_SUCCESS)
+		return sts;
+
+	rpkt->uv_phy_addr = 0;
+
+	/* Store the address of UV in the rx packet for post*/
+	if (uv_desc_ix)
+		rpkt->uv_phy_addr = rpkt->desc_mem.phy_addr +
+				    (sizeof(dma_descriptor) * (uv_desc_ix + 1));
+
+	if (en_post && !hw->hw_pause_issued) {
+		sts = hw->pfnPostRxSideBuff(hw, rpkt);
+	}
+	else {
+		sts = crystalhd_dioq_add(hw->rx_freeq, rpkt, false, tag);
+		hw->pfnNotifyFLLChange(hw, false);
+	}
+
+	return sts;
+}
+
+BC_STATUS crystalhd_hw_get_cap_buffer(struct crystalhd_hw *hw,
+										C011_PIB *pib,
+										crystalhd_dio_req **ioreq)
+{
+	crystalhd_rx_dma_pkt *rpkt;
+	uint32_t timeout = BC_PROC_OUTPUT_TIMEOUT / 1000;
+	uint32_t sig_pending = 0;
+
+	if (!hw || !ioreq || !pib) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	rpkt = crystalhd_dioq_fetch_wait(hw, timeout, &sig_pending);
+
+	if( hw->adp->pdev->device == BC_PCI_DEVID_FLEA)
+	{
+		//printk("pre-PU state %x RLL %x Rtsh %x, currentPS %d,\n",
+		//	hw->FleaPowerState, crystalhd_dioq_count(hw->rx_rdyq) , hw->ResumeThreshold, hw->FleaPowerState);
+		if( (hw->FleaPowerState == FLEA_PS_LP_PENDING) ||
+			(hw->FleaPowerState == FLEA_PS_LP_COMPLETE))
+		{
+			if(crystalhd_dioq_count(hw->rx_rdyq)  <= hw->ResumeThreshold)
+				hw->pfnIssuePause(hw, false);	/*Need this Notification For Flea*/
+				hw->hw_pause_issued = false;
+		}
+	}
+	else if( hw->hw_pause_issued)
+	{
+// 		if(crystalhd_dioq_count(hw->rx_rdyq) < hw->PauseThreshold ) //HW_RESUME_THRESHOLD
+// 		{
+// 			dev_info(&hw->adp->pdev->dev, "HW RESUME with rdy list %u \n",crystalhd_dioq_count(hw->rx_rdyq));
+// 			hw->pfnIssuePause(hw, false);
+// 			hw->hw_pause_issued = false;
+// 		}
+	}
+
+	if (!rpkt) {
+		if (sig_pending) {
+			return BC_STS_IO_USER_ABORT;
+		} else {
+			return BC_STS_TIMEOUT;
+		}
+	}
+
+	rpkt->dio_req->uinfo.comp_flags = rpkt->flags;
+
+	if (rpkt->flags & COMP_FLAG_PIB_VALID)
+	{
+		pib->ppb.picture_number = rpkt->pib.picture_number;
+		pib->ppb.width = rpkt->pib.width;
+		pib->ppb.height = rpkt->pib.height;
+		pib->ppb.chroma_format = rpkt->pib.chroma_format;
+		pib->ppb.pulldown = rpkt->pib.pulldown;
+		pib->ppb.flags = rpkt->pib.flags;
+		pib->ptsStcOffset = rpkt->pib.sess_num;
+		pib->ppb.aspect_ratio = rpkt->pib.aspect_ratio;
+		pib->ppb.colour_primaries = rpkt->pib.colour_primaries;
+		pib->ppb.picture_meta_payload = rpkt->pib.picture_meta_payload;
+		pib->resolution = rpkt->pib.frame_rate;
+	}
+
+	*ioreq = rpkt->dio_req;
+
+	crystalhd_hw_free_rx_pkt(hw, rpkt);
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_start_capture(struct crystalhd_hw *hw)
+{
+	crystalhd_rx_dma_pkt *rx_pkt;
+	BC_STATUS sts;
+	uint32_t i;
+
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	/* This is start of capture.. Post to both the lists.. */
+	for (i = 0; i < DMA_ENGINE_CNT; i++) {
+		rx_pkt = crystalhd_dioq_fetch(hw->rx_freeq);
+		if (!rx_pkt)
+			return BC_STS_NO_DATA;
+		sts = hw->pfnPostRxSideBuff(hw, rx_pkt);
+		if (BC_STS_SUCCESS != sts)
+			break;
+
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_stop_capture(struct crystalhd_hw *hw, bool unmap)
+{
+	void *temp = NULL;
+
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	hw->pfnStopRXDMAEngines(hw);
+
+	if(!unmap)
+		return BC_STS_SUCCESS;
+
+	// Clear up Active, Ready and Free lists one by one and release resources
+	do {
+		temp = crystalhd_dioq_fetch(hw->rx_actq);
+		if (temp)
+			crystalhd_rx_pkt_rel_call_back(hw, temp);
+	} while (temp);
+
+	do {
+		temp = crystalhd_dioq_fetch(hw->rx_rdyq);
+		if (temp)
+			crystalhd_rx_pkt_rel_call_back(hw, temp);
+	} while (temp);
+
+	do {
+		temp = crystalhd_dioq_fetch(hw->rx_freeq);
+		if (temp)
+			crystalhd_rx_pkt_rel_call_back(hw, temp);
+	} while (temp);
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_hw_suspend(struct crystalhd_hw *hw)
+{
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if (!hw->pfnStopDevice(hw)) {
+		dev_err(&hw->adp->pdev->dev, "Failed to Stop Device!!\n");
+		return BC_STS_ERROR;
+	}
+
+	return BC_STS_SUCCESS;
+}
+
+void crystalhd_hw_stats(struct crystalhd_hw *hw, struct crystalhd_hw_stats *stats)
+{
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return;
+	}
+
+	/* if called w/NULL stats, its a req to zero out the stats */
+	if (!stats) {
+		hw->DrvTotalFrmCaptured = 0;
+		memset(&hw->stats, 0, sizeof(hw->stats));
+		return;
+	}
+
+	hw->stats.freeq_count = crystalhd_dioq_count(hw->rx_freeq);
+	hw->stats.rdyq_count  = crystalhd_dioq_count(hw->rx_rdyq);
+	memcpy(stats, &hw->stats, sizeof(*stats));
+}
diff --git a/drivers/staging/chd/crystalhd_hw.h b/drivers/staging/chd/crystalhd_hw.h
new file mode 100644
index 0000000..e075782
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_hw.h
@@ -0,0 +1,552 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_hw . h
+ *
+ *  Description:
+ *		BCM70012 Linux driver hardware layer.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_HW_H_
+#define _CRYSTALHD_HW_H_
+#define DEBUG 1
+
+#include <linux/device.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 24)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+#include "crystalhd_fw_if.h"
+#include "crystalhd_misc.h"
+#include "DriverFwShare.h"
+#include "FleaDefs.h"
+
+/* HW constants..*/
+#define DMA_ENGINE_CNT		2
+#define MAX_PIB_Q_DEPTH		64
+#define MIN_PIB_Q_DEPTH		2
+#define WR_POINTER_OFF		4
+#define MAX_VALID_POLL_CNT	1000
+
+#define TX_WRAP_THRESHOLD 128 * 1024
+
+#define	NUMBER_OF_TRANSFERS_TX_SIDE				1
+#define NUMBER_OF_TRANSFERS_RX_SIDE				2
+
+typedef struct _BC_DRV_PIC_INFO_{
+	C011_PIB			DecoPIB;
+	struct _BC_DRV_PIC_INFO_	*Flink;
+} BC_DRV_PIC_INFO, *PBC_DRV_PIC_INFO;
+
+typedef union _desc_low_addr_reg_ {
+	struct {
+#ifdef	__LITTLE_ENDIAN_BITFIELD
+		uint32_t	list_valid:1;
+		uint32_t	reserved:4;
+		uint32_t	low_addr:27;
+#else
+		uint32_t	low_addr:27;
+		uint32_t	reserved:4;
+		uint32_t	list_valid:1;
+#endif
+	};
+
+	uint32_t	whole_reg;
+
+} desc_low_addr_reg;
+
+typedef struct _dma_descriptor_ {	/* 8 32-bit values */
+#ifdef	__LITTLE_ENDIAN_BITFIELD
+	/* 0th u32 */
+	uint32_t sdram_buff_addr:28;	/* bits 0-27:  SDRAM Address */
+	uint32_t res0:4;		/* bits 28-31: Reserved */
+
+	/* 1st u32 */
+	uint32_t buff_addr_low;		/* 1 buffer address low */
+	uint32_t buff_addr_high;	/* 2 buffer address high */
+
+	/* 3rd u32 */
+	uint32_t res2:2;		/* 0-1 - Reserved */
+	uint32_t xfer_size:23;		/* 2-24 = Xfer size in words */
+	uint32_t res3:6;		/* 25-30 reserved */
+	uint32_t intr_enable:1;		/* 31 - Interrupt After this desc */
+
+	/* 4th u32 */
+	uint32_t endian_xlat_align:2;	/* 0-1 Endian Translation */
+	uint32_t next_desc_cont:1;	/* 2 - Next desc is in contig memory */
+	uint32_t res4:25;		/* 3 - 27 Reserved bits */
+	uint32_t fill_bytes:2;		/* 28-29 Bits Fill Bytes */
+	uint32_t dma_dir:1;		/* 30 bit DMA Direction */
+	uint32_t last_rec_indicator:1;	/* 31 bit Last Record Indicator */
+
+	/* 5th u32 */
+	uint32_t next_desc_addr_low;	/* 32-bits Next Desc Addr lower */
+
+	/* 6th u32 */
+	uint32_t next_desc_addr_high;	/* 32-bits Next Desc Addr Higher */
+
+	/* 7th u32 */
+	uint32_t res8;			/* Last 32bits reserved */
+#else
+	/* 0th u32 */
+	uint32_t res0:4;		/* bits 28-31: Reserved */
+	uint32_t sdram_buff_addr:28;	/* bits 0-27:  SDRAM Address */
+
+	/* 1st u32 */
+	uint32_t buff_addr_low;		/* 1 buffer address low */
+	uint32_t buff_addr_high;	/* 2 buffer address high */
+
+	/* 3rd u32 */
+	uint32_t intr_enable:1;		/* 31 - Interrupt After this desc */
+	uint32_t res3:6;		/* 25-30 reserved */
+	uint32_t xfer_size:23;		/* 2-24 = Xfer size in words */
+	uint32_t res2:2;		/* 0-1 - Reserved */
+
+	/* 4th u32 */
+	uint32_t last_rec_indicator:1;	/* 31 bit Last Record Indicator */
+	uint32_t dma_dir:1;		/* 30 bit DMA Direction */
+	uint32_t fill_bytes:2;		/* 28-29 Bits Fill Bytes */
+	uint32_t res4:25;		/* 3 - 27 Reserved bits */
+	uint32_t next_desc_cont:1;	/* 2 - Next desc is in contig memory */
+	uint32_t endian_xlat_align:2;	/* 0-1 Endian Translation */
+
+	/* 5th u32 */
+	uint32_t next_desc_addr_low;	/* 32-bits Next Desc Addr lower */
+
+	/* 6th u32 */
+	uint32_t next_desc_addr_high;	/* 32-bits Next Desc Addr Higher */
+
+	/* 7th u32 */
+	uint32_t res8;			/* Last 32bits reserved */
+#endif
+} dma_descriptor, *pdma_descriptor;
+
+/*
+ * We will allocate the memory in 4K pages
+ * the linked list will be a list of 32 byte descriptors.
+ * The  virtual address will determine what should be freed.
+ */
+typedef struct _dma_desc_mem_ {
+	pdma_descriptor		pdma_desc_start;	/* 32-bytes for dma descriptor. should be first element */
+	dma_addr_t		phy_addr;		/* physical address of each DMA desc */
+	uint32_t		sz;
+	struct _dma_desc_mem_	*Next;			/* points to Next Descriptor in chain */
+
+} dma_desc_mem, *pdma_desc_mem;
+
+typedef enum _list_sts_ {
+	sts_free 		= 0,
+
+	/* RX-Y Bits 0:7 */
+	rx_waiting_y_intr	= 0x00000001,
+	rx_y_error		= 0x00000004,
+
+	/* RX-UV Bits 8:16 */
+	rx_waiting_uv_intr	= 0x0000100,
+	rx_uv_error		= 0x0000400,
+
+	rx_sts_waiting		= (rx_waiting_y_intr|rx_waiting_uv_intr),
+	rx_sts_error		= (rx_y_error|rx_uv_error),
+
+	rx_y_mask		= 0x000000FF,
+	rx_uv_mask		= 0x0000FF00,
+
+} list_sts;
+
+
+typedef enum _INTERRUPT_STATUS_
+{
+	NO_INTERRUPT					= 0x0000,
+	FPGA_RX_L0_DMA_DONE				= 0x0001, /*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	FPGA_RX_L1_DMA_DONE				= 0x0002, /*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	FPGA_TX_L0_DMA_DONE				= 0x0004, /*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	FPGA_TX_L1_DMA_DONE				= 0x0008, /*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	DECO_PIB_INTR					= 0x0010, /*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	DECO_FMT_CHANGE					= 0x0020,
+	DECO_MBOX_RESP					= 0x0040,
+	DECO_RESUME_FRM_INTER_PAUSE		= 0x0080, /*Not Handled in DPC Need to Fire Rx cmds on resume from Pause*/
+}INTERRUPT_STATUS;
+
+typedef enum _ERR_STATUS_
+{
+	NO_ERROR			=0,
+	RX_Y_DMA_ERR_L0		=0x0001,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	RX_UV_DMA_ERR_L0	=0x0002,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	RX_Y_DMA_ERR_L1		=0x0004,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	RX_UV_DMA_ERR_L1	=0x0008,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	TX_DMA_ERR_L0		=0x0010,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	TX_DMA_ERR_L1		=0x0020,/*DONT CHANGE VALUES...SOME BITWIZE OPERATIONS WILL FAIL*/
+	FW_CMD_ERROR		=0x0040,
+	DROP_REPEATED		=0x0080,
+	DROP_FLEA_FMTCH		=0x0100,/*We do not want to deliver the flea dummy frame*/
+	DROP_DATA_ERROR		=0x0200,//We were not able to get the PIB correctly so drop the frame.
+	DROP_SIZE_ERROR		=0x0400,//We were not able to get the size properly from hardware.
+	FORCE_CANCEL		=0x8000
+}ERROR_STATUS;
+
+typedef enum _LIST_STATUS_
+{
+	ListStsFree=0,				// Initial state and state the buffer is moved to Ready Buffer list.
+	RxListWaitingForYIntr=1,	// When the Y Descriptor is posted.
+	RxListWaitingForUVIntr=2,	// When the UV descriptor is posted.
+	TxListWaitingForIntr =4,
+}LIST_STATUS;
+
+typedef struct _RX_LIST_{
+	LIST_STATUS		ListSts;
+	//LIST_ENTRY		ActiveList;
+	uint32_t			ActiveListLen;
+	uint32_t			ListLockInd;					/* To Be Filled up During Init */
+	uint32_t			ulDiscCount;					/* Discontinuity On this list */
+	uint32_t			RxYFirstDescLADDRReg;			/* First Desc Low Addr Y	*/
+	uint32_t			RxYFirstDescUADDRReg;			/* First Desc UPPER Addr Y	*/
+	uint32_t			RxYCurDescLADDRReg;				/* Current Desc Low Addr Y	*/
+	uint32_t			RxYCurDescUADDRReg;				/* First Desc Low Addr Y	*/
+	uint32_t			RxYCurByteCntRemReg;			/* Cur Byte Cnt Rem Y		*/
+
+	uint32_t			RxUVFirstDescLADDRReg;			/* First Desc Low Addr UV		*/
+	uint32_t			RxUVFirstDescUADDRReg;			/* First Desc UPPER Addr UV		*/
+	uint32_t			RxUVCurDescLADDRReg;			/* Current Desc Low Addr UV		*/
+	uint32_t			RxUVCurDescUADDRReg;			/* Current Desc UPPER Addr UV	*/
+	uint32_t			RxUVCurByteCntRemReg;			/* Cur Byte Cnt Rem UV			*/
+}RX_DMA_LIST,*PRX_DMA_LIST;
+
+typedef struct _tx_dma_pkt_ {
+	dma_desc_mem		desc_mem;
+	hw_comp_callback	call_back;
+	crystalhd_dio_req	*dio_req;
+	wait_queue_head_t	*cb_event;
+	uint32_t		list_tag;
+
+} tx_dma_pkt;
+
+typedef struct _crystalhd_rx_dma_pkt {
+	dma_desc_mem			desc_mem;
+	crystalhd_dio_req		*dio_req;
+	uint32_t			pkt_tag;
+	uint32_t			flags;
+	BC_PIC_INFO_BLOCK		pib;
+	dma_addr_t			uv_phy_addr;
+	struct  _crystalhd_rx_dma_pkt	*next;
+
+} crystalhd_rx_dma_pkt;
+
+struct crystalhd_hw_stats{
+	uint32_t	rx_errors;
+	uint32_t	tx_errors;
+	uint32_t	freeq_count;
+	uint32_t	rdyq_count;
+	uint32_t	num_interrupts;
+	uint32_t	dev_interrupts;
+	uint32_t	cin_busy;
+	uint32_t	pause_cnt;
+	uint32_t	rx_success;
+};
+
+typedef enum _DECODER_STATE_
+{
+	DECO_OPERATIONAL				= 0,			/* We start with this state.ST_FW_DWNLD,ST_CAPTURE,STOP_CAPTURE */
+	DECO_INTER_PAUSED				= 1,			/* Driver Issued Pause To Decoder */
+	DECO_INTER_PAUSE_IN_PROGRESS	= 2,			/* Pause CMD is pending with F/W  */
+	DECO_INTER_RESUME_IN_PROGRESS	= 3,			/* Resume CMD is pending with F/W */
+	DECO_STOPPED_BY_APP				= 4				/* After STOP Video I do not want to Throttle Decoder.So Special State */
+}DECO_STATE;
+
+//
+// These events can be used to notify the hardware layer
+// to set up it adapter in proper state...or for anyother
+// purpose for that matter.
+// We will use this for intermediae events as defined below
+
+typedef enum _BRCM_EVENT_{
+	BC_EVENT_ADAPTER_INIT_FAILED	=0,
+	BC_EVENT_ADAPTER_INIT_SUCCESS	=1,
+	BC_EVENT_FW_DNLD_STARTED		=2,
+	BC_EVENT_FW_DNLD_ERR			=3,
+	BC_EVENT_FW_DNLD_DONE			=4,
+	BC_EVENT_SYS_SHUT_DOWN			=5,
+	BC_EVENT_START_CAPTURE			=6,
+	BC_EVENT_START_CAPTURE_IMMI		=7,
+	BC_EVENT_STOP_CAPTURE			=8,		/* Stop Capturing the Rx buffers Stop the DMA engines UnMapBuffers Discard Free and Ready list */
+	BC_EVENT_DO_CLEANUP				=9,		/* Total Cleanup Rx And Tx side */
+	BC_DISCARD_RX_BUFFERS			=10		/* Move all the Ready buffers to free list. Stop RX DMA. Post Rx Side buffers. */
+}BRCM_EVENT,*PBRCM_EVENT;
+
+struct crystalhd_hw; // forward declaration for the types
+
+//typedef void*		(*HW_VERIFY_DEVICE)(struct crystalhd_adp*);
+//typedef bool		(*HW_INIT_DEVICE_RESOURCES)(struct crystalhd_adp*);
+//typedef bool		(*HW_CLEAN_DEVICE_RESOURCES)(struct crystalhd_adp*);
+typedef bool		(*HW_START_DEVICE)(struct crystalhd_hw*);
+typedef bool		(*HW_STOP_DEVICE)(struct crystalhd_hw*);
+/* typedef bool	(*HW_XLAT_AND_FIRE_SGL)(struct crystalhd_adp*,PVOID,PSCATTER_GATHER_LIST,uint32_t); */
+/* typedef bool	(*HW_RX_XLAT_SGL)(struct crystalhd_adp*,crystalhd_dio_req *ioreq); */
+typedef bool		(*HW_FIND_AND_CLEAR_INTR)(struct crystalhd_adp*,struct crystalhd_hw*);
+typedef uint32_t	(*HW_READ_DEVICE_REG)(struct crystalhd_adp*,uint32_t);
+typedef void		(*HW_WRITE_DEVICE_REG)(struct crystalhd_adp*,uint32_t,uint32_t);
+typedef uint32_t	(*HW_READ_FPGA_REG)(struct crystalhd_adp*,uint32_t);
+typedef void		(*HW_WRITE_FPGA_REG)(struct crystalhd_adp*,uint32_t,uint32_t);
+typedef BC_STATUS	(*HW_READ_DEV_MEM)(struct crystalhd_hw*,uint32_t,uint32_t,uint32_t*);
+typedef BC_STATUS	(*HW_WRITE_DEV_MEM)(struct crystalhd_hw*,uint32_t,uint32_t,uint32_t*);
+/* typedef bool		(*HW_INIT_DRAM)(struct crystalhd_adp*); */
+/* typedef bool		(*HW_DISABLE_INTR)(struct crystalhd_adp*); */
+/* typedef bool		(*HW_ENABLE_INTR)(struct crystalhd_adp*); */
+typedef BC_STATUS	(*HW_POST_RX_SIDE_BUFF)(struct crystalhd_hw*,crystalhd_rx_dma_pkt*);
+typedef bool		(*HW_CHECK_INPUT_FIFO)(struct crystalhd_hw*, uint32_t, uint32_t*,bool,uint8_t*);
+typedef void		(*HW_START_TX_DMA)(struct crystalhd_hw*, uint8_t, addr_64);
+typedef BC_STATUS	(*HW_STOP_TX_DMA)(struct crystalhd_hw*);
+/* typedef bool		(*HW_EVENT_NOTIFICATION)(struct crystalhd_adp*,BRCM_EVENT); */
+/* typedef bool		(*HW_RX_POST_INTR_PROCESSING)(struct crystalhd_adp*,uint32_t,uint32_t); */
+typedef void		(*HW_GET_DONE_SIZE)(struct crystalhd_hw *hw, uint32_t, uint32_t*, uint32_t*);
+/* typedef bool		(*HW_ADD_DRP_TO_FREE_LIST)(struct crystalhd_adp*,crystalhd_dio_req *ioreq); */
+typedef crystalhd_dio_req*	(*HW_FETCH_DONE_BUFFERS)(struct crystalhd_adp*,bool);
+/* typedef bool		(*HW_ADD_ROLLBACK_RXBUF)(struct crystalhd_adp*,crystalhd_dio_req *ioreq); */
+typedef bool		(*HW_PEEK_NEXT_DECODED_RXBUF)(struct crystalhd_hw*,uint64_t*,uint32_t*,uint32_t);
+typedef BC_STATUS	(*HW_FW_PASSTHRU_CMD)(struct crystalhd_hw*,PBC_FW_CMD);
+/* typedef bool		(*HW_CANCEL_FW_CMDS)(struct crystalhd_adp*,OS_CANCEL_CALLBACK); */
+/* typedef void*	(*HW_GET_FW_DONE_OS_CMD)(struct crystalhd_adp*); */
+/* typedef PBC_DRV_PIC_INFO	(*SEARCH_FOR_PIB)(struct crystalhd_adp*,bool,uint32_t); */
+/* typedef bool		(*HW_DO_DRAM_PWR_MGMT)(struct crystalhd_adp*); */
+typedef BC_STATUS	(*HW_FW_DOWNLOAD)(struct crystalhd_hw*,uint8_t*,uint32_t);
+typedef BC_STATUS	(*HW_ISSUE_DECO_PAUSE)(struct crystalhd_hw*, bool);
+typedef void		(*HW_STOP_DMA_ENGINES)(struct crystalhd_hw*);
+/*
+typedef BOOLEAN		(*FIRE_RX_REQ_TO_HW)	(PHW_EXTENSION,PRX_DMA_LIST);
+typedef BOOLEAN		(*PIC_POST_PROC)	(PHW_EXTENSION,PRX_DMA_LIST,PULONG);
+typedef BOOLEAN		(*HW_ISSUE_DECO_PAUSE)	(PHW_EXTENSION,BOOLEAN,BOOLEAN);
+typedef BOOLEAN		(*FIRE_TX_CMD_TO_HW)	(PCONTEXT_FOR_POST_TX);
+*/
+typedef void		(*NOTIFY_FLL_CHANGE)(struct crystalhd_hw*,bool);
+typedef bool		(*HW_EVENT_NOTIFICATION)(struct crystalhd_hw*, BRCM_EVENT);
+
+struct crystalhd_hw {
+	tx_dma_pkt		tx_pkt_pool[DMA_ENGINE_CNT];
+	spinlock_t		lock;
+
+	uint32_t		tx_ioq_tag_seed;
+	uint32_t		tx_list_post_index;
+
+	crystalhd_rx_dma_pkt	*rx_pkt_pool_head;
+	uint32_t		rx_pkt_tag_seed;
+
+	bool			dev_started;
+	struct crystalhd_adp	*adp;
+
+	wait_queue_head_t	*pfw_cmd_event;
+	int			fwcmd_evt_sts;
+
+	uint32_t		pib_del_Q_addr;
+	uint32_t		pib_rel_Q_addr;
+	uint32_t		channelNum;
+
+	crystalhd_dioq_t	*tx_freeq;
+	crystalhd_dioq_t	*tx_actq;
+
+	/* Rx DMA Engine Specific Locks */
+	spinlock_t		rx_lock;
+	uint32_t		rx_list_post_index;
+	list_sts		rx_list_sts[DMA_ENGINE_CNT];
+	crystalhd_dioq_t	*rx_rdyq;
+	crystalhd_dioq_t	*rx_freeq;
+	crystalhd_dioq_t	*rx_actq;
+	uint32_t		stop_pending;
+
+	uint32_t		hw_pause_issued;
+
+	uint32_t		fwcmdPostAddr;
+	uint32_t		fwcmdPostMbox;
+	uint32_t		fwcmdRespMbox;
+
+	/* HW counters.. */
+	struct crystalhd_hw_stats	stats;
+
+	/* Picture Information Block Management Variables */
+	uint32_t	PICWidth;	/* Pic Width Recieved On Format Change for link/With WidthField On Flea*/
+	uint32_t	PICHeight;	/* Pic Height Recieved on format change[Link and Flea]/Not Used in Flea*/
+	uint32_t	LastPicNo;	/* For Repeated Frame Detection */
+	uint32_t	LastTwoPicNo;	/* For Repeated Frame Detection on Interlace clip*/
+	uint32_t	LastSessNum;	/* For Session Change Detection */
+
+	struct semaphore fetch_sem; // semaphore between fetch and probe of the next picture information, since both will be in process context
+
+	uint32_t	RxCaptureState; // 0 if capture is not enabled, 1 if capture is enabled, 2 if stop rxdma is pending
+
+	// BCM70015 mods
+	uint32_t	PicQSts;		/* This is the bitmap given by PiCQSts Interrupt*/
+	uint32_t	TxBuffInfoAddr;		/* Address of the TX Fifo in DRAM*/
+	uint32_t	FleaRxPicDelAddr;	/* Memory address where the pictures are fired*/
+	uint32_t	FleaFLLUpdateAddr;	/* Memory Address where FLL is updated*/
+	uint32_t	FleaBmpIntrCnt;
+	uint32_t	RxSeqNum;
+	uint32_t	DrvEosDetected;
+	uint32_t	DrvCancelEosFlag;
+
+	uint32_t	SkipDropBadFrames;
+	uint32_t	TemperatureRegVal;
+	TX_INPUT_BUFFER_INFO	TxFwInputBuffInfo;
+
+	DECO_STATE			DecoderSt;				/* Weather the decoder is paused or not*/
+	uint32_t			PauseThreshold;
+	uint32_t			ResumeThreshold;
+
+	uint32_t				RxListPointer;					/* Treat the Rx List As Circular List */
+	LIST_STATUS				TxList0Sts;
+	LIST_STATUS				TxList1Sts;
+
+	uint32_t			FleaEnablePWM;
+	uint32_t			FleaWaitFirstPlaybackNotify;
+	FLEA_POWER_STATES	FleaPowerState;
+	uint32_t			EmptyCnt;
+	bool				SingleThreadAppFIFOEmpty;
+	bool				PwrDwnTxIntr; /* Got an TX FIFO status interrupt when in power down state */
+	bool				PwrDwnPiQIntr; /* Got a Picture Q interrupt when in power down state */
+	uint32_t			OLWatchDogTimer;
+	uint32_t			ILWatchDogTimer;
+	uint32_t			FwCmdCnt;
+	bool				WakeUpDecodeDone; /* Used to indicate that the HW is awake to RX is running so we can actively manage power */
+
+	uint64_t			TickCntDecodePU; /* Time when we first powered up to decode */
+	uint64_t			TickSpentInPD; /* Total amount of time spent in PD */
+	uint64_t			TickStartInPD; /* Tick count when we start in PD */
+	uint32_t			PDRatio; /* % of time spent in power down. Goal is to keep this close to 50 */
+	uint32_t			DefaultPauseThreshold; /* default threshold to set when we start power management */
+
+//	uint32_t			FreeListLen;
+//	uint32_t			ReadyListLen;
+
+//
+//	Counters needed for monitoring purposes.
+//	These counters are per session and will be reset to zero in
+//  start capture.
+//
+	uint32_t					DrvPauseCnt;					 /* Number of Times the driver has issued pause.*/
+	//uint32_t					DrvServiceIntrCnt;				 /* Number of interrutps the driver serviced. */
+	//uint32_t					DrvIgnIntrCnt;					 /* Number of Interrupts Driver Ignored.NOT OUR INTR. */
+	//uint32_t					DrvTotalFrmDropped;				 /* Number of frames dropped by the driver.*/
+	uint32_t					DrvTotalFrmCaptured;			 /* Numner of Good Frames Captured*/
+	//uint32_t					DrvTotalHWErrs;					 /* Total HW Errors.*/
+	//uint32_t					DrvTotalPIBFlushCnt;			 /* Number of Times the driver flushed PIB Queues.*/
+	//uint32_t					DrvMissedPIBCnt;				 /* Number of Frames for which the PIB was not found.*/
+	//uint64_t					TickCntOnPause;
+	//uint32_t					TotalTimeInPause;				/* In Milliseconds */
+	//uint32_t					RepeatedFramesCnt;
+//
+
+//	HW_VERIFY_DEVICE			pfnVerifyDevice;
+//	HW_INIT_DEVICE_RESOURCES		pfnInitDevResources;
+//	HW_CLEAN_DEVICE_RESOURCES		pfnCleanDevResources;
+	HW_START_DEVICE				pfnStartDevice;
+	HW_STOP_DEVICE				pfnStopDevice;
+//	HW_XLAT_AND_FIRE_SGL			pfnTxXlatAndFireSGL;
+//	HW_RX_XLAT_SGL				pfnRxXlatSgl;
+	HW_FIND_AND_CLEAR_INTR		pfnFindAndClearIntr;
+	HW_READ_DEVICE_REG			pfnReadDevRegister;
+	HW_WRITE_DEVICE_REG			pfnWriteDevRegister;
+	HW_READ_FPGA_REG			pfnReadFPGARegister;
+	HW_WRITE_FPGA_REG			pfnWriteFPGARegister;
+	HW_READ_DEV_MEM				pfnDevDRAMRead;
+	HW_WRITE_DEV_MEM			pfnDevDRAMWrite;
+//	HW_INIT_DRAM				pfnInitDRAM;
+//	HW_DISABLE_INTR				pfnDisableIntr;
+//	HW_ENABLE_INTR				pfnEnableIntr;
+	HW_POST_RX_SIDE_BUFF			pfnPostRxSideBuff;
+	HW_CHECK_INPUT_FIFO			pfnCheckInputFIFO;
+	HW_START_TX_DMA				pfnStartTxDMA;
+	HW_STOP_TX_DMA				pfnStopTxDMA;
+	HW_GET_DONE_SIZE			pfnHWGetDoneSize;
+//	HW_EVENT_NOTIFICATION			pfnNotifyHardware;
+//	HW_ADD_DRP_TO_FREE_LIST			pfnAddRxDRPToFreeList;
+//	HW_FETCH_DONE_BUFFERS			pfnFetchReadyRxDRP;
+//	HW_ADD_ROLLBACK_RXBUF			pfnRollBackRxBuf;
+	HW_PEEK_NEXT_DECODED_RXBUF		pfnPeekNextDeodedFr;
+	HW_FW_PASSTHRU_CMD			pfnDoFirmwareCmd;
+//	HW_GET_FW_DONE_OS_CMD			pfnGetFWDoneCmdOsCntxt;
+//	HW_CANCEL_FW_CMDS			pfnCancelFWCmds;
+//	SEARCH_FOR_PIB				pfnSearchPIB;
+//	HW_DO_DRAM_PWR_MGMT			pfnDRAMPwrMgmt;
+	HW_FW_DOWNLOAD				pfnFWDwnld;
+	HW_ISSUE_DECO_PAUSE			pfnIssuePause;
+	HW_STOP_DMA_ENGINES			pfnStopRXDMAEngines;
+//	FIRE_RX_REQ_TO_HW			pfnFireRx;
+//	PIC_POST_PROC				pfnPostProcessPicture;
+//	FIRE_TX_CMD_TO_HW			pfnFireTx;
+	NOTIFY_FLL_CHANGE			pfnNotifyFLLChange;
+	HW_EVENT_NOTIFICATION		pfnNotifyHardware;
+};
+
+crystalhd_rx_dma_pkt *crystalhd_hw_alloc_rx_pkt(struct crystalhd_hw *hw);
+void crystalhd_hw_free_rx_pkt(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt *pkt);
+void crystalhd_tx_desc_rel_call_back(void *context, void *data);
+void crystalhd_rx_pkt_rel_call_back(void *context, void *data);
+void crystalhd_hw_delete_ioqs(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_hw_create_ioqs(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_hw_open(struct crystalhd_hw *hw, struct crystalhd_adp *adp);
+BC_STATUS crystalhd_hw_close(struct crystalhd_hw *hw, struct crystalhd_adp *adp);
+BC_STATUS crystalhd_hw_setup_dma_rings(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_hw_free_dma_rings(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_hw_tx_req_complete(struct crystalhd_hw *hw, uint32_t list_id, BC_STATUS cs);
+BC_STATUS crystalhd_hw_fill_desc(crystalhd_dio_req *ioreq,
+				dma_descriptor *desc,
+				dma_addr_t desc_paddr_base,
+				uint32_t sg_cnt, uint32_t sg_st_ix,
+				uint32_t sg_st_off, uint32_t xfr_sz,
+				struct device *dev, uint32_t destDRAMaddr);
+BC_STATUS crystalhd_xlat_sgl_to_dma_desc(crystalhd_dio_req *ioreq,
+					pdma_desc_mem pdesc_mem,
+					uint32_t *uv_desc_index,
+					struct device *dev, uint32_t destDRAMaddr);
+BC_STATUS crystalhd_rx_pkt_done(struct crystalhd_hw *hw,
+				uint32_t list_index,
+				BC_STATUS comp_sts);
+BC_STATUS crystalhd_hw_post_tx(struct crystalhd_hw *hw, crystalhd_dio_req *ioreq,
+				hw_comp_callback call_back,
+				wait_queue_head_t *cb_event, uint32_t *list_id,
+				uint8_t data_flags);
+BC_STATUS crystalhd_hw_cancel_tx(struct crystalhd_hw *hw, uint32_t list_id);
+BC_STATUS crystalhd_hw_add_cap_buffer(struct crystalhd_hw *hw,crystalhd_dio_req *ioreq, bool en_post);
+BC_STATUS crystalhd_hw_get_cap_buffer(struct crystalhd_hw *hw,C011_PIB *pib,crystalhd_dio_req **ioreq);
+BC_STATUS crystalhd_hw_start_capture(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_hw_stop_capture(struct crystalhd_hw *hw, bool unmap);
+BC_STATUS crystalhd_hw_suspend(struct crystalhd_hw *hw);
+void crystalhd_hw_stats(struct crystalhd_hw *hw, struct crystalhd_hw_stats *stats);
+
+#define GET_Y0_ERR_MSK (MISC1_Y_RX_ERROR_STATUS_RX_L0_OVERRUN_ERROR_MASK |		\
+						MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK |		\
+						MISC1_Y_RX_ERROR_STATUS_RX_L0_DESC_TX_ABORT_ERRORS_MASK |	\
+						MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK)
+
+#define GET_UV0_ERR_MSK (MISC1_UV_RX_ERROR_STATUS_RX_L0_OVERRUN_ERROR_MASK |		\
+						MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK |		\
+						MISC1_UV_RX_ERROR_STATUS_RX_L0_DESC_TX_ABORT_ERRORS_MASK |	\
+						MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK)
+
+#define GET_Y1_ERR_MSK (MISC1_Y_RX_ERROR_STATUS_RX_L1_OVERRUN_ERROR_MASK |		\
+						MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK |		\
+						MISC1_Y_RX_ERROR_STATUS_RX_L1_DESC_TX_ABORT_ERRORS_MASK |	\
+						MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK)
+
+#define GET_UV1_ERR_MSK	(MISC1_UV_RX_ERROR_STATUS_RX_L1_OVERRUN_ERROR_MASK |		\
+						MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK |		\
+						MISC1_UV_RX_ERROR_STATUS_RX_L1_DESC_TX_ABORT_ERRORS_MASK |	\
+						MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK)
+
+#endif
diff --git a/drivers/staging/chd/crystalhd_linkfuncs.c b/drivers/staging/chd/crystalhd_linkfuncs.c
new file mode 100644
index 0000000..1385f96
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_linkfuncs.c
@@ -0,0 +1,2056 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_hw . c
+ *
+ *  Description:
+ *		BCM70010 Linux driver HW layer.
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/tsc.h>
+#include "crystalhd_hw.h"
+#include "crystalhd_lnx.h"
+#include "crystalhd_linkfuncs.h"
+#include "bc_defines.h"
+
+#define OFFSETOF(_s_, _m_) ((size_t)(unsigned long)&(((_s_ *)0)->_m_))
+
+/**
+* link_dec_reg_rd - Read 70010's device register.
+* @adp: Adapter instance
+* @reg_off: Register offset.
+*
+* Return:
+*	32bit value read
+*
+* 70010's device register read routine. This interface use
+* 70010's device access range mapped from BAR-2 (4M) of PCIe
+* configuration space.
+*/
+uint32_t link_dec_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off)
+{
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return 0;
+	}
+
+	if (reg_off > adp->pci_mem_len) {
+		dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+			__func__, reg_off);
+		return 0;
+	}
+
+	return readl(adp->mem_addr + reg_off);
+}
+
+/**
+* link_dec_reg_wr - Write 70010's device register
+* @adp: Adapter instance
+* @reg_off: Register offset.
+* @val: Dword value to be written.
+*
+* Return:
+*	none.
+*
+* 70010's device register write routine. This interface use
+* 70010's device access range mapped from BAR-2 (4M) of PCIe
+* configuration space.
+*/
+void link_dec_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val)
+{
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return;
+	}
+
+	if (reg_off > adp->pci_mem_len) {
+		dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+			__func__, reg_off);
+		return;
+	}
+
+	writel(val, adp->mem_addr + reg_off);
+
+	/* the udelay is required for latest 70012, not for others... :( */
+	udelay(8);
+}
+
+/**
+* crystalhd_reg_rd - Read 70012's device register.
+* @adp: Adapter instance
+* @reg_off: Register offset.
+*
+* Return:
+*	32bit value read
+*
+* 70012 device register  read routine. This interface use
+* 70012's device access range mapped from BAR-1 (64K) of PCIe
+* configuration space.
+*
+*/
+uint32_t crystalhd_link_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off)
+{
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return 0;
+	}
+
+	if (reg_off > adp->pci_i2o_len) {
+		dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+			__func__, reg_off);
+		return 0;
+	}
+
+	return readl(adp->i2o_addr + reg_off);
+}
+
+/**
+* crystalhd_reg_wr - Write 70012's device register
+* @adp: Adapter instance
+* @reg_off: Register offset.
+* @val: Dword value to be written.
+*
+* Return:
+*	none.
+*
+* 70012 device register  write routine. This interface use
+* 70012's device access range mapped from BAR-1 (64K) of PCIe
+* configuration space.
+*
+*/
+void crystalhd_link_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val)
+{
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return;
+	}
+
+	if (reg_off > adp->pci_i2o_len) {
+		dev_err(&adp->pdev->dev, "%s: reg_off out of range: 0x%08x\n",
+				__func__, reg_off);
+				return;
+	}
+
+	writel(val, adp->i2o_addr + reg_off);
+}
+
+inline uint32_t crystalhd_link_dram_rd(struct crystalhd_hw *hw, uint32_t mem_off)
+{
+	hw->pfnWriteFPGARegister(hw->adp,  DCI_DRAM_BASE_ADDR, (mem_off >> 19));
+	return hw->pfnReadDevRegister(hw->adp,  (0x00380000 | (mem_off & 0x0007FFFF)));
+}
+
+inline void crystalhd_link_dram_wr(struct crystalhd_hw *hw, uint32_t mem_off, uint32_t val)
+{
+	hw->pfnWriteFPGARegister(hw->adp, DCI_DRAM_BASE_ADDR, (mem_off >> 19));
+	hw->pfnWriteDevRegister(hw->adp, (0x00380000 | (mem_off & 0x0007FFFF)), val);
+}
+
+/**
+* crystalhd_link_mem_rd - Read data from DRAM area.
+* @adp: Adapter instance
+* @start_off: Start offset.
+* @dw_cnt: Count in dwords.
+* @rd_buff: Buffer to copy the data from dram.
+*
+* Return:
+*	Status.
+*
+* Dram read routine.
+*/
+BC_STATUS crystalhd_link_mem_rd(struct crystalhd_hw *hw, uint32_t start_off,
+								uint32_t dw_cnt, uint32_t *rd_buff)
+{
+	uint32_t ix = 0;
+
+	if (!hw || !rd_buff) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+	for (ix = 0; ix < dw_cnt; ix++)
+		rd_buff[ix] = crystalhd_link_dram_rd(hw, (start_off + (ix * 4)));
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+* crystalhd_link_mem_wr - Write data to DRAM area.
+* @adp: Adapter instance
+* @start_off: Start offset.
+* @dw_cnt: Count in dwords.
+* @wr_buff: Data Buffer to be written.
+*
+* Return:
+*	Status.
+*
+* Dram write routine.
+*/
+BC_STATUS crystalhd_link_mem_wr(struct crystalhd_hw *hw, uint32_t start_off,
+						uint32_t dw_cnt, uint32_t *wr_buff)
+{
+	uint32_t ix = 0;
+
+	if (!hw || !wr_buff) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	for (ix = 0; ix < dw_cnt; ix++)
+		crystalhd_link_dram_wr(hw, (start_off + (ix * 4)), wr_buff[ix]);
+
+	return BC_STS_SUCCESS;
+}
+
+void crystalhd_link_enable_uarts(struct crystalhd_hw *hw)
+{
+	hw->pfnWriteDevRegister(hw->adp, UartSelectA, BSVS_UART_STREAM);
+	hw->pfnWriteDevRegister(hw->adp, UartSelectB, BSVS_UART_DEC_OUTER);
+}
+
+void crystalhd_link_start_dram(struct crystalhd_hw *hw)
+{
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_PARAM, ((40 / 5 - 1) <<  0) |
+	/* tras (40ns tras)/(5ns period) -1 ((15/5 - 1) <<  4) | // trcd */
+		      ((15 / 5 - 1) <<  7) |	/* trp */
+		      ((10 / 5 - 1) << 10) |	/* trrd */
+		      ((15 / 5 + 1) << 12) |	/* twr */
+		      ((2 + 1) << 16) |		/* twtr */
+		      ((70 / 5 - 2) << 19) |	/* trfc */
+		      (0 << 23));
+
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_PRECHARGE, 0);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_EXT_MODE, 2);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_MODE, 0x132);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_PRECHARGE, 0);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_REFRESH, 0);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_REFRESH, 0);
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_MODE, 0x32);
+	/* setting the refresh rate here */
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_REF_PARAM, ((1 << 12) | 96));
+}
+
+
+bool crystalhd_link_bring_out_of_rst(struct crystalhd_hw *hw)
+{
+	link_misc_perst_deco_ctrl rst_deco_cntrl;
+	link_misc_perst_clk_ctrl rst_clk_cntrl;
+	uint32_t temp;
+
+	/*
+	 * Link clocks: MISC_PERST_CLOCK_CTRL Clear PLL power down bit,
+	 * delay to allow PLL to lock Clear alternate clock, stop clock bits
+	 */
+	rst_clk_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL);
+	rst_clk_cntrl.pll_pwr_dn = 0;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	rst_clk_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL);
+	rst_clk_cntrl.stop_core_clk = 0;
+	rst_clk_cntrl.sel_alt_clk = 0;
+
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	/*
+	 * Bus Arbiter Timeout: GISB_ARBITER_TIMER
+	 * Set internal bus arbiter timeout to 40us based on core clock speed
+	 * (63MHz * 40us = 0x9D8)
+	 */
+	hw->pfnWriteFPGARegister(hw->adp, GISB_ARBITER_TIMER, 0x9D8);
+
+	/*
+	 * Decoder clocks: MISC_PERST_DECODER_CTRL
+	 * Enable clocks while 7412 reset is asserted, delay
+	 * De-assert 7412 reset
+	 */
+	rst_deco_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL);
+	rst_deco_cntrl.stop_bcm_7412_clk = 0;
+	rst_deco_cntrl.bcm7412_rst = 1;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	rst_deco_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL);
+	rst_deco_cntrl.bcm7412_rst = 0;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	/* Disable OTP_CONTENT_MISC to 0 to disable all secure modes */
+	hw->pfnWriteFPGARegister(hw->adp, OTP_CONTENT_MISC, 0);
+
+	/* Clear bit 29 of 0x404 */
+	temp = hw->pfnReadFPGARegister(hw->adp, PCIE_TL_TRANSACTION_CONFIGURATION);
+	temp &= ~BC_BIT(29);
+	hw->pfnWriteFPGARegister(hw->adp, PCIE_TL_TRANSACTION_CONFIGURATION, temp);
+
+	/* 2.5V regulator must be set to 2.6 volts (+6%) */
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_VREG_CTRL, 0xF3);
+
+	return true;
+}
+
+bool crystalhd_link_put_in_reset(struct crystalhd_hw *hw)
+{
+	link_misc_perst_deco_ctrl rst_deco_cntrl;
+	link_misc_perst_clk_ctrl  rst_clk_cntrl;
+	uint32_t                  temp;
+
+	/*
+	 * Decoder clocks: MISC_PERST_DECODER_CTRL
+	 * Assert 7412 reset, delay
+	 * Assert 7412 stop clock
+	 */
+	rst_deco_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL);
+	rst_deco_cntrl.stop_bcm_7412_clk = 1;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_DECODER_CTRL, rst_deco_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	/* Bus Arbiter Timeout: GISB_ARBITER_TIMER
+	 * Set internal bus arbiter timeout to 40us based on core clock speed
+	 * (6.75MHZ * 40us = 0x10E)
+	 */
+	hw->pfnWriteFPGARegister(hw->adp, GISB_ARBITER_TIMER, 0x10E);
+
+	/* Link clocks: MISC_PERST_CLOCK_CTRL
+	 * Stop core clk, delay
+	 * Set alternate clk, delay, set PLL power down
+	 */
+	rst_clk_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL);
+	rst_clk_cntrl.stop_core_clk = 1;
+	rst_clk_cntrl.sel_alt_clk = 1;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);
+	msleep_interruptible(50);
+
+	rst_clk_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL);
+	rst_clk_cntrl.pll_pwr_dn = 1;
+	hw->pfnWriteFPGARegister(hw->adp, MISC_PERST_CLOCK_CTRL, rst_clk_cntrl.whole_reg);
+
+	/*
+	 * Read and restore the Transaction Configuration Register
+	 * after core reset
+	 */
+	temp = hw->pfnReadFPGARegister(hw->adp, PCIE_TL_TRANSACTION_CONFIGURATION);
+
+	/*
+	 * Link core soft reset: MISC3_RESET_CTRL
+	 * - Write BIT[0]=1 and read it back for core reset to take place
+	 */
+	hw->pfnWriteFPGARegister(hw->adp, MISC3_RESET_CTRL, 1);
+	rst_deco_cntrl.whole_reg = hw->pfnReadFPGARegister(hw->adp, MISC3_RESET_CTRL);
+	msleep_interruptible(50);
+
+	/* restore the transaction configuration register */
+	hw->pfnWriteFPGARegister(hw->adp, PCIE_TL_TRANSACTION_CONFIGURATION, temp);
+
+	return true;
+}
+
+void crystalhd_link_disable_interrupts(struct crystalhd_hw *hw)
+{
+	intr_mask_reg   intr_mask;
+	intr_mask.whole_reg = hw->pfnReadFPGARegister(hw->adp, INTR_INTR_MSK_STS_REG);
+	intr_mask.mask_pcie_err = 1;
+	intr_mask.mask_pcie_rbusmast_err = 1;
+	intr_mask.mask_pcie_rgr_bridge   = 1;
+	intr_mask.mask_rx_done = 1;
+	intr_mask.mask_rx_err  = 1;
+	intr_mask.mask_tx_done = 1;
+	intr_mask.mask_tx_err  = 1;
+	hw->pfnWriteFPGARegister(hw->adp, INTR_INTR_MSK_SET_REG, intr_mask.whole_reg);
+
+	return;
+}
+
+void crystalhd_link_enable_interrupts(struct crystalhd_hw *hw)
+{
+	intr_mask_reg   intr_mask;
+	intr_mask.whole_reg = hw->pfnReadFPGARegister(hw->adp, INTR_INTR_MSK_STS_REG);
+	intr_mask.mask_pcie_err = 1;
+	intr_mask.mask_pcie_rbusmast_err = 1;
+	intr_mask.mask_pcie_rgr_bridge   = 1;
+	intr_mask.mask_rx_done = 1;
+	intr_mask.mask_rx_err  = 1;
+	intr_mask.mask_tx_done = 1;
+	intr_mask.mask_tx_err  = 1;
+	hw->pfnWriteFPGARegister(hw->adp, INTR_INTR_MSK_CLR_REG, intr_mask.whole_reg);
+
+	return;
+}
+
+void crystalhd_link_clear_errors(struct crystalhd_hw *hw)
+{
+	uint32_t reg;
+
+	/* Writing a 1 to a set bit clears that bit */
+	reg = hw->pfnReadFPGARegister(hw->adp, MISC1_Y_RX_ERROR_STATUS);
+	if (reg)
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_ERROR_STATUS, reg);
+
+	reg = hw->pfnReadFPGARegister(hw->adp, MISC1_UV_RX_ERROR_STATUS);
+	if (reg)
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_ERROR_STATUS, reg);
+
+	reg = hw->pfnReadFPGARegister(hw->adp, MISC1_TX_DMA_ERROR_STATUS);
+	if (reg)
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_TX_DMA_ERROR_STATUS, reg);
+}
+
+void crystalhd_link_clear_interrupts(struct crystalhd_hw *hw)
+{
+	uint32_t intr_sts =  hw->pfnReadFPGARegister(hw->adp, INTR_INTR_STATUS);
+
+	if (intr_sts) {
+		hw->pfnWriteFPGARegister(hw->adp, INTR_INTR_CLR_REG, intr_sts);
+
+		/* Write End Of Interrupt for PCIE */
+		hw->pfnWriteFPGARegister(hw->adp, INTR_EOI_CTRL, 1);
+	}
+}
+
+void crystalhd_link_soft_rst(struct crystalhd_hw *hw)
+{
+	uint32_t val;
+
+	/* Assert c011 soft reset*/
+	hw->pfnWriteDevRegister(hw->adp, DecHt_HostSwReset, 0x00000001);
+	msleep_interruptible(50);
+
+	/* Release c011 soft reset*/
+	hw->pfnWriteDevRegister(hw->adp, DecHt_HostSwReset, 0x00000000);
+
+	/* Disable Stuffing..*/
+	val = hw->pfnReadFPGARegister(hw->adp, MISC2_GLOBAL_CTRL);
+	val |= BC_BIT(8);
+	hw->pfnWriteFPGARegister(hw->adp, MISC2_GLOBAL_CTRL, val);
+}
+
+bool crystalhd_link_load_firmware_config(struct crystalhd_hw *hw)
+{
+	uint32_t i = 0, reg;
+
+	hw->pfnWriteFPGARegister(hw->adp, DCI_DRAM_BASE_ADDR, (BC_DRAM_FW_CFG_ADDR >> 19));
+
+	hw->pfnWriteFPGARegister(hw->adp, AES_CMD, 0);
+	hw->pfnWriteFPGARegister(hw->adp, AES_CONFIG_INFO, (BC_DRAM_FW_CFG_ADDR & 0x7FFFF));
+	hw->pfnWriteFPGARegister(hw->adp, AES_CMD, 0x1);
+
+	for (i = 0; i < 100; ++i) {
+		reg = hw->pfnReadFPGARegister(hw->adp, AES_STATUS);
+		if (reg & 0x1)
+			return true;
+		msleep_interruptible(10);
+	}
+
+	return false;
+}
+
+
+bool crystalhd_link_start_device(struct crystalhd_hw *hw)
+{
+	uint32_t dbg_options, glb_cntrl = 0, reg_pwrmgmt = 0;
+	struct device *dev;
+
+	if (!hw)
+		return -EINVAL;
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "Starting Crystal HD BCM70012 Device\n");
+
+	if (!crystalhd_link_bring_out_of_rst(hw)) {
+		dev_err(dev, "Failed To Bring BCM70012 Out Of Reset\n");
+		return false;
+	}
+
+	crystalhd_link_disable_interrupts(hw);
+
+	crystalhd_link_clear_errors(hw);
+
+	crystalhd_link_clear_interrupts(hw);
+
+	crystalhd_link_enable_interrupts(hw);
+
+	/* Enable the option for getting the total no. of DWORDS
+	 * that have been transfered by the RXDMA engine
+	 */
+	dbg_options = hw->pfnReadFPGARegister(hw->adp, MISC1_DMA_DEBUG_OPTIONS_REG);
+	dbg_options |= 0x10;
+	hw->pfnWriteFPGARegister(hw->adp, MISC1_DMA_DEBUG_OPTIONS_REG, dbg_options);
+
+	/* Enable PCI Global Control options */
+	glb_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC2_GLOBAL_CTRL);
+	glb_cntrl |= 0x100;
+	glb_cntrl |= 0x8000;
+	hw->pfnWriteFPGARegister(hw->adp, MISC2_GLOBAL_CTRL, glb_cntrl);
+
+	crystalhd_link_enable_interrupts(hw);
+
+	crystalhd_link_soft_rst(hw);
+	crystalhd_link_start_dram(hw);
+	crystalhd_link_enable_uarts(hw);
+
+	// Disable L1 ASPM while video is playing as this causes performance problems otherwise
+	reg_pwrmgmt = hw->pfnReadFPGARegister(hw->adp, PCIE_DLL_DATA_LINK_CONTROL);
+	reg_pwrmgmt &= ~ASPM_L1_ENABLE;
+
+	hw->pfnWriteFPGARegister(hw->adp, PCIE_DLL_DATA_LINK_CONTROL, reg_pwrmgmt);
+
+	return true;
+}
+
+bool crystalhd_link_stop_device(struct crystalhd_hw *hw)
+{
+	uint32_t reg;
+	BC_STATUS sts;
+
+	dev_dbg(&hw->adp->pdev->dev, "Stopping Crystal HD BCM70012 Device\n");
+	sts = crystalhd_link_put_ddr2sleep(hw);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(&hw->adp->pdev->dev, "Failed to Put DDR To Sleep!!\n");
+		return BC_STS_ERROR;
+	}
+
+	/* Clear and disable interrupts */
+	crystalhd_link_disable_interrupts(hw);
+	crystalhd_link_clear_errors(hw);
+	crystalhd_link_clear_interrupts(hw);
+
+	if (!crystalhd_link_put_in_reset(hw))
+		dev_err(&hw->adp->pdev->dev, "Failed to Put Link To Reset State\n");
+
+	reg = hw->pfnReadFPGARegister(hw->adp, PCIE_DLL_DATA_LINK_CONTROL);
+	reg |= ASPM_L1_ENABLE;
+	hw->pfnWriteFPGARegister(hw->adp, PCIE_DLL_DATA_LINK_CONTROL, reg);
+
+	/* Set PCI Clk Req */
+	reg = hw->pfnReadFPGARegister(hw->adp, PCIE_CLK_REQ_REG);
+	reg |= PCI_CLK_REQ_ENABLE;
+	hw->pfnWriteFPGARegister(hw->adp, PCIE_CLK_REQ_REG, reg);
+
+	return true;
+}
+
+uint32_t link_GetPicInfoLineNum(crystalhd_dio_req *dio, uint8_t *base)
+{
+	uint32_t PicInfoLineNum = 0;
+
+	if (dio->uinfo.b422mode == MODE422_YUY2) {
+		PicInfoLineNum = ((uint32_t)(*(base + 6)) & 0xff)
+			| (((uint32_t)(*(base + 4)) << 8)  & 0x0000ff00)
+			| (((uint32_t)(*(base + 2)) << 16) & 0x00ff0000)
+			| (((uint32_t)(*(base + 0)) << 24) & 0xff000000);
+	} else if (dio->uinfo.b422mode == MODE422_UYVY) {
+		PicInfoLineNum = ((uint32_t)(*(base + 7)) & 0xff)
+			| (((uint32_t)(*(base + 5)) << 8)  & 0x0000ff00)
+			| (((uint32_t)(*(base + 3)) << 16) & 0x00ff0000)
+			| (((uint32_t)(*(base + 1)) << 24) & 0xff000000);
+	} else {
+		PicInfoLineNum = ((uint32_t)(*(base + 3)) & 0xff)
+			| (((uint32_t)(*(base + 2)) << 8)  & 0x0000ff00)
+			| (((uint32_t)(*(base + 1)) << 16) & 0x00ff0000)
+			| (((uint32_t)(*(base + 0)) << 24) & 0xff000000);
+	}
+
+	return PicInfoLineNum;
+}
+
+uint32_t link_GetMode422Data(crystalhd_dio_req *dio,
+			       PBC_PIC_INFO_BLOCK pPicInfoLine, int type)
+{
+	int i;
+	uint32_t offset = 0, val = 0;
+	uint8_t *tmp;
+	tmp = (uint8_t *)&val;
+
+	if (type == 1)
+		offset = OFFSETOF(BC_PIC_INFO_BLOCK, picture_meta_payload);
+	else if (type == 2)
+		offset = OFFSETOF(BC_PIC_INFO_BLOCK, height);
+	else
+		offset = 0;
+
+	if (dio->uinfo.b422mode == MODE422_YUY2) {
+		for (i = 0; i < 4; i++)
+			((uint8_t*)tmp)[i] =
+				((uint8_t*)pPicInfoLine)[(offset + i) * 2];
+	} else if (dio->uinfo.b422mode == MODE422_UYVY) {
+		for (i = 0; i < 4; i++)
+			((uint8_t*)tmp)[i] =
+				((uint8_t*)pPicInfoLine)[(offset + i) * 2 + 1];
+	}
+
+	return val;
+}
+
+uint32_t link_GetMetaDataFromPib(crystalhd_dio_req *dio,
+				   PBC_PIC_INFO_BLOCK pPicInfoLine)
+{
+	uint32_t picture_meta_payload = 0;
+
+	if (dio->uinfo.b422mode)
+		picture_meta_payload = link_GetMode422Data(dio, pPicInfoLine, 1);
+	else
+		picture_meta_payload = pPicInfoLine->picture_meta_payload;
+
+	return BC_SWAP32(picture_meta_payload);
+}
+
+uint32_t link_GetHeightFromPib(crystalhd_dio_req *dio,
+				 PBC_PIC_INFO_BLOCK pPicInfoLine)
+{
+	uint32_t height = 0;
+
+	if (dio->uinfo.b422mode)
+		height = link_GetMode422Data(dio, pPicInfoLine, 2);
+	else
+		height = pPicInfoLine->height;
+
+	return BC_SWAP32(height);
+}
+
+/* This function cannot be called from ISR context since it uses APIs that can sleep */
+bool link_GetPictureInfo(struct crystalhd_hw *hw, uint32_t picHeight, uint32_t picWidth, crystalhd_dio_req *dio,
+			   uint32_t *PicNumber, uint64_t *PicMetaData)
+{
+	uint32_t PicInfoLineNum = 0, HeightInPib = 0, offset = 0, size = 0;
+	PBC_PIC_INFO_BLOCK pPicInfoLine = NULL;
+	uint32_t pic_number = 0;
+	uint8_t *tmp = (uint8_t *)&pic_number;
+	int i;
+	unsigned long res = 0;
+
+	//dev_dbg(&hw->adp->pdev->dev, "getting Picture Info\n");
+
+	*PicNumber = 0;
+	*PicMetaData = 0;
+
+	if (!dio || !picWidth)
+		goto getpictureinfo_err_nosem;
+
+// 	if(down_interruptible(&hw->fetch_sem))
+// 		goto getpictureinfo_err_nosem;
+
+	dio->pib_va = kmalloc(2 * sizeof(BC_PIC_INFO_BLOCK) + 16, GFP_KERNEL); // since copy_from_user can sleep anyway
+	if(dio->pib_va == NULL)
+		goto getpictureinfo_err;
+
+	res = copy_from_user(dio->pib_va, (void *)dio->uinfo.xfr_buff, 8);
+	if (res != 0)
+		goto getpictureinfo_err;
+
+	/*
+	 * -- Ajitabh[01-16-2009]: Strictly check against done size.
+	 * -- we have seen that the done size sometimes comes less without
+	 * -- any error indicated to the driver. So we change the limit
+	 * -- to check against the done size rather than the full buffer size
+	 * -- this way we will always make sure that the PIB is recieved by
+	 * -- the driver.
+	 */
+	/* Limit = Base + pRxDMAReq->RxYDMADesc.RxBuffSz; */
+	/* Limit = Base + (pRxDMAReq->RxYDoneSzInDword * 4); */
+// 	Limit = dio->uinfo.xfr_buff + dio->uinfo.xfr_len;
+
+	PicInfoLineNum = link_GetPicInfoLineNum(dio, dio->pib_va);
+	if (PicInfoLineNum > 1092) {
+		//dev_dbg(&hw->adp->pdev->dev, "Invalid Line Number[%x]\n", (int)PicInfoLineNum);
+		goto getpictureinfo_err;
+	}
+
+	/*
+	 * -- Ajitabh[01-16-2009]: Added the check for validating the
+	 * -- PicInfoLine Number. This function is only called for link so we
+	 * -- do not have to check for height+1 or (Height+1)/2 as we are doing
+	 * -- in DIL. In DIL we need that because for flea firmware is padding
+	 * -- the data to make it 16 byte aligned. This Validates the reception
+	 * -- of PIB itself.
+	 */
+	if (picHeight) {
+		if ((PicInfoLineNum != picHeight) &&
+		    (PicInfoLineNum != picHeight/2)) {
+			dev_dbg(&hw->adp->pdev->dev, "PicInfoLineNum[%d] != PICHeight "
+				"Or PICHeight/2 [%d]\n",
+				(int)PicInfoLineNum, picHeight);
+			goto getpictureinfo_err;
+		}
+	}
+
+	/* calc pic info line offset */
+	if (dio->uinfo.b422mode) {
+		size = 2 * sizeof(BC_PIC_INFO_BLOCK);
+		offset = (PicInfoLineNum * picWidth * 2) + 8;
+	} else {
+		size = sizeof(BC_PIC_INFO_BLOCK);
+		offset = (PicInfoLineNum * picWidth) + 4;
+	}
+
+	res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff+offset), size);
+	if (res != 0)
+		goto getpictureinfo_err;
+	pPicInfoLine = (PBC_PIC_INFO_BLOCK)(dio->pib_va);
+
+// 	if (((uint8_t *)pPicInfoLine < Base) ||
+// 	    ((uint8_t *)pPicInfoLine > Limit)) {
+// 		dev_err(dev, "Base Limit Check Failed for Extracting "
+// 			"the PIB\n");
+// 		goto getpictureinfo_err;
+// 	}
+
+	/*
+	 * -- Ajitabh[01-16-2009]:
+	 * We have seen that the data gets shifted for some repeated frames.
+	 * To detect those we use PicInfoLineNum and compare it with height.
+	 */
+
+	HeightInPib = link_GetHeightFromPib(dio, pPicInfoLine);
+	if ((PicInfoLineNum != HeightInPib) &&
+	    (PicInfoLineNum != HeightInPib / 2)) {
+		printk("Height Match Failed: HeightInPIB[%d] "
+			"PicInfoLineNum[%d]\n",
+			(int)HeightInPib, (int)PicInfoLineNum);
+		goto getpictureinfo_err;
+	}
+
+	/* get pic meta data from pib */
+	*PicMetaData = link_GetMetaDataFromPib(dio, pPicInfoLine);
+	/* get pic number from pib */
+	/* calc pic info line offset */
+	if (dio->uinfo.b422mode)
+		offset = (PicInfoLineNum * picWidth * 2);
+	else
+		offset = (PicInfoLineNum * picWidth);
+
+	res = copy_from_user(dio->pib_va, (void *)(dio->uinfo.xfr_buff+offset), 12);
+	if (res != 0)
+		goto getpictureinfo_err;
+
+	if (dio->uinfo.b422mode == MODE422_YUY2) {
+		for (i = 0; i < 4; i++)
+			((uint8_t *)tmp)[i] = ((uint8_t *)dio->pib_va)[i * 2];
+	} else if (dio->uinfo.b422mode == MODE422_UYVY) {
+		for (i = 0; i < 4; i++)
+			((uint8_t *)tmp)[i] = ((uint8_t *)dio->pib_va)[(i * 2) + 1];
+	} else
+		pic_number = *(uint32_t *)(dio->pib_va);
+
+	*PicNumber =  BC_SWAP32(pic_number);
+
+	if(dio->pib_va)
+		kfree(dio->pib_va);
+
+// 	up(&hw->fetch_sem);
+
+	return true;
+
+getpictureinfo_err:
+// 	up(&hw->fetch_sem);
+
+getpictureinfo_err_nosem:
+	if(dio->pib_va)
+		kfree(dio->pib_va);
+	*PicNumber = 0;
+	*PicMetaData = 0;
+
+	return false;
+}
+
+uint32_t link_GetRptDropParam(struct crystalhd_hw *hw, uint32_t picHeight, uint32_t picWidth, void* pRxDMAReq)
+{
+	uint32_t PicNumber = 0, result = 0;
+	uint64_t PicMetaData = 0;
+
+	if(link_GetPictureInfo(hw, picHeight, picWidth, ((crystalhd_rx_dma_pkt *)pRxDMAReq)->dio_req,
+				&PicNumber, &PicMetaData))
+		result = PicNumber;
+
+	return result;
+}
+
+/*
+* This function gets the next picture metadata payload
+* from the decoded picture in ReadyQ (if there was any)
+* and returns it. THIS IS ONLY USED FOR LINK.
+*/
+bool crystalhd_link_peek_next_decoded_frame(struct crystalhd_hw *hw,
+					  uint64_t *meta_payload, uint32_t *picNumFlags,
+					  uint32_t PicWidth)
+{
+	uint32_t PicNumber = 0;
+	unsigned long flags = 0;
+	crystalhd_dioq_t *ioq;
+	crystalhd_elem_t *tmp;
+	crystalhd_rx_dma_pkt *rpkt;
+
+	*meta_payload = 0;
+
+	ioq = hw->rx_rdyq;
+	spin_lock_irqsave(&ioq->lock, flags);
+
+	if ((ioq->count > 0) && (ioq->head != (crystalhd_elem_t *)&ioq->head)) {
+		tmp = ioq->head;
+		spin_unlock_irqrestore(&ioq->lock, flags);
+		rpkt = (crystalhd_rx_dma_pkt *)tmp->data;
+		if (rpkt) {
+			// We are in process context here and have to check if we have repeated pictures
+			// Drop repeated pictures or garbabge pictures here
+			// This is because if we advertize a valid picture here, but later drop it
+			// It will cause single threaded applications to hang, or errors in applications that expect
+			// pictures not to be dropped once we have advertized their availability
+
+			// If format change packet, then return with out checking anything
+			if (!(rpkt->flags & (COMP_FLAG_PIB_VALID | COMP_FLAG_FMT_CHANGE))) {
+				link_GetPictureInfo(hw, hw->PICHeight, hw->PICWidth, rpkt->dio_req,
+									&PicNumber, meta_payload);
+				if(!PicNumber || (PicNumber == hw->LastPicNo) || (PicNumber == hw->LastTwoPicNo)) {
+					// discard picture
+					if(PicNumber != 0) {
+						hw->LastTwoPicNo = hw->LastPicNo;
+						hw->LastPicNo = PicNumber;
+					}
+					rpkt = crystalhd_dioq_fetch(hw->rx_rdyq);
+					if (rpkt) {
+						crystalhd_dioq_add(hw->rx_freeq, rpkt, false, rpkt->pkt_tag);
+						rpkt = NULL;
+					}
+					*meta_payload = 0;
+				}
+				return true;
+				// Do not update the picture numbers here since they will be updated on the actual fetch of a valid picture
+			}
+			else
+				return false; // don't use the meta_payload information
+		}
+		else
+			return false;
+	}
+	spin_unlock_irqrestore(&ioq->lock, flags);
+
+	return false;
+}
+
+bool crystalhd_link_check_input_full(struct crystalhd_hw *hw,
+				   uint32_t needed_sz, uint32_t *empty_sz,
+				   bool b_188_byte_pkts, uint8_t *flags)
+{
+	uint32_t base, end, writep, readp;
+	uint32_t cpbSize, cpbFullness, fifoSize;
+
+	if (*flags & 0x02) { /* ASF Bit is set */
+		base   = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsAudCDB2Base);
+		end    = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsAudCDB2End);
+		writep = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsAudCDB2Wrptr);
+		readp  = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsAudCDB2Rdptr);
+	} else if (b_188_byte_pkts) { /*Encrypted 188 byte packets*/
+		base   = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsUser0Base);
+		end    = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsUser0End);
+		writep = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsUser0Wrptr);
+		readp  = hw->pfnReadDevRegister(hw->adp, REG_Dec_TsUser0Rdptr);
+	} else {
+		base   = hw->pfnReadDevRegister(hw->adp, REG_DecCA_RegCinBase);
+		end    = hw->pfnReadDevRegister(hw->adp, REG_DecCA_RegCinEnd);
+		writep = hw->pfnReadDevRegister(hw->adp, REG_DecCA_RegCinWrPtr);
+		readp  = hw->pfnReadDevRegister(hw->adp, REG_DecCA_RegCinRdPtr);
+	}
+
+	cpbSize = end - base;
+	if (writep >= readp)
+		cpbFullness = writep - readp;
+	else
+		cpbFullness = (end - base) - (readp - writep);
+
+	fifoSize = cpbSize - cpbFullness;
+
+
+	if (fifoSize < BC_INFIFO_THRESHOLD)
+	{
+		*empty_sz = 0;
+		return true;
+	}
+
+	if (needed_sz > (fifoSize - BC_INFIFO_THRESHOLD))
+	{
+		*empty_sz = 0;
+		return true;
+	}
+	*empty_sz = fifoSize - BC_INFIFO_THRESHOLD;
+
+	return false;
+}
+
+bool crystalhd_link_tx_list0_handler(struct crystalhd_hw *hw, uint32_t err_sts)
+{
+	uint32_t err_mask, tmp;
+
+	err_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L0_DESC_TX_ABORT_ERRORS_MASK |
+		MISC1_TX_DMA_ERROR_STATUS_TX_L0_DMA_DATA_TX_ABORT_ERRORS_MASK |
+		MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;
+
+	if (!(err_sts & err_mask))
+		return false;
+
+	dev_err(&hw->adp->pdev->dev, "Error on Tx-L0 %x\n", err_sts);
+
+	tmp = err_mask;
+
+	if (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK)
+		tmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L0_FIFO_FULL_ERRORS_MASK;
+
+	if (tmp) {
+		/* reset list index.*/
+		hw->tx_list_post_index = 0;
+	}
+
+	tmp = err_sts & err_mask;
+	hw->pfnWriteFPGARegister(hw->adp, MISC1_TX_DMA_ERROR_STATUS, tmp);
+
+	return true;
+}
+
+bool crystalhd_link_tx_list1_handler(struct crystalhd_hw *hw, uint32_t err_sts)
+{
+	uint32_t err_mask, tmp;
+
+	err_mask = MISC1_TX_DMA_ERROR_STATUS_TX_L1_DESC_TX_ABORT_ERRORS_MASK |
+		MISC1_TX_DMA_ERROR_STATUS_TX_L1_DMA_DATA_TX_ABORT_ERRORS_MASK |
+		MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;
+
+	if (!(err_sts & err_mask))
+		return false;
+
+	dev_err(&hw->adp->pdev->dev, "Error on Tx-L1 %x\n", err_sts);
+
+	tmp = err_mask;
+
+	if (err_sts & MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK)
+		tmp &= ~MISC1_TX_DMA_ERROR_STATUS_TX_L1_FIFO_FULL_ERRORS_MASK;
+
+	if (tmp) {
+		/* reset list index.*/
+		hw->tx_list_post_index = 0;
+	}
+
+	tmp = err_sts & err_mask;
+	hw->pfnWriteFPGARegister(hw->adp, MISC1_TX_DMA_ERROR_STATUS, tmp);
+
+	return true;
+}
+
+void crystalhd_link_tx_isr(struct crystalhd_hw *hw, uint32_t int_sts)
+{
+	uint32_t err_sts;
+
+	if (int_sts & INTR_INTR_STATUS_L0_TX_DMA_DONE_INTR_MASK)
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0,
+					   BC_STS_SUCCESS);
+
+	if (int_sts & INTR_INTR_STATUS_L1_TX_DMA_DONE_INTR_MASK)
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1,
+					     BC_STS_SUCCESS);
+
+	if (!(int_sts & (INTR_INTR_STATUS_L0_TX_DMA_ERR_INTR_MASK |
+			 INTR_INTR_STATUS_L1_TX_DMA_ERR_INTR_MASK)))
+		/* No error mask set.. */
+		return;
+
+	/* Handle Tx errors. */
+	err_sts = hw->pfnReadFPGARegister(hw->adp, MISC1_TX_DMA_ERROR_STATUS);
+
+	if (crystalhd_link_tx_list0_handler(hw, err_sts))
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 0,
+					     BC_STS_ERROR);
+
+	if (crystalhd_link_tx_list1_handler(hw, err_sts))
+		crystalhd_hw_tx_req_complete(hw, hw->tx_ioq_tag_seed + 1,
+					     BC_STS_ERROR);
+
+	hw->stats.tx_errors++;
+}
+
+void crystalhd_link_start_tx_dma_engine(struct crystalhd_hw *hw, uint8_t list_id, addr_64 desc_addr)
+{
+	uint32_t dma_cntrl;
+	uint32_t first_desc_u_addr, first_desc_l_addr;
+
+	if (list_id == 0) {
+		first_desc_u_addr = MISC1_TX_FIRST_DESC_U_ADDR_LIST0;
+		first_desc_l_addr = MISC1_TX_FIRST_DESC_L_ADDR_LIST0;
+	} else {
+		first_desc_u_addr = MISC1_TX_FIRST_DESC_U_ADDR_LIST1;
+		first_desc_l_addr = MISC1_TX_FIRST_DESC_L_ADDR_LIST1;
+	}
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp,MISC1_TX_SW_DESC_LIST_CTRL_STS);
+	if (!(dma_cntrl & DMA_START_BIT)) {
+		dma_cntrl |= DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS,
+			       dma_cntrl);
+	}
+
+	hw->pfnWriteFPGARegister(hw->adp, first_desc_u_addr, desc_addr.high_part);
+
+	hw->pfnWriteFPGARegister(hw->adp, first_desc_l_addr, desc_addr.low_part | 0x01);
+						/* Be sure we set the valid bit ^^^^ */
+	return;
+}
+
+/* _CHECK_THIS_
+ *
+ * Verify if the Stop generates a completion interrupt or not.
+ * if it does not generate an interrupt, then add polling here.
+ */
+BC_STATUS crystalhd_link_stop_tx_dma_engine(struct crystalhd_hw *hw)
+{
+	struct device *dev;
+	uint32_t dma_cntrl, cnt = 30;
+	uint32_t l1 = 1, l2 = 1;
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS);
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "Stopping TX DMA Engine..\n");
+
+	if (!(dma_cntrl & DMA_START_BIT)) {
+		dev_dbg(dev, "Already Stopped\n");
+		return BC_STS_SUCCESS;
+	}
+
+	crystalhd_link_disable_interrupts(hw);
+
+	/* Issue stop to HW */
+	dma_cntrl &= ~DMA_START_BIT;
+	hw->pfnWriteFPGARegister(hw->adp, MISC1_TX_SW_DESC_LIST_CTRL_STS, dma_cntrl);
+
+	dev_dbg(dev, "Cleared the DMA Start bit\n");
+
+	/* Poll for 3seconds (30 * 100ms) on both the lists..*/
+	while ((l1 || l2) && cnt) {
+
+		if (l1) {
+			l1 = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_TX_FIRST_DESC_L_ADDR_LIST0);
+			l1 &= DMA_START_BIT;
+		}
+
+		if (l2) {
+			l2 = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_TX_FIRST_DESC_L_ADDR_LIST1);
+			l2 &= DMA_START_BIT;
+		}
+
+		msleep_interruptible(100);
+
+		cnt--;
+	}
+
+	if (!cnt) {
+		dev_err(dev, "Failed to stop TX DMA.. l1 %d, l2 %d\n", l1, l2);
+		crystalhd_link_enable_interrupts(hw);
+		return BC_STS_ERROR;
+	}
+
+	hw->tx_list_post_index = 0;
+	dev_dbg(dev, "stopped TX DMA..\n");
+	crystalhd_link_enable_interrupts(hw);
+
+	return BC_STS_SUCCESS;
+}
+
+uint32_t crystalhd_link_get_pib_avail_cnt(struct crystalhd_hw *hw)
+{
+	/*
+	* Position of the PIB Entries can be found at
+	* 0th and the 1st location of the Circular list.
+	*/
+	uint32_t Q_addr;
+	uint32_t pib_cnt, r_offset, w_offset;
+
+	Q_addr = hw->pib_del_Q_addr;
+
+	/* Get the Read Pointer */
+	crystalhd_link_mem_rd(hw, Q_addr, 1, &r_offset);
+
+	/* Get the Write Pointer */
+	crystalhd_link_mem_rd(hw, Q_addr + sizeof(uint32_t), 1, &w_offset);
+
+	if (r_offset == w_offset)
+		return 0;	/* Queue is empty */
+
+	if (w_offset > r_offset)
+		pib_cnt = w_offset - r_offset;
+	else
+		pib_cnt = (w_offset + MAX_PIB_Q_DEPTH) -
+			  (r_offset + MIN_PIB_Q_DEPTH);
+
+	if (pib_cnt > MAX_PIB_Q_DEPTH) {
+		dev_err(&hw->adp->pdev->dev, "Invalid PIB Count (%u)\n", pib_cnt);
+		return 0;
+	}
+
+	return pib_cnt;
+}
+
+uint32_t crystalhd_link_get_addr_from_pib_Q(struct crystalhd_hw *hw)
+{
+	uint32_t Q_addr;
+	uint32_t addr_entry, r_offset, w_offset;
+
+	Q_addr = hw->pib_del_Q_addr;
+
+	/* Get the Read Pointer 0Th Location is Read Pointer */
+	crystalhd_link_mem_rd(hw, Q_addr, 1, &r_offset);
+
+	/* Get the Write Pointer 1st Location is Write pointer */
+	crystalhd_link_mem_rd(hw, Q_addr + sizeof(uint32_t), 1, &w_offset);
+
+	/* Queue is empty */
+	if (r_offset == w_offset)
+		return 0;
+
+	if ((r_offset < MIN_PIB_Q_DEPTH) || (r_offset >= MAX_PIB_Q_DEPTH))
+		return 0;
+
+	/* Get the Actual Address of the PIB */
+	crystalhd_link_mem_rd(hw, Q_addr + (r_offset * sizeof(uint32_t)),
+		       1, &addr_entry);
+
+	/* Increment the Read Pointer */
+	r_offset++;
+
+	if (MAX_PIB_Q_DEPTH == r_offset)
+		r_offset = MIN_PIB_Q_DEPTH;
+
+	/* Write back the read pointer to It's Location */
+	crystalhd_link_mem_wr(hw, Q_addr, 1, &r_offset);
+
+	return addr_entry;
+}
+
+bool crystalhd_link_rel_addr_to_pib_Q(struct crystalhd_hw *hw, uint32_t addr_to_rel)
+{
+	uint32_t Q_addr;
+	uint32_t r_offset, w_offset, n_offset;
+
+	Q_addr = hw->pib_rel_Q_addr;
+
+	/* Get the Read Pointer */
+	crystalhd_link_mem_rd(hw, Q_addr, 1, &r_offset);
+
+	/* Get the Write Pointer */
+	crystalhd_link_mem_rd(hw, Q_addr + sizeof(uint32_t), 1, &w_offset);
+
+	if ((r_offset < MIN_PIB_Q_DEPTH) ||
+	    (r_offset >= MAX_PIB_Q_DEPTH))
+		return false;
+
+	n_offset = w_offset + 1;
+
+	if (MAX_PIB_Q_DEPTH == n_offset)
+		n_offset = MIN_PIB_Q_DEPTH;
+
+	if (r_offset == n_offset)
+		return false; /* should never happen */
+
+	/* Write the DRAM ADDR to the Queue at Next Offset */
+	crystalhd_link_mem_wr(hw, Q_addr + (w_offset * sizeof(uint32_t)),
+		       1, &addr_to_rel);
+
+	/* Put the New value of the write pointer in Queue */
+	crystalhd_link_mem_wr(hw, Q_addr + sizeof(uint32_t), 1, &n_offset);
+
+	return true;
+}
+
+void link_cpy_pib_to_app(C011_PIB *src_pib, BC_PIC_INFO_BLOCK *dst_pib)
+{
+	if (!src_pib || !dst_pib) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return;
+	}
+
+	dst_pib->timeStamp		= 0;
+	dst_pib->picture_number		= src_pib->ppb.picture_number;
+	dst_pib->width			= src_pib->ppb.width;
+	dst_pib->height			= src_pib->ppb.height;
+	dst_pib->chroma_format		= src_pib->ppb.chroma_format;
+	dst_pib->pulldown		= src_pib->ppb.pulldown;
+	dst_pib->flags			= src_pib->ppb.flags;
+	dst_pib->sess_num		= src_pib->ptsStcOffset;
+	dst_pib->aspect_ratio		= src_pib->ppb.aspect_ratio;
+	dst_pib->colour_primaries	= src_pib->ppb.colour_primaries;
+	dst_pib->picture_meta_payload	= src_pib->ppb.picture_meta_payload;
+	dst_pib->frame_rate		= src_pib->resolution ;
+	return;
+}
+
+void crystalhd_link_proc_pib(struct crystalhd_hw *hw)
+{
+	unsigned int cnt;
+	C011_PIB src_pib;
+	uint32_t pib_addr, pib_cnt;
+	BC_PIC_INFO_BLOCK *AppPib;
+	crystalhd_rx_dma_pkt *rx_pkt = NULL;
+
+	pib_cnt = crystalhd_link_get_pib_avail_cnt(hw);
+
+	if (!pib_cnt)
+		return;
+
+	for (cnt = 0; cnt < pib_cnt; cnt++) {
+		pib_addr = crystalhd_link_get_addr_from_pib_Q(hw);
+		crystalhd_link_mem_rd(hw, pib_addr, sizeof(C011_PIB) / 4,
+				 (uint32_t *)&src_pib);
+
+		if (src_pib.bFormatChange) {
+			rx_pkt = (crystalhd_rx_dma_pkt *)
+					crystalhd_dioq_fetch(hw->rx_freeq);
+			if (!rx_pkt)
+				return;
+
+			rx_pkt->flags = 0;
+			rx_pkt->flags |= COMP_FLAG_PIB_VALID |
+					 COMP_FLAG_FMT_CHANGE;
+			AppPib = &rx_pkt->pib;
+			link_cpy_pib_to_app(&src_pib, AppPib);
+
+			hw->PICHeight = rx_pkt->pib.height;
+			if (rx_pkt->pib.width > 1280)
+				hw->PICWidth = 1920;
+			else if (rx_pkt->pib.width > 720)
+				hw->PICWidth = 1280;
+			else
+				hw->PICWidth = 720;
+
+			dev_info(&hw->adp->pdev->dev,
+				"[FMT CH] PIB:%x %x %x %x %x %x %x %x %x %x\n",
+				rx_pkt->pib.picture_number,
+				rx_pkt->pib.aspect_ratio,
+				rx_pkt->pib.chroma_format,
+				rx_pkt->pib.colour_primaries,
+				rx_pkt->pib.frame_rate,
+				rx_pkt->pib.height,
+				rx_pkt->pib.width,
+				rx_pkt->pib.n_drop,
+				rx_pkt->pib.pulldown,
+				rx_pkt->pib.ycom);
+
+			crystalhd_dioq_add(hw->rx_rdyq, (void *)rx_pkt,
+					   true, rx_pkt->pkt_tag);
+
+		}
+
+		crystalhd_link_rel_addr_to_pib_Q(hw, pib_addr);
+	}
+}
+
+void crystalhd_link_start_rx_dma_engine(struct crystalhd_hw *hw)
+{
+	uint32_t        dma_cntrl;
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);
+	if (!(dma_cntrl & DMA_START_BIT)) {
+		dma_cntrl |= DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);
+	if (!(dma_cntrl & DMA_START_BIT)) {
+		dma_cntrl |= DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+
+	return;
+}
+
+void crystalhd_link_stop_rx_dma_engine(struct crystalhd_hw *hw)
+{
+	struct device *dev = &hw->adp->pdev->dev;
+	uint32_t dma_cntrl = 0, count = 30;
+	uint32_t l0y = 1, l0uv = 1, l1y = 1, l1uv = 1;
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);
+	if ((dma_cntrl & DMA_START_BIT)) {
+		dma_cntrl &= ~DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);
+	if ((dma_cntrl & DMA_START_BIT)) {
+		dma_cntrl &= ~DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+
+	/* Poll for 3seconds (30 * 100ms) on both the lists..*/
+	while ((l0y || l0uv || l1y || l1uv) && count) {
+
+		if (l0y) {
+			l0y = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST0);
+			l0y &= DMA_START_BIT;
+			if (!l0y)
+				hw->rx_list_sts[0] &= ~rx_waiting_y_intr;
+		}
+
+		if (l1y) {
+			l1y = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST1);
+			l1y &= DMA_START_BIT;
+			if (!l1y)
+				hw->rx_list_sts[1] &= ~rx_waiting_y_intr;
+		}
+
+		if (l0uv) {
+			l0uv = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST0);
+			l0uv &= DMA_START_BIT;
+			if (!l0uv)
+				hw->rx_list_sts[0] &= ~rx_waiting_uv_intr;
+		}
+
+		if (l1uv) {
+			l1uv = hw->pfnReadFPGARegister(hw->adp,
+				MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST1);
+			l1uv &= DMA_START_BIT;
+			if (!l1uv)
+				hw->rx_list_sts[1] &= ~rx_waiting_uv_intr;
+		}
+		msleep_interruptible(100);
+		count--;
+	}
+
+	hw->rx_list_post_index = 0;
+
+	dev_dbg(dev, "Capture Stop: %d List0:Sts:%x List1:Sts:%x\n",
+		count, hw->rx_list_sts[0], hw->rx_list_sts[1]);
+}
+
+BC_STATUS crystalhd_link_hw_prog_rxdma(struct crystalhd_hw *hw,
+					 crystalhd_rx_dma_pkt *rx_pkt)
+{
+	struct device *dev;
+	uint32_t y_low_addr_reg, y_high_addr_reg;
+	uint32_t uv_low_addr_reg, uv_high_addr_reg;
+	addr_64 desc_addr;
+	unsigned long flags;
+
+	if (!hw || !rx_pkt) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	if (hw->rx_list_post_index >= DMA_ENGINE_CNT) {
+		dev_err(dev, "List Out Of bounds %x\n", hw->rx_list_post_index);
+		return BC_STS_INV_ARG;
+	}
+
+	spin_lock_irqsave(&hw->rx_lock, flags);
+	if (hw->rx_list_sts[hw->rx_list_post_index]) {
+		spin_unlock_irqrestore(&hw->rx_lock, flags);
+		return BC_STS_BUSY;
+	}
+
+	if (!hw->rx_list_post_index) {
+		y_low_addr_reg   = MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST0;
+		y_high_addr_reg  = MISC1_Y_RX_FIRST_DESC_U_ADDR_LIST0;
+		uv_low_addr_reg  = MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST0;
+		uv_high_addr_reg = MISC1_UV_RX_FIRST_DESC_U_ADDR_LIST0;
+	} else {
+		y_low_addr_reg   = MISC1_Y_RX_FIRST_DESC_L_ADDR_LIST1;
+		y_high_addr_reg  = MISC1_Y_RX_FIRST_DESC_U_ADDR_LIST1;
+		uv_low_addr_reg  = MISC1_UV_RX_FIRST_DESC_L_ADDR_LIST1;
+		uv_high_addr_reg = MISC1_UV_RX_FIRST_DESC_U_ADDR_LIST1;
+	}
+	rx_pkt->pkt_tag = hw->rx_pkt_tag_seed + hw->rx_list_post_index;
+	hw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_y_intr;
+	if (rx_pkt->uv_phy_addr)
+		hw->rx_list_sts[hw->rx_list_post_index] |= rx_waiting_uv_intr;
+	hw->rx_list_post_index = (hw->rx_list_post_index + 1) % DMA_ENGINE_CNT;
+
+	crystalhd_dioq_add(hw->rx_actq, (void *)rx_pkt, false, rx_pkt->pkt_tag);
+
+	crystalhd_link_start_rx_dma_engine(hw);
+	/* Program the Y descriptor */
+	desc_addr.full_addr = rx_pkt->desc_mem.phy_addr;
+	hw->pfnWriteFPGARegister(hw->adp, y_high_addr_reg, desc_addr.high_part);
+	hw->pfnWriteFPGARegister(hw->adp, y_low_addr_reg, desc_addr.low_part | 0x01);
+
+	if (rx_pkt->uv_phy_addr) {
+		/* Program the UV descriptor */
+		desc_addr.full_addr = rx_pkt->uv_phy_addr;
+		hw->pfnWriteFPGARegister(hw->adp, uv_high_addr_reg, desc_addr.high_part);
+		hw->pfnWriteFPGARegister(hw->adp, uv_low_addr_reg, desc_addr.low_part | 0x01);
+	}
+
+	spin_unlock_irqrestore(&hw->rx_lock, flags);
+
+	return BC_STS_SUCCESS;
+}
+
+BC_STATUS crystalhd_link_hw_post_cap_buff(struct crystalhd_hw *hw,
+					  crystalhd_rx_dma_pkt *rx_pkt)
+{
+	BC_STATUS sts = crystalhd_link_hw_prog_rxdma(hw, rx_pkt);
+
+	if (sts == BC_STS_BUSY)
+		crystalhd_dioq_add(hw->rx_freeq, (void *)rx_pkt,
+				 false, rx_pkt->pkt_tag);
+
+	return sts;
+}
+
+void crystalhd_link_get_dnsz(struct crystalhd_hw *hw, uint32_t list_index,
+			     uint32_t *y_dw_dnsz, uint32_t *uv_dw_dnsz)
+{
+	uint32_t y_dn_sz_reg, uv_dn_sz_reg;
+
+	if (!list_index) {
+		y_dn_sz_reg  = MISC1_Y_RX_LIST0_CUR_BYTE_CNT;
+		uv_dn_sz_reg = MISC1_UV_RX_LIST0_CUR_BYTE_CNT;
+	} else {
+		y_dn_sz_reg  = MISC1_Y_RX_LIST1_CUR_BYTE_CNT;
+		uv_dn_sz_reg = MISC1_UV_RX_LIST1_CUR_BYTE_CNT;
+	}
+
+	*y_dw_dnsz  = hw->pfnReadFPGARegister(hw->adp, y_dn_sz_reg);
+	*uv_dw_dnsz = hw->pfnReadFPGARegister(hw->adp, uv_dn_sz_reg);
+}
+
+/*
+ * This function should be called only after making sure that the two DMA
+ * lists are free. This function does not check if DMA's are active, before
+ * turning off the DMA.
+ */
+void crystalhd_link_hw_finalize_pause(struct crystalhd_hw *hw)
+{
+	uint32_t dma_cntrl;
+
+	hw->stop_pending = 0;
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS);
+	if (dma_cntrl & DMA_START_BIT) {
+		dma_cntrl &= ~DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+
+	dma_cntrl = hw->pfnReadFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS);
+	if (dma_cntrl & DMA_START_BIT) {
+		dma_cntrl &= ~DMA_START_BIT;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_SW_DESC_LIST_CTRL_STS,
+				 dma_cntrl);
+	}
+	hw->rx_list_post_index = 0;
+
+// 	aspm = crystalhd_reg_rd(hw->adp, PCIE_DLL_DATA_LINK_CONTROL);
+// 	aspm |= ASPM_L1_ENABLE;
+// 	dev_info(&hw->adp->pdev->dev, "aspm on\n");
+// 	crystalhd_reg_wr(hw->adp, PCIE_DLL_DATA_LINK_CONTROL, aspm);
+}
+
+bool crystalhd_link_rx_list0_handler(struct crystalhd_hw *hw,
+				       uint32_t int_sts,
+				       uint32_t y_err_sts,
+				       uint32_t uv_err_sts)
+{
+	uint32_t tmp;
+	list_sts tmp_lsts;
+
+	if (!(y_err_sts & GET_Y0_ERR_MSK) && !(uv_err_sts & GET_UV0_ERR_MSK))
+		return false;
+
+	tmp_lsts = hw->rx_list_sts[0];
+
+	/* Y0 - DMA */
+	tmp = y_err_sts & GET_Y0_ERR_MSK;
+	if (int_sts & INTR_INTR_STATUS_L0_Y_RX_DMA_DONE_INTR_MASK)
+		hw->rx_list_sts[0] &= ~rx_waiting_y_intr;
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[0] &= ~rx_waiting_y_intr;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;
+	}
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {
+		hw->rx_list_sts[0] &= ~rx_y_mask;
+		hw->rx_list_sts[0] |= rx_y_error;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[0] &= ~rx_y_mask;
+		hw->rx_list_sts[0] |= rx_y_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	/* UV0 - DMA */
+	tmp = uv_err_sts & GET_UV0_ERR_MSK;
+	if (int_sts & INTR_INTR_STATUS_L0_UV_RX_DMA_DONE_INTR_MASK)
+		hw->rx_list_sts[0] &= ~rx_waiting_uv_intr;
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[0] &= ~rx_waiting_uv_intr;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_UNDERRUN_ERROR_MASK;
+	}
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK) {
+		hw->rx_list_sts[0] &= ~rx_uv_mask;
+		hw->rx_list_sts[0] |= rx_uv_error;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L0_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[0] &= ~rx_uv_mask;
+		hw->rx_list_sts[0] |= rx_uv_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	if (y_err_sts & GET_Y0_ERR_MSK) {
+		tmp = y_err_sts & GET_Y0_ERR_MSK;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_ERROR_STATUS, tmp);
+	}
+
+	if (uv_err_sts & GET_UV0_ERR_MSK) {
+		tmp = uv_err_sts & GET_UV0_ERR_MSK;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_ERROR_STATUS, tmp);
+	}
+
+	return (tmp_lsts != hw->rx_list_sts[0]);
+}
+
+bool crystalhd_link_rx_list1_handler(struct crystalhd_hw *hw,
+				       uint32_t int_sts, uint32_t y_err_sts,
+				       uint32_t uv_err_sts)
+{
+	uint32_t tmp;
+	list_sts tmp_lsts;
+
+	if (!(y_err_sts & GET_Y1_ERR_MSK) && !(uv_err_sts & GET_UV1_ERR_MSK))
+		return false;
+
+	tmp_lsts = hw->rx_list_sts[1];
+
+	/* Y1 - DMA */
+	tmp = y_err_sts & GET_Y1_ERR_MSK;
+	if (int_sts & INTR_INTR_STATUS_L1_Y_RX_DMA_DONE_INTR_MASK)
+		hw->rx_list_sts[1] &= ~rx_waiting_y_intr;
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[1] &= ~rx_waiting_y_intr;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;
+	}
+
+	if (y_err_sts & MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {
+		/* Add retry-support..*/
+		hw->rx_list_sts[1] &= ~rx_y_mask;
+		hw->rx_list_sts[1] |= rx_y_error;
+		tmp &= ~MISC1_Y_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[1] &= ~rx_y_mask;
+		hw->rx_list_sts[1] |= rx_y_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	/* UV1 - DMA */
+	tmp = uv_err_sts & GET_UV1_ERR_MSK;
+	if (int_sts & INTR_INTR_STATUS_L1_UV_RX_DMA_DONE_INTR_MASK)
+		hw->rx_list_sts[1] &= ~rx_waiting_uv_intr;
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK) {
+		hw->rx_list_sts[1] &= ~rx_waiting_uv_intr;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_UNDERRUN_ERROR_MASK;
+	}
+
+	if (uv_err_sts & MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK) {
+		/* Add retry-support*/
+		hw->rx_list_sts[1] &= ~rx_uv_mask;
+		hw->rx_list_sts[1] |= rx_uv_error;
+		tmp &= ~MISC1_UV_RX_ERROR_STATUS_RX_L1_FIFO_FULL_ERRORS_MASK;
+	}
+
+	if (tmp) {
+		hw->rx_list_sts[1] &= ~rx_uv_mask;
+		hw->rx_list_sts[1] |= rx_uv_error;
+		hw->rx_list_post_index = 0;
+	}
+
+	if (y_err_sts & GET_Y1_ERR_MSK) {
+		tmp = y_err_sts & GET_Y1_ERR_MSK;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_Y_RX_ERROR_STATUS, tmp);
+	}
+
+	if (uv_err_sts & GET_UV1_ERR_MSK) {
+		tmp = uv_err_sts & GET_UV1_ERR_MSK;
+		hw->pfnWriteFPGARegister(hw->adp, MISC1_UV_RX_ERROR_STATUS, tmp);
+	}
+
+	return (tmp_lsts != hw->rx_list_sts[1]);
+}
+
+void crystalhd_link_rx_isr(struct crystalhd_hw *hw, uint32_t intr_sts)
+{
+	unsigned long flags;
+	uint32_t i, list_avail = 0;
+	BC_STATUS comp_sts = BC_STS_NO_DATA;
+	uint32_t y_err_sts, uv_err_sts, y_dn_sz = 0, uv_dn_sz = 0;
+	bool ret = 0;
+
+	if (!hw) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return;
+	}
+
+	if (!(intr_sts & GET_RX_INTR_MASK))
+		return;
+
+	y_err_sts = hw->pfnReadFPGARegister(hw->adp, MISC1_Y_RX_ERROR_STATUS);
+	uv_err_sts = hw->pfnReadFPGARegister(hw->adp, MISC1_UV_RX_ERROR_STATUS);
+
+	for (i = 0; i < DMA_ENGINE_CNT; i++) {
+		/* Update States..*/
+		spin_lock_irqsave(&hw->rx_lock, flags);
+		if (i == 0)
+			ret = crystalhd_link_rx_list0_handler(hw, intr_sts, y_err_sts, uv_err_sts);
+		else
+			ret = crystalhd_link_rx_list1_handler(hw, intr_sts, y_err_sts, uv_err_sts);
+		if (ret) {
+			switch (hw->rx_list_sts[i]) {
+			case sts_free:
+				comp_sts = BC_STS_SUCCESS;
+				list_avail = 1;
+				hw->stats.rx_success++;
+				break;
+			case rx_y_error:
+			case rx_uv_error:
+			case rx_sts_error:
+				/* We got error on both or Y or uv. */
+				hw->stats.rx_errors++;
+				hw->pfnHWGetDoneSize(hw, i, &y_dn_sz, &uv_dn_sz);
+				dev_info(&hw->adp->pdev->dev, "list_index:%x "
+					"rx[%d] rxtot[%d] Y:%x UV:%x Int:%x YDnSz:%x "
+					"UVDnSz:%x\n", i, hw->stats.rx_errors,
+					hw->stats.rx_errors + hw->stats.rx_success,
+					y_err_sts, uv_err_sts, intr_sts,
+					y_dn_sz, uv_dn_sz);
+				hw->rx_list_sts[i] = sts_free;
+				comp_sts = BC_STS_ERROR;
+				break;
+			default:
+				/* Wait for completion..*/
+				comp_sts = BC_STS_NO_DATA;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&hw->rx_lock, flags);
+
+		/* handle completion...*/
+		if (comp_sts != BC_STS_NO_DATA) {
+			crystalhd_rx_pkt_done(hw, i, comp_sts);
+			comp_sts = BC_STS_NO_DATA;
+		}
+	}
+
+	if (list_avail) {
+		if (hw->stop_pending) {
+			if ((hw->rx_list_sts[0] == sts_free) &&
+			    (hw->rx_list_sts[1] == sts_free))
+				crystalhd_link_hw_finalize_pause(hw);
+		} else {
+			if(!hw->hw_pause_issued)
+				crystalhd_hw_start_capture(hw);
+		}
+	}
+}
+
+BC_STATUS crystalhd_link_hw_pause(struct crystalhd_hw *hw, bool state)
+{
+	uint32_t pause = 0;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	if(state) {
+		pause = 1;
+		hw->stats.pause_cnt++;
+		hw->stop_pending = 1;
+		hw->pfnWriteDevRegister(hw->adp, HW_PauseMbx, pause);
+
+		if ((hw->rx_list_sts[0] == sts_free) &&
+			(hw->rx_list_sts[1] == sts_free))
+			crystalhd_link_hw_finalize_pause(hw);
+	} else {
+		pause = 0;
+		hw->stop_pending = 0;
+		sts = crystalhd_hw_start_capture(hw);
+		hw->pfnWriteDevRegister(hw->adp, HW_PauseMbx, pause);
+	}
+	return sts;
+}
+
+BC_STATUS crystalhd_link_fw_cmd_post_proc(struct crystalhd_hw *hw,
+					  BC_FW_CMD *fw_cmd)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+	DecRspChannelStartVideo *st_rsp = NULL;
+
+	switch (fw_cmd->cmd[0]) {
+	case eCMD_C011_DEC_CHAN_START_VIDEO:
+		st_rsp = (DecRspChannelStartVideo *)fw_cmd->rsp;
+		hw->pib_del_Q_addr = st_rsp->picInfoDeliveryQ;
+		hw->pib_rel_Q_addr = st_rsp->picInfoReleaseQ;
+		dev_dbg(&hw->adp->pdev->dev, "DelQAddr:%x RelQAddr:%x\n",
+		       hw->pib_del_Q_addr, hw->pib_rel_Q_addr);
+		break;
+	case eCMD_C011_INIT:
+		if (!(crystalhd_link_load_firmware_config(hw))) {
+			dev_err(&hw->adp->pdev->dev, "Invalid Params\n");
+			sts = BC_STS_FW_AUTH_FAILED;
+		}
+		break;
+	default:
+		break;
+	}
+	return sts;
+}
+
+BC_STATUS crystalhd_link_put_ddr2sleep(struct crystalhd_hw *hw)
+{
+	uint32_t reg;
+	link_misc_perst_decoder_ctrl rst_cntrl_reg;
+
+	/* Pulse reset pin of 7412 (MISC_PERST_DECODER_CTRL) */
+	rst_cntrl_reg.whole_reg = hw->pfnReadDevRegister(hw->adp, MISC_PERST_DECODER_CTRL);
+
+	rst_cntrl_reg.bcm_7412_rst = 1;
+	hw->pfnWriteDevRegister(hw->adp, MISC_PERST_DECODER_CTRL, rst_cntrl_reg.whole_reg);
+	msleep_interruptible(50);
+
+	rst_cntrl_reg.bcm_7412_rst = 0;
+	hw->pfnWriteDevRegister(hw->adp, MISC_PERST_DECODER_CTRL, rst_cntrl_reg.whole_reg);
+
+	/* Close all banks, put DDR in idle */
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_PRECHARGE, 0);
+
+	/* Set bit 25 (drop CKE pin of DDR) */
+	reg = hw->pfnReadDevRegister(hw->adp, SDRAM_PARAM);
+	reg |= 0x02000000;
+	hw->pfnWriteDevRegister(hw->adp, SDRAM_PARAM, reg);
+
+	/* Reset the audio block */
+	hw->pfnWriteDevRegister(hw->adp, AUD_DSP_MISC_SOFT_RESET, 0x1);
+
+	/* Power down Raptor PLL */
+	reg = hw->pfnReadDevRegister(hw->adp, DecHt_PllCCtl);
+	reg |= 0x00008000;
+	hw->pfnWriteDevRegister(hw->adp, DecHt_PllCCtl, reg);
+
+	/* Power down all Audio PLL */
+	hw->pfnWriteDevRegister(hw->adp, AIO_MISC_PLL_RESET, 0x1);
+
+	/* Power down video clock (75MHz) */
+	reg = hw->pfnReadDevRegister(hw->adp, DecHt_PllECtl);
+	reg |= 0x00008000;
+	hw->pfnWriteDevRegister(hw->adp, DecHt_PllECtl, reg);
+
+	/* Power down video clock (75MHz) */
+	reg = hw->pfnReadDevRegister(hw->adp, DecHt_PllDCtl);
+	reg |= 0x00008000;
+	hw->pfnWriteDevRegister(hw->adp, DecHt_PllDCtl, reg);
+
+	/* Power down core clock (200MHz) */
+	reg = hw->pfnReadDevRegister(hw->adp, DecHt_PllACtl);
+	reg |= 0x00008000;
+	hw->pfnWriteDevRegister(hw->adp, DecHt_PllACtl, reg);
+
+	/* Power down core clock (200MHz) */
+	reg = hw->pfnReadDevRegister(hw->adp, DecHt_PllBCtl);
+	reg |= 0x00008000;
+	hw->pfnWriteDevRegister(hw->adp, DecHt_PllBCtl, reg);
+
+	return BC_STS_SUCCESS;
+}
+
+/************************************************
+**
+*************************************************/
+
+BC_STATUS crystalhd_link_download_fw(struct crystalhd_hw *hw,
+				uint8_t *buffer, uint32_t sz)
+{
+	struct device *dev;
+	uint32_t reg_data, cnt, *temp_buff;
+	uint32_t fw_sig_len = 36;
+	uint32_t dram_offset = BC_FWIMG_ST_ADDR, sig_reg;
+
+	if (!hw || !buffer || !sz) {
+		printk(KERN_ERR "%s: Invalid Params\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "%s entered\n", __func__);
+
+	reg_data = hw->pfnReadFPGARegister(hw->adp, OTP_CMD);
+	if (!(reg_data & 0x02)) {
+		dev_err(dev, "Invalid hw config.. otp not programmed\n");
+		return BC_STS_ERROR;
+	}
+
+	reg_data = 0;
+	hw->pfnWriteFPGARegister(hw->adp, DCI_CMD, 0);
+	reg_data |= BC_BIT(0);
+	hw->pfnWriteFPGARegister(hw->adp, DCI_CMD, reg_data);
+
+	reg_data = 0;
+	cnt = 1000;
+	msleep_interruptible(10);
+
+	while (reg_data != BC_BIT(4)) {
+		reg_data = hw->pfnReadFPGARegister(hw->adp, DCI_STATUS);
+		reg_data &= BC_BIT(4);
+		if (--cnt == 0) {
+			dev_err(dev, "Firmware Download RDY Timeout.\n");
+			return BC_STS_TIMEOUT;
+		}
+	}
+
+	msleep_interruptible(10);
+	/*  Load the FW to the FW_ADDR field in the DCI_FIRMWARE_ADDR */
+	hw->pfnWriteFPGARegister(hw->adp, DCI_FIRMWARE_ADDR, dram_offset);
+	temp_buff = (uint32_t *)buffer;
+	for (cnt = 0; cnt < (sz - fw_sig_len); cnt += 4) {
+		hw->pfnWriteFPGARegister(hw->adp, DCI_DRAM_BASE_ADDR, (dram_offset >> 19));
+		hw->pfnWriteFPGARegister(hw->adp, DCI_FIRMWARE_DATA, *temp_buff);
+		dram_offset += 4;
+		temp_buff++;
+	}
+	msleep_interruptible(10);
+
+	temp_buff++;
+
+	sig_reg = (uint32_t)DCI_SIGNATURE_DATA_7;
+	for (cnt = 0; cnt < 8; cnt++) {
+		uint32_t swapped_data = *temp_buff;
+		swapped_data = bswap_32_1(swapped_data);
+		hw->pfnWriteFPGARegister(hw->adp, sig_reg, swapped_data);
+		sig_reg -= 4;
+		temp_buff++;
+	}
+	msleep_interruptible(10);
+
+	reg_data = 0;
+	reg_data |= BC_BIT(1);
+	hw->pfnWriteFPGARegister(hw->adp, DCI_CMD, reg_data);
+	msleep_interruptible(10);
+
+	reg_data = 0;
+	reg_data = hw->pfnReadFPGARegister(hw->adp, DCI_STATUS);
+
+	if ((reg_data & BC_BIT(9)) == BC_BIT(9)) {
+		cnt = 1000;
+		while ((reg_data & BC_BIT(0)) != BC_BIT(0)) {
+			reg_data = hw->pfnReadFPGARegister(hw->adp, DCI_STATUS);
+			reg_data &= BC_BIT(0);
+			if (!(--cnt))
+				break;
+			msleep_interruptible(10);
+		}
+		reg_data = 0;
+		reg_data = hw->pfnReadFPGARegister(hw->adp, DCI_CMD);
+		reg_data |= BC_BIT(4);
+		hw->pfnWriteFPGARegister(hw->adp, DCI_CMD, reg_data);
+
+	} else {
+		dev_err(dev, "F/w Signature mismatch\n");
+		return BC_STS_FW_AUTH_FAILED;
+	}
+
+	dev_dbg(dev, "Firmware Downloaded Successfully\n");
+
+	// Load command response addresses
+	hw->fwcmdPostAddr = TS_Host2CpuSnd;
+	hw->fwcmdPostMbox = Hst2CpuMbx1;
+	hw->fwcmdRespMbox = Cpu2HstMbx1;
+
+	return BC_STS_SUCCESS;;
+}
+
+BC_STATUS crystalhd_link_do_fw_cmd(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd)
+{
+	struct device *dev;
+	uint32_t cnt = 0, cmd_res_addr;
+	uint32_t *cmd_buff, *res_buff;
+	wait_queue_head_t fw_cmd_event;
+	int rc = 0;
+	BC_STATUS sts;
+	unsigned long flags;
+
+	crystalhd_create_event(&fw_cmd_event);
+
+	if (!hw || !fw_cmd) {
+		printk(KERN_ERR "%s: Invalid Arguments\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &hw->adp->pdev->dev;
+
+	dev_dbg(dev, "%s entered\n", __func__);
+
+	cmd_buff = fw_cmd->cmd;
+	res_buff = fw_cmd->rsp;
+
+	if (!cmd_buff || !res_buff) {
+		dev_err(dev, "Invalid Parameters for F/W Command\n");
+		return BC_STS_INV_ARG;
+	}
+
+	hw->fwcmd_evt_sts = 0;
+	hw->pfw_cmd_event = &fw_cmd_event;
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	/*Write the command to the memory*/
+	hw->pfnDevDRAMWrite(hw, hw->fwcmdPostAddr, FW_CMD_BUFF_SZ, cmd_buff);
+
+	/*Memory Read for memory arbitrator flush*/
+	hw->pfnDevDRAMRead(hw, hw->fwcmdPostAddr, 1, &cnt);
+
+	/* Write the command address to mailbox */
+	hw->pfnWriteDevRegister(hw->adp, hw->fwcmdPostMbox, hw->fwcmdPostAddr);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	msleep_interruptible(50);
+
+	// FW commands should complete even if we got a signal from the upper layer
+	crystalhd_wait_on_event(&fw_cmd_event, hw->fwcmd_evt_sts,
+				20000, rc, true);
+
+	if (!rc) {
+		sts = BC_STS_SUCCESS;
+	} else if (rc == -EBUSY) {
+		dev_err(dev, "Firmware command T/O\n");
+		sts = BC_STS_TIMEOUT;
+	} else if (rc == -EINTR) {
+		dev_err(dev, "FwCmd Wait Signal int - Should never happen\n");
+		sts = BC_STS_IO_USER_ABORT;
+	} else {
+		dev_err(dev, "FwCmd IO Error.\n");
+		sts = BC_STS_IO_ERROR;
+	}
+
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "FwCmd Failed.\n");
+		return sts;
+	}
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	/*Get the Responce Address*/
+	cmd_res_addr = hw->pfnReadDevRegister(hw->adp, hw->fwcmdRespMbox);
+
+	/*Read the Response*/
+	hw->pfnDevDRAMRead(hw, cmd_res_addr, FW_CMD_BUFF_SZ, res_buff);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	if (res_buff[2] != C011_RET_SUCCESS) {
+		dev_err(dev, "res_buff[2] != C011_RET_SUCCESS\n");
+		return BC_STS_FW_CMD_ERR;
+	}
+
+	sts = crystalhd_link_fw_cmd_post_proc(hw, fw_cmd);
+	if (sts != BC_STS_SUCCESS)
+		dev_err(dev, "crystalhd_fw_cmd_post_proc Failed.\n");
+
+	return sts;
+}
+
+bool crystalhd_link_hw_interrupt_handle(struct crystalhd_adp *adp, struct crystalhd_hw *hw)
+{
+	uint32_t intr_sts = 0;
+	uint32_t deco_intr = 0;
+	bool rc = false;
+
+	if (!adp || !hw->dev_started)
+		return rc;
+
+	hw->stats.num_interrupts++;
+
+	deco_intr = hw->pfnReadDevRegister(hw->adp, Stream2Host_Intr_Sts);
+	intr_sts  = hw->pfnReadFPGARegister(hw->adp, INTR_INTR_STATUS);
+
+	if (intr_sts) {
+		/* let system know we processed interrupt..*/
+		rc = true;
+		hw->stats.dev_interrupts++;
+	}
+
+	if (deco_intr && (deco_intr != 0xdeaddead)) {
+
+		if (deco_intr & 0x80000000) {
+			/*Set the Event and the status flag*/
+			if (hw->pfw_cmd_event) {
+				hw->fwcmd_evt_sts = 1;
+				crystalhd_set_event(hw->pfw_cmd_event);
+			}
+		}
+
+		if (deco_intr & BC_BIT(1))
+			crystalhd_link_proc_pib(hw);
+
+		hw->pfnWriteDevRegister(hw->adp, Stream2Host_Intr_Sts, deco_intr);
+		hw->pfnWriteDevRegister(hw->adp, Stream2Host_Intr_Sts, 0);
+		rc = 1;
+	}
+
+	/* Rx interrupts */
+	crystalhd_link_rx_isr(hw, intr_sts);
+
+	/* Tx interrupts*/
+	crystalhd_link_tx_isr(hw, intr_sts);
+
+	/* Clear interrupts */
+	if (rc) {
+		if (intr_sts)
+			hw->pfnWriteFPGARegister(hw->adp, INTR_INTR_CLR_REG, intr_sts);
+
+		hw->pfnWriteFPGARegister(hw->adp, INTR_EOI_CTRL, 1);
+	}
+
+	return rc;
+}
+
+// Dummy private function
+void crystalhd_link_notify_fll_change(struct crystalhd_hw *hw, bool bCleanupContext)
+{
+	return;
+}
+
+bool crystalhd_link_notify_event(struct crystalhd_hw *hw, BRCM_EVENT EventCode)
+{
+	return true;
+}
diff --git a/drivers/staging/chd/crystalhd_linkfuncs.h b/drivers/staging/chd/crystalhd_linkfuncs.h
new file mode 100644
index 0000000..4ae2994
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_linkfuncs.h
@@ -0,0 +1,228 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_linkfuncs . h
+ *
+ *  Description:
+ *		BCM70012 Linux driver hardware layer.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_LINKFUNCS_H_
+#define _CRYSTALHD_LINKFUNCS_H_
+
+#define ASPM_L1_ENABLE		(BC_BIT(27))
+
+/*************************************************
+  7412 Decoder  Registers.
+**************************************************/
+#define FW_CMD_BUFF_SZ		64
+#define TS_Host2CpuSnd		0x00000100
+#define HW_PauseMbx		0x00000300
+#define Hst2CpuMbx1		0x00100F00
+#define Cpu2HstMbx1		0x00100F04
+#define MbxStat1		0x00100F08
+#define Stream2Host_Intr_Sts	0x00100F24
+#define C011_RET_SUCCESS	0x0	/* Reutrn status of firmware command. */
+
+/* TS input status register */
+#define TS_StreamAFIFOStatus	0x0010044C
+#define TS_StreamBFIFOStatus	0x0010084C
+
+/*UART Selection definitions*/
+#define UartSelectA		0x00100300
+#define UartSelectB		0x00100304
+
+#define BSVS_UART_DEC_NONE	0x00
+#define BSVS_UART_DEC_OUTER	0x01
+#define BSVS_UART_DEC_INNER	0x02
+#define BSVS_UART_STREAM	0x03
+
+/* Code-In fifo */
+#define REG_DecCA_RegCinCTL	0xa00
+#define REG_DecCA_RegCinBase	0xa0c
+#define REG_DecCA_RegCinEnd	0xa10
+#define REG_DecCA_RegCinWrPtr	0xa04
+#define REG_DecCA_RegCinRdPtr	0xa08
+
+#define REG_Dec_TsUser0Base	0x100864
+#define REG_Dec_TsUser0Rdptr	0x100868
+#define REG_Dec_TsUser0Wrptr	0x10086C
+#define REG_Dec_TsUser0End	0x100874
+
+/* ASF Case ...*/
+#define REG_Dec_TsAudCDB2Base	0x10036c
+#define REG_Dec_TsAudCDB2Rdptr  0x100378
+#define REG_Dec_TsAudCDB2Wrptr  0x100374
+#define REG_Dec_TsAudCDB2End	0x100370
+
+/* DRAM bringup Registers */
+#define SDRAM_PARAM		0x00040804
+#define SDRAM_PRECHARGE		0x000408B0
+#define SDRAM_EXT_MODE		0x000408A4
+#define SDRAM_MODE		0x000408A0
+#define SDRAM_REFRESH		0x00040890
+#define SDRAM_REF_PARAM		0x00040808
+
+#define DecHt_PllACtl		0x34000C
+#define DecHt_PllBCtl		0x340010
+#define DecHt_PllCCtl		0x340014
+#define DecHt_PllDCtl		0x340034
+#define DecHt_PllECtl		0x340038
+#define AUD_DSP_MISC_SOFT_RESET	0x00240104
+#define AIO_MISC_PLL_RESET	0x0026000C
+#define PCIE_CLK_REQ_REG	0xDC
+#define	PCI_CLK_REQ_ENABLE	(BC_BIT(8))
+
+/*************************************************
+  F/W Copy engine definitions..
+**************************************************/
+#define BC_FWIMG_ST_ADDR	0x00000000
+
+#define DecHt_HostSwReset	0x340000
+#define BC_DRAM_FW_CFG_ADDR	0x001c2000
+
+typedef union _link_intr_mask_reg_ {
+	struct {
+		uint32_t	mask_tx_done:1;
+		uint32_t	mask_tx_err:1;
+		uint32_t	mask_rx_done:1;
+		uint32_t	mask_rx_err:1;
+		uint32_t	mask_pcie_err:1;
+		uint32_t	mask_pcie_rbusmast_err:1;
+		uint32_t	mask_pcie_rgr_bridge:1;
+		uint32_t	reserved:25;
+	};
+
+	uint32_t	whole_reg;
+
+} intr_mask_reg;
+
+typedef union _link_misc_perst_deco_ctrl_ {
+	struct {
+		uint32_t	bcm7412_rst:1;		/* 1 -> BCM7412 is held in reset. Reset value 1.*/
+		uint32_t	reserved0:3;		/* Reserved.No Effect*/
+		uint32_t	stop_bcm_7412_clk:1;	/* 1 ->Stops branch of 27MHz clk used to clk BCM7412*/
+		uint32_t	reserved1:27;		/* Reseved. No Effect*/
+	};
+
+	uint32_t	whole_reg;
+
+} link_misc_perst_deco_ctrl;
+
+typedef union _link_misc_perst_clk_ctrl_ {
+	struct {
+		uint32_t	sel_alt_clk:1;	  /* When set, selects a 6.75MHz clock as the source of core_clk */
+		uint32_t	stop_core_clk:1;  /* When set, stops the branch of core_clk that is not needed for low power operation */
+		uint32_t	pll_pwr_dn:1;	  /* When set, powers down the main PLL. The alternate clock bit should be set
+						     to select an alternate clock before setting this bit.*/
+		uint32_t	reserved0:5;	  /* Reserved */
+		uint32_t	pll_mult:8;	  /* This setting controls the multiplier for the PLL. */
+		uint32_t	pll_div:4;	  /* This setting controls the divider for the PLL. */
+		uint32_t	reserved1:12;	  /* Reserved */
+	};
+
+	uint32_t	whole_reg;
+
+} link_misc_perst_clk_ctrl;
+
+
+typedef union _link_misc_perst_decoder_ctrl_ {
+	struct {
+		uint32_t	bcm_7412_rst:1; /* 1 -> BCM7412 is held in reset. Reset value 1.*/
+		uint32_t	res0:3; /* Reserved.No Effect*/
+		uint32_t	stop_7412_clk:1; /* 1 ->Stops branch of 27MHz clk used to clk BCM7412*/
+		uint32_t	res1:27; /* Reseved. No Effect */
+	};
+
+	uint32_t	whole_reg;
+
+} link_misc_perst_decoder_ctrl;
+
+/* DMA engine register BIT mask wrappers.. */
+#define DMA_START_BIT		MISC1_TX_SW_DESC_LIST_CTRL_STS_TX_DMA_RUN_STOP_MASK
+
+#define GET_RX_INTR_MASK (INTR_INTR_STATUS_L1_UV_RX_DMA_ERR_INTR_MASK |		\
+			  INTR_INTR_STATUS_L1_UV_RX_DMA_DONE_INTR_MASK |	\
+			  INTR_INTR_STATUS_L1_Y_RX_DMA_ERR_INTR_MASK |		\
+			  INTR_INTR_STATUS_L1_Y_RX_DMA_DONE_INTR_MASK |		\
+			  INTR_INTR_STATUS_L0_UV_RX_DMA_ERR_INTR_MASK |		\
+			  INTR_INTR_STATUS_L0_UV_RX_DMA_DONE_INTR_MASK |	\
+			  INTR_INTR_STATUS_L0_Y_RX_DMA_ERR_INTR_MASK |		\
+			  INTR_INTR_STATUS_L0_Y_RX_DMA_DONE_INTR_MASK)
+
+uint32_t link_dec_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off);
+void link_dec_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val);
+uint32_t crystalhd_link_reg_rd(struct crystalhd_adp *adp, uint32_t reg_off);
+void crystalhd_link_reg_wr(struct crystalhd_adp *adp, uint32_t reg_off, uint32_t val);
+uint32_t crystalhd_link_dram_rd(struct crystalhd_hw *hw, uint32_t mem_off);
+void crystalhd_link_dram_wr(struct crystalhd_hw *hw, uint32_t mem_off, uint32_t val);
+BC_STATUS crystalhd_link_mem_rd(struct crystalhd_hw *hw, uint32_t start_off, uint32_t dw_cnt, uint32_t *rd_buff);
+BC_STATUS crystalhd_link_mem_wr(struct crystalhd_hw *hw, uint32_t start_off, uint32_t dw_cnt, uint32_t *wr_buff);
+void crystalhd_link_enable_uarts(struct crystalhd_hw *hw);
+void crystalhd_link_start_dram(struct crystalhd_hw *hw);
+bool crystalhd_link_bring_out_of_rst(struct crystalhd_hw *hw);
+bool crystalhd_link_put_in_reset(struct crystalhd_hw *hw);
+void crystalhd_link_disable_interrupts(struct crystalhd_hw *hw);
+void crystalhd_link_enable_interrupts(struct crystalhd_hw *hw);
+void crystalhd_link_clear_errors(struct crystalhd_hw *hw);
+void crystalhd_link_clear_interrupts(struct crystalhd_hw *hw);
+void crystalhd_link_soft_rst(struct crystalhd_hw *hw);
+bool crystalhd_link_load_firmware_config(struct crystalhd_hw *hw);
+bool crystalhd_link_start_device(struct crystalhd_hw *hw);
+bool crystalhd_link_stop_device(struct crystalhd_hw *hw);
+uint32_t link_GetPicInfoLineNum(crystalhd_dio_req *dio, uint8_t *base);
+uint32_t link_GetMode422Data(crystalhd_dio_req *dio, PBC_PIC_INFO_BLOCK pPicInfoLine, int type);
+uint32_t link_GetMetaDataFromPib(crystalhd_dio_req *dio,	PBC_PIC_INFO_BLOCK pPicInfoLine);
+uint32_t link_GetHeightFromPib(crystalhd_dio_req *dio, PBC_PIC_INFO_BLOCK pPicInfoLine);
+bool link_GetPictureInfo(struct crystalhd_hw *hw, uint32_t picHeight, uint32_t picWidth, crystalhd_dio_req *dio,
+								uint32_t *PicNumber, uint64_t *PicMetaData);
+uint32_t link_GetRptDropParam(struct crystalhd_hw *hw, uint32_t picHeight, uint32_t picWidth, void *pRxDMAReq);
+bool crystalhd_link_peek_next_decoded_frame(struct crystalhd_hw *hw, uint64_t *meta_payload, uint32_t *picNumFlags, uint32_t PicWidth);
+bool crystalhd_link_check_input_full(struct crystalhd_hw *hw, uint32_t needed_sz, uint32_t *empty_sz,
+									 bool b_188_byte_pkts, uint8_t *flags);
+bool crystalhd_link_tx_list0_handler(struct crystalhd_hw *hw, uint32_t err_sts);
+bool crystalhd_link_tx_list1_handler(struct crystalhd_hw *hw, uint32_t err_sts);
+void crystalhd_link_tx_isr(struct crystalhd_hw *hw, uint32_t int_sts);
+void crystalhd_link_start_tx_dma_engine(struct crystalhd_hw *hw, uint8_t list_id, addr_64 desc_addr);
+BC_STATUS crystalhd_link_stop_tx_dma_engine(struct crystalhd_hw *hw);
+uint32_t crystalhd_link_get_pib_avail_cnt(struct crystalhd_hw *hw);
+uint32_t crystalhd_link_get_addr_from_pib_Q(struct crystalhd_hw *hw);
+bool crystalhd_link_rel_addr_to_pib_Q(struct crystalhd_hw *hw, uint32_t addr_to_rel);
+void link_cpy_pib_to_app(C011_PIB *src_pib, BC_PIC_INFO_BLOCK *dst_pib);
+void crystalhd_link_proc_pib(struct crystalhd_hw *hw);
+void crystalhd_link_start_rx_dma_engine(struct crystalhd_hw *hw);
+void crystalhd_link_stop_rx_dma_engine(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_link_hw_prog_rxdma(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt *rx_pkt);
+BC_STATUS crystalhd_link_hw_post_cap_buff(struct crystalhd_hw *hw, crystalhd_rx_dma_pkt *rx_pkt);
+void crystalhd_link_get_dnsz(struct crystalhd_hw *hw, uint32_t list_index,
+									uint32_t *y_dw_dnsz, uint32_t *uv_dw_dnsz);
+void crystalhd_link_hw_finalize_pause(struct crystalhd_hw *hw);
+bool crystalhd_link_rx_list0_handler(struct crystalhd_hw *hw,uint32_t int_sts,uint32_t y_err_sts,uint32_t uv_err_sts);
+bool crystalhd_link_rx_list1_handler(struct crystalhd_hw *hw,uint32_t int_sts,uint32_t y_err_sts,uint32_t uv_err_sts);
+void crystalhd_link_rx_isr(struct crystalhd_hw *hw, uint32_t intr_sts);
+BC_STATUS crystalhd_link_hw_pause(struct crystalhd_hw *hw, bool state);
+BC_STATUS crystalhd_link_fw_cmd_post_proc(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd);
+BC_STATUS crystalhd_link_put_ddr2sleep(struct crystalhd_hw *hw);
+BC_STATUS crystalhd_link_download_fw(struct crystalhd_hw* hw, uint8_t* buffer, uint32_t sz);
+BC_STATUS crystalhd_link_do_fw_cmd(struct crystalhd_hw *hw, BC_FW_CMD *fw_cmd);
+bool crystalhd_link_hw_interrupt_handle(struct crystalhd_adp *adp, struct crystalhd_hw *hw);
+void crystalhd_link_notify_fll_change(struct crystalhd_hw *hw, bool bCleanupContext);
+bool crystalhd_link_notify_event(struct crystalhd_hw *hw, BRCM_EVENT EventCode);
+#endif
diff --git a/drivers/staging/chd/crystalhd_lnx.c b/drivers/staging/chd/crystalhd_lnx.c
new file mode 100644
index 0000000..f4c9a82
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_lnx.c
@@ -0,0 +1,783 @@
+/***************************************************************************
+  BCM70010 Linux driver
+  Copyright (c) 2005-2009, Broadcom Corporation.
+
+  This driver is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, version 2 of the License.
+
+  This driver is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+***************************************************************************/
+
+#include <linux/version.h>
+
+#include "crystalhd_lnx.h"
+
+static struct class *crystalhd_class;
+
+static struct crystalhd_adp *g_adp_info;
+
+struct device *chddev(void)
+{
+	return &g_adp_info->pdev->dev;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
+static irqreturn_t chd_dec_isr(int irq, void *arg)
+#else
+static irqreturn_t chd_dec_isr(int irq, void *arg, struct pt_regs *r)
+#endif
+{
+	struct crystalhd_adp *adp = (struct crystalhd_adp *) arg;
+	int rc = 0;
+	if (adp)
+		rc = crystalhd_cmd_interrupt(&adp->cmds);
+
+	return IRQ_RETVAL(rc);
+}
+
+static int chd_dec_enable_int(struct crystalhd_adp *adp)
+{
+	int rc = 0;
+
+	if (!adp || !adp->pdev) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	rc = pci_enable_msi(adp->pdev);
+	if(rc != 0)
+		dev_err(&adp->pdev->dev, "MSI request failed..\n");
+	else
+		adp->msi = 1;
+
+	rc = request_irq(adp->pdev->irq, chd_dec_isr, IRQF_SHARED,
+			 adp->name, (void *)adp);
+
+	if (rc != 0) {
+		dev_err(&adp->pdev->dev, "Interrupt request failed..\n");
+		if(adp->msi) {
+			pci_disable_msi(adp->pdev);
+			adp->msi = 0;
+		}
+	}
+
+	return rc;
+}
+
+static int chd_dec_disable_int(struct crystalhd_adp *adp)
+{
+	if (!adp || !adp->pdev) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	free_irq(adp->pdev->irq, adp);
+
+	if (adp->msi) {
+		pci_disable_msi(adp->pdev);
+		adp->msi = 0;
+	}
+
+	return 0;
+}
+
+crystalhd_ioctl_data *chd_dec_alloc_iodata(struct crystalhd_adp *adp, bool isr)
+{
+	unsigned long flags = 0;
+	crystalhd_ioctl_data *temp;
+
+	if (!adp)
+		return NULL;
+
+	spin_lock_irqsave(&adp->lock, flags);
+
+	temp = adp->idata_free_head;
+	if (temp) {
+		adp->idata_free_head = adp->idata_free_head->next;
+		memset(temp, 0, sizeof(*temp));
+	}
+
+	spin_unlock_irqrestore(&adp->lock, flags);
+	return temp;
+}
+
+void chd_dec_free_iodata(struct crystalhd_adp *adp, crystalhd_ioctl_data *iodata,
+			 bool isr)
+{
+	unsigned long flags = 0;
+
+	if (!adp || !iodata)
+		return;
+
+	spin_lock_irqsave(&adp->lock, flags);
+	iodata->next = adp->idata_free_head;
+	adp->idata_free_head = iodata;
+	spin_unlock_irqrestore(&adp->lock, flags);
+}
+
+static inline int crystalhd_user_data(unsigned long ud, void *dr, int size, int set)
+{
+	int rc;
+
+	if (!ud || !dr) {
+		dev_err(chddev(), "%s: Invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	if (set)
+		rc = copy_to_user((void *)ud, dr, size);
+	else
+		rc = copy_from_user(dr, (void *)ud, size);
+
+	if (rc) {
+		dev_err(chddev(), "Invalid args for command\n");
+		rc = -EFAULT;
+	}
+
+	return rc;
+}
+
+static int chd_dec_fetch_cdata(struct crystalhd_adp *adp, crystalhd_ioctl_data *io,
+			       uint32_t m_sz, unsigned long ua)
+{
+	unsigned long ua_off;
+	int rc = 0;
+
+	if (!adp || !io || !ua || !m_sz) {
+		dev_err(chddev(), "Invalid Arg!!\n");
+		return -EINVAL;
+	}
+
+	io->add_cdata = vmalloc(m_sz);
+	if (!io->add_cdata) {
+		dev_err(chddev(), "kalloc fail for sz:%x\n", m_sz);
+		return -ENOMEM;
+	}
+
+	io->add_cdata_sz = m_sz;
+	ua_off = ua + sizeof(io->udata);
+	rc = crystalhd_user_data(ua_off, io->add_cdata, io->add_cdata_sz, 0);
+	if (rc) {
+		dev_err(chddev(), "failed to pull add_cdata sz:%x "
+			"ua_off:%x\n", io->add_cdata_sz,
+			(unsigned int)ua_off);
+		if (io->add_cdata) {
+			kfree(io->add_cdata);
+			io->add_cdata = NULL;
+		}
+		return -ENODATA;
+	}
+
+	return rc;
+}
+
+static int chd_dec_release_cdata(struct crystalhd_adp *adp,
+				 crystalhd_ioctl_data *io, unsigned long ua)
+{
+	unsigned long ua_off;
+	int rc;
+
+	if (!adp || !io || !ua) {
+		dev_err(chddev(), "Invalid Arg!!\n");
+		return -EINVAL;
+	}
+
+	if (io->cmd != BCM_IOC_FW_DOWNLOAD) {
+		ua_off = ua + sizeof(io->udata);
+		rc = crystalhd_user_data(ua_off, io->add_cdata,
+					io->add_cdata_sz, 1);
+		if (rc) {
+			dev_err(chddev(), "failed to push add_cdata sz:%x "
+				"ua_off:%x\n", io->add_cdata_sz,
+				(unsigned int)ua_off);
+			return -ENODATA;
+		}
+	}
+
+	if (io->add_cdata) {
+		vfree(io->add_cdata);
+		io->add_cdata = NULL;
+	}
+
+	return 0;
+}
+
+static int chd_dec_proc_user_data(struct crystalhd_adp *adp,
+				  crystalhd_ioctl_data *io,
+				  unsigned long ua, int set)
+{
+	int rc;
+	uint32_t m_sz = 0;
+
+	if (!adp || !io || !ua) {
+		dev_err(chddev(), "Invalid Arg!!\n");
+		return -EINVAL;
+	}
+
+	rc = crystalhd_user_data(ua, &io->udata, sizeof(io->udata), set);
+	if (rc) {
+		dev_err(chddev(), "failed to %s iodata\n",
+			(set ? "set" : "get"));
+		return rc;
+	}
+
+	switch (io->cmd) {
+	case BCM_IOC_MEM_RD:
+	case BCM_IOC_MEM_WR:
+	case BCM_IOC_FW_DOWNLOAD:
+		m_sz = io->udata.u.devMem.NumDwords * 4;
+		if (set)
+			rc = chd_dec_release_cdata(adp, io, ua);
+		else
+			rc = chd_dec_fetch_cdata(adp, io, m_sz, ua);
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static int chd_dec_api_cmd(struct crystalhd_adp *adp, unsigned long ua,
+			   uint32_t uid, uint32_t cmd, crystalhd_cmd_proc func)
+{
+	int rc;
+	crystalhd_ioctl_data *temp;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	temp = chd_dec_alloc_iodata(adp, 0);
+	if (!temp) {
+		dev_err(chddev(), "Failed to get iodata..\n");
+		return -EINVAL;
+	}
+
+	temp->u_id = uid;
+	temp->cmd  = cmd;
+
+	rc = chd_dec_proc_user_data(adp, temp, ua, 0);
+	if (!rc) {
+		sts = func(&adp->cmds, temp);
+		if (sts == BC_STS_PENDING)
+			sts = BC_STS_NOT_IMPL;
+		temp->udata.RetSts = sts;
+		rc = chd_dec_proc_user_data(adp, temp, ua, 1);
+	}
+
+	if (temp) {
+		chd_dec_free_iodata(adp, temp, 0);
+		temp = NULL;
+	}
+
+	return rc;
+}
+
+/* API interfaces */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+static int chd_dec_ioctl(struct inode *in, struct file *fd,
+			 unsigned int cmd, unsigned long ua)
+#else
+static long chd_dec_ioctl(struct file *fd,
+			 unsigned int cmd, unsigned long ua)
+#endif
+{
+	struct crystalhd_adp *adp = chd_get_adp();
+	crystalhd_cmd_proc cproc;
+	struct crystalhd_user *uc;
+
+	if (!adp || !fd) {
+		dev_err(chddev(), "Invalid adp\n");
+		return -EINVAL;
+	}
+
+	uc = fd->private_data;
+	if (!uc) {
+		dev_err(chddev(), "Failed to get uc\n");
+		return -ENODATA;
+	}
+
+	cproc = crystalhd_get_cmd_proc(&adp->cmds, cmd, uc);
+	if (!cproc) {
+		dev_err(chddev(), "Unhandled command: %d\n", cmd);
+		return -EINVAL;
+	}
+
+	return chd_dec_api_cmd(adp, ua, uc->uid, cmd, cproc);
+}
+
+static int chd_dec_open(struct inode *in, struct file *fd)
+{
+	struct crystalhd_adp *adp = chd_get_adp();
+	struct device *dev = &adp->pdev->dev;
+	int rc = 0;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	struct crystalhd_user *uc = NULL;
+
+	dev_dbg(dev, "Entering %s\n", __func__);
+	if (!adp) {
+		dev_err(dev, "Invalid adp\n");
+		return -EINVAL;
+	}
+
+	if (adp->cfg_users >= BC_LINK_MAX_OPENS) {
+		dev_info(dev, "Already in use.%d\n", adp->cfg_users);
+		return -EBUSY;
+	}
+
+	sts = crystalhd_user_open(&adp->cmds, &uc);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "cmd_user_open - %d\n", sts);
+		rc = -EBUSY;
+	}
+	else {
+		adp->cfg_users++;
+		fd->private_data = uc;
+	}
+
+	return rc;
+}
+
+static int chd_dec_close(struct inode *in, struct file *fd)
+{
+	struct crystalhd_adp *adp = chd_get_adp();
+	struct device *dev = &adp->pdev->dev;
+	struct crystalhd_user *uc;
+
+	dev_dbg(dev, "Entering %s\n", __func__);
+	if (!adp) {
+		dev_err(dev, "Invalid adp\n");
+		return -EINVAL;
+	}
+
+	uc = fd->private_data;
+	if (!uc) {
+		dev_err(dev, "Failed to get uc\n");
+		return -ENODATA;
+	}
+
+	crystalhd_user_close(&adp->cmds, uc);
+
+	adp->cfg_users--;
+
+	return 0;
+}
+
+static const struct file_operations chd_dec_fops = {
+	.owner   = THIS_MODULE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	.ioctl   = chd_dec_ioctl,
+#else
+	.unlocked_ioctl = chd_dec_ioctl,
+#endif
+	.open    = chd_dec_open,
+	.release = chd_dec_close,
+};
+
+static int chd_dec_init_chdev(struct crystalhd_adp *adp)
+{
+	struct device *xdev = &adp->pdev->dev;
+	struct device *dev;
+	crystalhd_ioctl_data *temp;
+	int rc = -ENODEV, i = 0;
+
+	if (!adp)
+		goto fail;
+
+	adp->chd_dec_major = register_chrdev(0, CRYSTALHD_API_NAME,
+					     &chd_dec_fops);
+	if (adp->chd_dec_major < 0) {
+		dev_err(xdev, "Failed to create config dev\n");
+		rc = adp->chd_dec_major;
+		goto fail;
+	}
+
+	/* register crystalhd class */
+	crystalhd_class = class_create(THIS_MODULE, "crystalhd");
+	if (IS_ERR(crystalhd_class)) {
+		dev_err(xdev, "failed to create class\n");
+		goto fail;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 25)
+	dev = device_create(crystalhd_class, NULL, MKDEV(adp->chd_dec_major, 0),
+			    NULL, "crystalhd");
+#else
+	dev = device_create(crystalhd_class, NULL, MKDEV(adp->chd_dec_major, 0),
+			    "crystalhd");
+#endif
+	if (IS_ERR(dev)) {
+		dev_err(xdev, "failed to create device\n");
+		goto device_create_fail;
+	}
+
+//	rc = crystalhd_create_elem_pool(adp, BC_LINK_ELEM_POOL_SZ);
+//	if (rc) {
+//		dev_err(xdev, "failed to create device\n");
+//		goto elem_pool_fail;
+//	}
+
+	/* Allocate general purpose ioctl pool. */
+	for (i = 0; i < CHD_IODATA_POOL_SZ; i++) {
+		temp = kzalloc(sizeof(crystalhd_ioctl_data), GFP_KERNEL);
+		if (!temp) {
+			dev_err(xdev, "ioctl data pool kzalloc failed\n");
+			rc = -ENOMEM;
+			goto kzalloc_fail;
+		}
+		/* Add to global pool.. */
+		chd_dec_free_iodata(adp, temp, 0);
+	}
+
+	return 0;
+
+kzalloc_fail:
+	//crystalhd_delete_elem_pool(adp);
+//elem_pool_fail:
+	device_destroy(crystalhd_class, MKDEV(adp->chd_dec_major, 0));
+device_create_fail:
+	class_destroy(crystalhd_class);
+fail:
+	return rc;
+}
+
+static void chd_dec_release_chdev(struct crystalhd_adp *adp)
+{
+	crystalhd_ioctl_data *temp = NULL;
+	if (!adp)
+		return;
+
+	if (adp->chd_dec_major > 0) {
+		/* unregister crystalhd class */
+		device_destroy(crystalhd_class, MKDEV(adp->chd_dec_major, 0));
+		unregister_chrdev(adp->chd_dec_major, CRYSTALHD_API_NAME);
+		dev_info(chddev(), "released api device - %d\n",
+		       adp->chd_dec_major);
+		class_destroy(crystalhd_class);
+	}
+	adp->chd_dec_major = 0;
+
+	/* Clear iodata pool.. */
+	do {
+		temp = chd_dec_alloc_iodata(adp, 0);
+		if (temp)
+			kfree(temp);
+	} while (temp);
+
+	//crystalhd_delete_elem_pool(adp);
+}
+
+static int chd_pci_reserve_mem(struct crystalhd_adp *pinfo)
+{
+	struct device *dev = &pinfo->pdev->dev;
+	int rc;
+
+	uint32_t bar0		= pci_resource_start(pinfo->pdev, 0);
+	uint32_t i2o_len	= pci_resource_len(pinfo->pdev, 0);
+
+	uint32_t bar2		= pci_resource_start(pinfo->pdev, 2);
+	uint32_t mem_len	= pci_resource_len(pinfo->pdev, 2);
+
+	dev_dbg(dev, "bar0:0x%x-0x%08x  bar2:0x%x-0x%08x\n",
+	        bar0, i2o_len, bar2, mem_len);
+
+	pinfo->i2o_addr = ioremap_nocache(bar0, i2o_len);
+	if (!pinfo->i2o_addr) {
+		printk(KERN_ERR "Failed to remap i2o region...\n");
+		return -ENOMEM;
+	}
+
+	pinfo->pci_i2o_start = bar0;
+	pinfo->pci_i2o_len   = i2o_len;
+
+	pinfo->mem_addr = ioremap_nocache(bar2, mem_len);
+	if (!pinfo->mem_addr) {
+		printk(KERN_ERR "Failed to remap mem region...\n");
+		return -ENOMEM;
+	}
+
+	pinfo->pci_mem_start = bar2;
+	pinfo->pci_mem_len   = mem_len;
+
+	/* pdev */
+	rc = pci_request_regions(pinfo->pdev, pinfo->name);
+	if (rc < 0) {
+		printk(KERN_ERR "Region request failed: %d\n", rc);
+		return rc;
+	}
+
+	dev_dbg(dev, "i2o_addr:0x%08lx   Mapped addr:0x%08lx  \n",
+	        (unsigned long)pinfo->i2o_addr, (unsigned long)pinfo->mem_addr);
+
+	return 0;
+}
+
+static void chd_pci_release_mem(struct crystalhd_adp *pinfo)
+{
+	if (!pinfo)
+		return;
+
+	if (pinfo->mem_addr)
+		iounmap(pinfo->mem_addr);
+
+	if (pinfo->i2o_addr)
+		iounmap(pinfo->i2o_addr);
+
+	pci_release_regions(pinfo->pdev);
+}
+
+
+static void chd_dec_pci_remove(struct pci_dev *pdev)
+{
+	struct crystalhd_adp *pinfo;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	dev_dbg(chddev(), "Entering %s\n", __func__);
+
+	pinfo = (struct crystalhd_adp *) pci_get_drvdata(pdev);
+	if (!pinfo) {
+		dev_err(chddev(), "could not get adp\n");
+		return;
+	}
+
+	sts = crystalhd_delete_cmd_context(&pinfo->cmds);
+	if (sts != BC_STS_SUCCESS)
+		dev_err(chddev(), "cmd delete :%d\n", sts);
+
+	chd_dec_release_chdev(pinfo);
+
+	chd_dec_disable_int(pinfo);
+
+	chd_pci_release_mem(pinfo);
+	pci_disable_device(pinfo->pdev);
+
+	kfree(pinfo);
+	g_adp_info = NULL;
+}
+
+static int chd_dec_pci_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *entry)
+{
+	struct device *dev = &pdev->dev;
+	struct crystalhd_adp *pinfo;
+	int rc;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	dev_info(dev, "Starting Device:0x%04x\n", pdev->device);
+
+	pinfo = kzalloc(sizeof(struct crystalhd_adp), GFP_KERNEL);
+	if (!pinfo) {
+		dev_err(dev, "%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	pinfo->pdev = pdev;
+
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		dev_err(dev, "%s: Failed to enable PCI device\n", __func__);
+		return rc;
+	}
+
+	snprintf(pinfo->name, 31, "crystalhd_pci_e:%d:%d:%d",
+		 pdev->bus->number, PCI_SLOT(pdev->devfn),
+		 PCI_FUNC(pdev->devfn));
+
+	rc = chd_pci_reserve_mem(pinfo);
+	if (rc) {
+		dev_err(dev, "%s: Failed to set up memory regions.\n",
+			__func__);
+		pci_disable_device(pdev);
+		return -ENOMEM;
+	}
+
+	pinfo->present	= 1;
+	pinfo->drv_data = entry->driver_data;
+
+	/* Setup adapter level lock.. */
+	spin_lock_init(&pinfo->lock);
+
+	/* setup api stuff.. */
+	chd_dec_init_chdev(pinfo);
+	rc = chd_dec_enable_int(pinfo);
+	if (rc) {
+		dev_err(dev, "%s: _enable_int err:%d\n", __func__, rc);
+		pci_disable_device(pdev);
+		return -ENODEV;
+	}
+
+	/* Set dma mask... */
+	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
+		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+		pinfo->dmabits = 64;
+	} else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
+		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+		pinfo->dmabits = 32;
+	} else {
+		dev_err(dev, "%s: Unabled to setup DMA %d\n", __func__, rc);
+		pci_disable_device(pdev);
+		return -ENODEV;
+	}
+
+	sts = crystalhd_setup_cmd_context(&pinfo->cmds, pinfo);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "%s: cmd setup :%d\n", __func__, sts);
+		pci_disable_device(pdev);
+		return -ENODEV;
+	}
+
+	pci_set_master(pdev);
+
+	pci_set_drvdata(pdev, pinfo);
+
+	g_adp_info = pinfo;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+int chd_dec_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct crystalhd_adp *adp;
+	struct device *dev = &pdev->dev;
+	crystalhd_ioctl_data *temp;
+	BC_STATUS sts = BC_STS_SUCCESS;
+
+	adp = (struct crystalhd_adp *)pci_get_drvdata(pdev);
+	if (!adp) {
+		dev_err(dev, "%s: could not get adp\n", __func__);
+		return -ENODEV;
+	}
+
+	temp = chd_dec_alloc_iodata(adp, false);
+	if (!temp) {
+		dev_err(dev, "could not get ioctl data\n");
+		return -ENODEV;
+	}
+
+	sts = crystalhd_suspend(&adp->cmds, temp);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "Crystal HD Suspend %d\n", sts);
+		return -ENODEV;
+	}
+
+	chd_dec_free_iodata(adp, temp, false);
+	chd_dec_disable_int(adp);
+	pci_save_state(pdev);
+
+	/* Disable IO/bus master/irq router */
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	return 0;
+}
+
+int chd_dec_pci_resume(struct pci_dev *pdev)
+{
+	struct crystalhd_adp *adp;
+	struct device *dev = &pdev->dev;
+	BC_STATUS sts = BC_STS_SUCCESS;
+	int rc;
+
+	adp = (struct crystalhd_adp *)pci_get_drvdata(pdev);
+	if (!adp) {
+		dev_err(dev, "%s: could not get adp\n", __func__);
+		return -ENODEV;
+	}
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+
+	/* device's irq possibly is changed, driver should take care */
+	if (pci_enable_device(pdev)) {
+		dev_err(dev, "Failed to enable PCI device\n");
+		return 1;
+	}
+
+	pci_set_master(pdev);
+
+	rc = chd_dec_enable_int(adp);
+	if (rc) {
+		dev_err(dev, "_enable_int err:%d\n", rc);
+		pci_disable_device(pdev);
+		return -ENODEV;
+	}
+
+	sts = crystalhd_resume(&adp->cmds);
+	if (sts != BC_STS_SUCCESS) {
+		dev_err(dev, "Crystal HD Resume %d\n", sts);
+		pci_disable_device(pdev);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 24)
+static DEFINE_PCI_DEVICE_TABLE(chd_dec_pci_id_table) = {
+	{ PCI_VDEVICE(BROADCOM, 0x1612), 8 },
+	{ PCI_VDEVICE(BROADCOM, 0x1615), 8 },
+	{ 0, },
+};
+#else
+static struct pci_device_id chd_dec_pci_id_table[] = {
+/*	vendor, device, subvendor, subdevice, class, classmask, driver_data */
+	{ 0x14e4, 0x1612, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },
+	{ 0x14e4, 0x1615, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },
+	{ 0, },
+};
+#endif
+MODULE_DEVICE_TABLE(pci, chd_dec_pci_id_table);
+
+static struct pci_driver bc_chd_driver = {
+	.name     = "crystalhd",
+	.probe    = chd_dec_pci_probe,
+	.remove   = chd_dec_pci_remove,
+	.id_table = chd_dec_pci_id_table,
+#ifdef CONFIG_PM
+	.suspend  = chd_dec_pci_suspend,
+	.resume   = chd_dec_pci_resume
+#endif
+};
+
+struct crystalhd_adp *chd_get_adp(void)
+{
+	return g_adp_info;
+}
+
+static int __init chd_dec_module_init(void)
+{
+	int rc;
+
+	printk(KERN_DEBUG "Loading crystalhd v%d.%d.%d\n",
+	       crystalhd_kmod_major, crystalhd_kmod_minor, crystalhd_kmod_rev);
+
+	rc = pci_register_driver(&bc_chd_driver);
+
+	if (rc < 0)
+		printk(KERN_ERR "%s: Could not find any devices. err:%d\n",
+		       __func__, rc);
+
+	return rc;
+}
+module_init(chd_dec_module_init);
+
+static void __exit chd_dec_module_cleanup(void)
+{
+	printk(KERN_DEBUG "Unloading crystalhd %d.%d.%d\n",
+	       crystalhd_kmod_major, crystalhd_kmod_minor, crystalhd_kmod_rev);
+
+	pci_unregister_driver(&bc_chd_driver);
+}
+module_exit(chd_dec_module_cleanup);
+
+MODULE_AUTHOR("Naren Sankar <nsankar@broadcom.com>");
+MODULE_AUTHOR("Prasad Bolisetty <prasadb@broadcom.com>");
+MODULE_DESCRIPTION(CRYSTAL_HD_NAME);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("crystalhd");
diff --git a/drivers/staging/chd/crystalhd_lnx.h b/drivers/staging/chd/crystalhd_lnx.h
new file mode 100644
index 0000000..e147521
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_lnx.h
@@ -0,0 +1,94 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_lnx . c
+ *
+ *  Description:
+ *		BCM70012 Linux driver
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_LNX_H_
+#define _CRYSTALHD_LNX_H_
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <linux/uaccess.h>
+
+#include "crystalhd_cmds.h"
+
+#define CRYSTAL_HD_NAME "Broadcom Crystal HD Decoder Driver"
+
+/* OS specific PCI information structure and adapter information. */
+struct crystalhd_adp {
+	/* Hardware board/PCI specifics */
+	char			name[32];
+	struct pci_dev		*pdev;
+
+	unsigned long		pci_mem_start;
+	uint32_t			pci_mem_len;
+	void				*mem_addr;
+
+	unsigned long		pci_i2o_start;
+	uint32_t			pci_i2o_len;
+	void				*i2o_addr;
+
+	unsigned int		drv_data;
+	unsigned int		dmabits;	/* 32 | 64 */
+	unsigned int		registered;
+	unsigned int		present;
+	unsigned int		msi;
+
+	spinlock_t		lock;
+
+	/* API Related */
+	unsigned int		chd_dec_major;
+	unsigned int		cfg_users;
+
+	crystalhd_ioctl_data	*idata_free_head;	/* ioctl data pool */
+	crystalhd_elem_t	*elem_pool_head;	/* Queue element pool */
+
+	struct crystalhd_cmd	cmds;
+
+	crystalhd_dio_req	*ua_map_free_head;
+	struct pci_pool		*fill_byte_pool;
+};
+
+
+struct crystalhd_adp *chd_get_adp(void);
+struct device *chddev(void);
+
+#endif
+
diff --git a/drivers/staging/chd/crystalhd_misc.c b/drivers/staging/chd/crystalhd_misc.c
new file mode 100644
index 0000000..67235cf
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_misc.c
@@ -0,0 +1,946 @@
+/***************************************************************************
+ *	   Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_misc . c
+ *
+ *  Description:
+ *		BCM70012 Linux driver misc routines.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#include <linux/device.h>
+#include <linux/version.h>
+
+#include "crystalhd_lnx.h"
+#include "crystalhd_misc.h"
+
+// Some HW specific code defines
+extern uint32_t link_GetRptDropParam(struct crystalhd_hw *hw, uint32_t picHeight, uint32_t picWidth, void *);
+extern uint32_t flea_GetRptDropParam(struct crystalhd_hw *hw, void *);
+
+static crystalhd_dio_req *crystalhd_alloc_dio(struct crystalhd_adp *adp)
+{
+	unsigned long flags = 0;
+	crystalhd_dio_req *temp = NULL;
+
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return temp;
+	}
+
+	spin_lock_irqsave(&adp->lock, flags);
+	temp = adp->ua_map_free_head;
+	if (temp)
+		adp->ua_map_free_head = adp->ua_map_free_head->next;
+	spin_unlock_irqrestore(&adp->lock, flags);
+
+	return temp;
+}
+
+static void crystalhd_free_dio(struct crystalhd_adp *adp, crystalhd_dio_req *dio)
+{
+	unsigned long flags = 0;
+
+	if (!adp || !dio)
+		return;
+	spin_lock_irqsave(&adp->lock, flags);
+	dio->sig = crystalhd_dio_inv;
+	dio->page_cnt = 0;
+	dio->fb_size = 0;
+	memset(&dio->uinfo, 0, sizeof(dio->uinfo));
+	dio->next = adp->ua_map_free_head;
+	adp->ua_map_free_head = dio;
+	spin_unlock_irqrestore(&adp->lock, flags);
+}
+
+static crystalhd_elem_t *crystalhd_alloc_elem(struct crystalhd_adp *adp)
+{
+	unsigned long flags = 0;
+	crystalhd_elem_t *temp = NULL;
+
+	if (!adp)
+	{
+		printk(KERN_ERR "%s: Invalid args\n", __func__);
+		return temp;
+	}
+	spin_lock_irqsave(&adp->lock, flags);
+	temp = adp->elem_pool_head;
+	if (temp) {
+		adp->elem_pool_head = adp->elem_pool_head->flink;
+		memset(temp, 0, sizeof(*temp));
+	}
+
+	spin_unlock_irqrestore(&adp->lock, flags);
+
+	return temp;
+}
+static void crystalhd_free_elem(struct crystalhd_adp *adp, crystalhd_elem_t *elem)
+{
+	unsigned long flags = 0;
+
+	if (!adp || !elem)
+		return;
+	spin_lock_irqsave(&adp->lock, flags);
+	elem->flink = adp->elem_pool_head;
+	adp->elem_pool_head = elem;
+	spin_unlock_irqrestore(&adp->lock, flags);
+}
+
+static inline void crystalhd_set_sg(struct scatterlist *sg, struct page *page,
+				  unsigned int len, unsigned int offset)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+	sg_set_page(sg, page, len, offset);
+#else
+	sg->page       = page;
+	sg->offset     = offset;
+	sg->length     = len;
+#endif
+#ifdef CONFIG_X86_64
+	sg->dma_length = len;
+#endif
+}
+
+static inline void crystalhd_init_sg(struct scatterlist *sg, unsigned int entries)
+{
+	/* http://lkml.org/lkml/2007/11/27/68 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+	sg_init_table(sg, entries);
+#endif
+}
+
+/*========================== Extern ========================================*/
+/**
+ * crystalhd_pci_cfg_rd - PCIe config read
+ * @adp: Adapter instance
+ * @off: PCI config space offset.
+ * @len: Size -- Byte, Word & dword.
+ * @val: Value read
+ *
+ * Return:
+ *	Status.
+ *
+ * Get value from PCIe config space.
+ */
+BC_STATUS crystalhd_pci_cfg_rd(struct crystalhd_adp *adp, uint32_t off,
+			     uint32_t len, uint32_t *val)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+	int rc = 0;
+
+	if (!adp || !val) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	switch (len) {
+	case 1:
+		rc = pci_read_config_byte(adp->pdev, off, (u8 *)val);
+		break;
+	case 2:
+		rc = pci_read_config_word(adp->pdev, off, (u16 *)val);
+		break;
+	case 4:
+		rc = pci_read_config_dword(adp->pdev, off, (u32 *)val);
+		break;
+	default:
+		rc = -EINVAL;
+		sts = BC_STS_INV_ARG;
+		dev_err(&adp->pdev->dev, "Invalid len:%d\n", len);
+	};
+
+	if (rc && (sts == BC_STS_SUCCESS))
+		sts = BC_STS_ERROR;
+
+	return sts;
+}
+
+/**
+ * crystalhd_pci_cfg_wr - PCIe config write
+ * @adp: Adapter instance
+ * @off: PCI config space offset.
+ * @len: Size -- Byte, Word & dword.
+ * @val: Value to be written
+ *
+ * Return:
+ *	Status.
+ *
+ * Set value to Link's PCIe config space.
+ */
+BC_STATUS crystalhd_pci_cfg_wr(struct crystalhd_adp *adp, uint32_t off,
+			     uint32_t len, uint32_t val)
+{
+	BC_STATUS sts = BC_STS_SUCCESS;
+	int rc = 0;
+
+	if (!adp || !val) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	switch (len) {
+	case 1:
+		rc = pci_write_config_byte(adp->pdev, off, (u8)val);
+		break;
+	case 2:
+		rc = pci_write_config_word(adp->pdev, off, (u16)val);
+		break;
+	case 4:
+		rc = pci_write_config_dword(adp->pdev, off, val);
+		break;
+	default:
+		rc = -EINVAL;
+		sts = BC_STS_INV_ARG;
+		dev_err(&adp->pdev->dev, "Invalid len:%d\n", len);
+	};
+
+	if (rc && (sts == BC_STS_SUCCESS))
+		sts = BC_STS_ERROR;
+
+	return sts;
+}
+
+/**
+ * bc_kern_dma_alloc - Allocate memory for Dma rings
+ * @adp: Adapter instance
+ * @sz: Size of the memory to allocate.
+ * @phy_addr: Physical address of the memory allocated.
+ *	   Typedef to system's dma_addr_t (u64)
+ *
+ * Return:
+ *  Pointer to allocated memory..
+ *
+ * Wrapper to Linux kernel interface.
+ *
+ */
+void *bc_kern_dma_alloc(struct crystalhd_adp *adp, uint32_t sz,
+			dma_addr_t *phy_addr)
+{
+	void *temp = NULL;
+
+	if (!adp || !sz || !phy_addr) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return temp;
+	}
+
+	temp = pci_alloc_consistent(adp->pdev, sz, phy_addr);
+	if (temp)
+		memset(temp, 0, sz);
+
+	return temp;
+}
+
+/**
+ * bc_kern_dma_free - Release Dma ring memory.
+ * @adp: Adapter instance
+ * @sz: Size of the memory to allocate.
+ * @ka: Kernel virtual address returned during _dio_alloc()
+ * @phy_addr: Physical address of the memory allocated.
+ *	   Typedef to system's dma_addr_t (u64)
+ *
+ * Return:
+ *     none.
+ */
+void bc_kern_dma_free(struct crystalhd_adp *adp, uint32_t sz, void *ka,
+		      dma_addr_t phy_addr)
+{
+	if (!adp || !ka || !sz || !phy_addr) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return;
+	}
+
+	pci_free_consistent(adp->pdev, sz, ka, phy_addr);
+}
+
+/**
+ * crystalhd_create_dioq - Create Generic DIO queue
+ * @adp: Adapter instance
+ * @dioq_hnd: Handle to the dio queue created
+ * @cb	: Optional - Call back To free the element.
+ * @cbctx: Context to pass to callback.
+ *
+ * Return:
+ *  status
+ *
+ * Initialize Generic DIO queue to hold any data. Callback
+ * will be used to free elements while deleting the queue.
+ */
+BC_STATUS crystalhd_create_dioq(struct crystalhd_adp *adp,
+			      crystalhd_dioq_t **dioq_hnd,
+			      crystalhd_data_free_cb cb, void *cbctx)
+{
+	crystalhd_dioq_t *dioq = NULL;
+
+	if (!adp || !dioq_hnd) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dioq = kzalloc(sizeof(*dioq), GFP_KERNEL);
+	if (!dioq)
+		return BC_STS_INSUFF_RES;
+
+	spin_lock_init(&dioq->lock);
+	dioq->sig = BC_LINK_DIOQ_SIG;
+	dioq->head = (crystalhd_elem_t *)&dioq->head;
+	dioq->tail = (crystalhd_elem_t *)&dioq->head;
+	crystalhd_create_event(&dioq->event);
+	dioq->adp = adp;
+	dioq->data_rel_cb = cb;
+	dioq->cb_context = cbctx;
+	*dioq_hnd = dioq;
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_delete_dioq - Delete Generic DIO queue
+ * @adp: Adapter instance
+ * @dioq: DIOQ instance..
+ *
+ * Return:
+ *  None.
+ *
+ * Release Generic DIO queue. This function will remove
+ * all the entries from the Queue and will release data
+ * by calling the call back provided during creation.
+ *
+ */
+void crystalhd_delete_dioq(struct crystalhd_adp *adp, crystalhd_dioq_t *dioq)
+{
+	void *temp;
+
+	if (!dioq || (dioq->sig != BC_LINK_DIOQ_SIG))
+		return;
+
+	do {
+		temp = crystalhd_dioq_fetch(dioq);
+		if (temp && dioq->data_rel_cb)
+			dioq->data_rel_cb(dioq->cb_context, temp);
+	} while (temp);
+	dioq->sig = 0;
+	kfree(dioq);
+}
+
+/**
+ * crystalhd_dioq_add - Add new DIO request element.
+ * @ioq: DIO queue instance
+ * @t: DIO request to be added.
+ * @wake: True - Wake up suspended process.
+ * @tag: Special tag to assign - For search and get.
+ *
+ * Return:
+ *  Status.
+ *
+ * Insert new element to Q tail.
+ */
+BC_STATUS crystalhd_dioq_add(crystalhd_dioq_t *ioq, void *data,
+			   bool wake, uint32_t tag)
+{
+	unsigned long flags = 0;
+	crystalhd_elem_t *tmp;
+
+	if (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG) || !data) {
+		dev_err(chddev(), "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	tmp = crystalhd_alloc_elem(ioq->adp);
+	if (!tmp) {
+		dev_err(chddev(), "%s: No free elements.\n", __func__);
+		return BC_STS_INSUFF_RES;
+	}
+
+	tmp->data = data;
+	tmp->tag = tag;
+	spin_lock_irqsave(&ioq->lock, flags);
+	tmp->flink = (crystalhd_elem_t *)&ioq->head;
+	tmp->blink = ioq->tail;
+	tmp->flink->blink = tmp;
+	tmp->blink->flink = tmp;
+	ioq->count++;
+	spin_unlock_irqrestore(&ioq->lock, flags);
+
+	if (wake)
+		crystalhd_set_event(&ioq->event);
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_dioq_fetch - Fetch element from head.
+ * @ioq: DIO queue instance
+ *
+ * Return:
+ *	data element from the head..
+ *
+ * Remove an element from Queue.
+ */
+void *crystalhd_dioq_fetch(crystalhd_dioq_t *ioq)
+{
+	unsigned long flags = 0;
+	crystalhd_elem_t *tmp;
+	crystalhd_elem_t *ret = NULL;
+	void *data = NULL;
+
+	if (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG)) {
+		dev_err(chddev(), "%s: Invalid arg\n", __func__);
+		return data;
+	}
+
+	spin_lock_irqsave(&ioq->lock, flags);
+	tmp = ioq->head;
+	if (tmp != (crystalhd_elem_t *)&ioq->head) {
+		ret = tmp;
+		tmp->flink->blink = tmp->blink;
+		tmp->blink->flink = tmp->flink;
+		ioq->count--;
+	}
+	spin_unlock_irqrestore(&ioq->lock, flags);
+	if (ret) {
+		data = ret->data;
+		crystalhd_free_elem(ioq->adp, ret);
+	}
+
+	return data;
+}
+/**
+ * crystalhd_dioq_find_and_fetch - Search the tag and Fetch element
+ * @ioq: DIO queue instance
+ * @tag: Tag to search for.
+ *
+ * Return:
+ *	element from the head..
+ *
+ * Search TAG and remove the element.
+ */
+void *crystalhd_dioq_find_and_fetch(crystalhd_dioq_t *ioq, uint32_t tag)
+{
+	unsigned long flags = 0;
+	crystalhd_elem_t *tmp;
+	crystalhd_elem_t *ret = NULL;
+	void *data = NULL;
+
+	if (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG)) {
+		dev_err(chddev(), "%s: Invalid arg\n", __func__);
+		return data;
+	}
+
+	spin_lock_irqsave(&ioq->lock, flags);
+	tmp = ioq->head;
+	while (tmp != (crystalhd_elem_t *)&ioq->head) {
+		if (tmp->tag == tag) {
+			ret = tmp;
+			tmp->flink->blink = tmp->blink;
+			tmp->blink->flink = tmp->flink;
+			ioq->count--;
+			break;
+		}
+		tmp = tmp->flink;
+	}
+	spin_unlock_irqrestore(&ioq->lock, flags);
+
+	if (ret) {
+		data = ret->data;
+		crystalhd_free_elem(ioq->adp, ret);
+	}
+
+	return data;
+}
+
+/**
+ * crystalhd_dioq_fetch_wait - Fetch element from Head.
+ * @ioq: DIO queue instance
+ * @to_secs: Wait timeout in seconds..
+ *
+ * Return:
+ *	element from the head..
+ *
+ * Return element from head if Q is not empty. Wait for new element
+ * if Q is empty for Timeout seconds.
+ */
+void *crystalhd_dioq_fetch_wait(struct crystalhd_hw *hw, uint32_t to_secs, uint32_t *sig_pend)
+{
+	struct device *dev = chddev();
+	unsigned long flags = 0;
+	int rc = 0;
+
+	crystalhd_rx_dma_pkt *r_pkt = NULL;
+	crystalhd_dioq_t *ioq = hw->rx_rdyq;
+	uint32_t picYcomp = 0;
+
+	unsigned long fetchTimeout = jiffies + msecs_to_jiffies(to_secs * 1000);
+
+	if (!ioq || (ioq->sig != BC_LINK_DIOQ_SIG) || !to_secs || !sig_pend) {
+		dev_err(dev, "%s: Invalid arg\n", __func__);
+		return r_pkt;
+	}
+
+	spin_lock_irqsave(&ioq->lock, flags);
+	while (!time_after_eq(jiffies, fetchTimeout)) {
+		if(ioq->count == 0) {
+			spin_unlock_irqrestore(&ioq->lock, flags);
+			crystalhd_wait_on_event(&ioq->event, (ioq->count > 0),
+					250, rc, false);
+		}
+		else
+			spin_unlock_irqrestore(&ioq->lock, flags);
+		if (rc == 0) {
+			// Found a packet. Check if it is a repeated picture or not
+			// Drop the picture if it is a repeated picture
+			// Lock against checks from get status calls
+			if(down_interruptible(&hw->fetch_sem))
+				goto sem_error;
+			r_pkt = crystalhd_dioq_fetch(ioq);
+			// If format change packet, then return with out checking anything
+			if (r_pkt->flags & (COMP_FLAG_PIB_VALID | COMP_FLAG_FMT_CHANGE))
+				goto sem_rel_return;
+			if (hw->adp->pdev->device == BC_PCI_DEVID_LINK) {
+				picYcomp = link_GetRptDropParam(hw, hw->PICHeight, hw->PICWidth, (void *)r_pkt);
+			}
+			else {
+				// For Flea, we don't have the width and height handy since they
+				// come in the PIB in the picture, so this function will also
+				// populate the width and height
+				picYcomp = flea_GetRptDropParam(hw, (void *)r_pkt);
+				// For flea it is the above function that indicated format change
+				if(r_pkt->flags & (COMP_FLAG_PIB_VALID | COMP_FLAG_FMT_CHANGE))
+					goto sem_rel_return;
+			}
+			if(!picYcomp || (picYcomp == hw->LastPicNo) ||
+				(picYcomp == hw->LastTwoPicNo)) {
+				//Discard picture
+				if(picYcomp != 0) {
+					hw->LastTwoPicNo = hw->LastPicNo;
+					hw->LastPicNo = picYcomp;
+				}
+				crystalhd_dioq_add(hw->rx_freeq, r_pkt, false, r_pkt->pkt_tag);
+				r_pkt = NULL;
+				up(&hw->fetch_sem);
+			} else {
+				if(hw->adp->pdev->device == BC_PCI_DEVID_LINK) {
+					if((picYcomp - hw->LastPicNo) > 1) {
+						dev_info(dev, "MISSING %u PICTURES\n", (picYcomp - hw->LastPicNo));
+					}
+				}
+				hw->LastTwoPicNo = hw->LastPicNo;
+				hw->LastPicNo = picYcomp;
+				goto sem_rel_return;
+			}
+		} else if (rc == -EINTR) {
+			*sig_pend = 1;
+			return r_pkt;
+		}
+		spin_lock_irqsave(&ioq->lock, flags);
+	}
+	dev_info(dev, "FETCH TIMEOUT\n");
+	spin_unlock_irqrestore(&ioq->lock, flags);
+	return r_pkt;
+sem_error:
+	return NULL;
+sem_rel_return:
+	up(&hw->fetch_sem);
+	return r_pkt;
+}
+
+/**
+ * crystalhd_map_dio - Map user address for DMA
+ * @adp:	Adapter instance
+ * @ubuff:	User buffer to map.
+ * @ubuff_sz:	User buffer size.
+ * @uv_offset:	UV buffer offset.
+ * @en_422mode: TRUE:422 FALSE:420 Capture mode.
+ * @dir_tx:	TRUE for Tx (To device from host)
+ * @dio_hnd:	Handle to mapped DIO request.
+ *
+ * Return:
+ *	Status.
+ *
+ * This routine maps user address and lock pages for DMA.
+ *
+ */
+BC_STATUS crystalhd_map_dio(struct crystalhd_adp *adp, void *ubuff,
+			  uint32_t ubuff_sz, uint32_t uv_offset,
+			  bool en_422mode, bool dir_tx,
+			  crystalhd_dio_req **dio_hnd)
+{
+	struct device *dev;
+	crystalhd_dio_req	*dio;
+	uint32_t start = 0, end = 0, count = 0;
+	uint32_t spsz = 0;
+	unsigned long uaddr = 0, uv_start = 0;
+	int i = 0, rw = 0, res = 0, nr_pages = 0, skip_fb_sg = 0;
+
+	if (!adp || !ubuff || !ubuff_sz || !dio_hnd) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	dev = &adp->pdev->dev;
+
+	/* Compute pages */
+	uaddr = (unsigned long)ubuff;
+	count = ubuff_sz;
+	end = (uaddr + count + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	start = uaddr >> PAGE_SHIFT;
+	nr_pages = end - start;
+
+	if (!count || ((uaddr + count) < uaddr)) {
+		dev_err(dev, "User addr overflow!!\n");
+		return BC_STS_INV_ARG;
+	}
+
+	dio = crystalhd_alloc_dio(adp);
+	if (!dio) {
+		dev_err(dev, "dio pool empty..\n");
+		return BC_STS_INSUFF_RES;
+	}
+
+	if (dir_tx) {
+		rw = WRITE;
+		dio->direction = DMA_TO_DEVICE;
+	} else {
+		rw = READ;
+		dio->direction = DMA_FROM_DEVICE;
+	}
+
+	if (nr_pages > dio->max_pages) {
+		dev_err(dev, "max_pages(%d) exceeded(%d)!!\n",
+			dio->max_pages, nr_pages);
+		crystalhd_unmap_dio(adp, dio);
+		return BC_STS_INSUFF_RES;
+	}
+
+	if (uv_offset) {
+		uv_start = (uaddr + uv_offset)  >> PAGE_SHIFT;
+		dio->uinfo.uv_sg_ix = uv_start - start;
+		dio->uinfo.uv_sg_off = ((uaddr + uv_offset) & ~PAGE_MASK);
+	}
+
+	dio->fb_size = ubuff_sz & 0x03;
+	if (dio->fb_size) {
+		res = copy_from_user(dio->fb_va,
+				     (void *)(uaddr + count - dio->fb_size),
+				     dio->fb_size);
+		if (res) {
+			dev_err(dev, "failed %d to copy %u fill bytes from %p\n",
+				res, dio->fb_size,
+				(void *)(uaddr + count-dio->fb_size));
+			crystalhd_unmap_dio(adp, dio);
+			return BC_STS_INSUFF_RES;
+		}
+	}
+
+	down_read(&current->mm->mmap_sem);
+	res = get_user_pages(current, current->mm, uaddr, nr_pages, rw == READ,
+			     0, dio->pages, NULL);
+	up_read(&current->mm->mmap_sem);
+
+	/* Save for release..*/
+	dio->sig = crystalhd_dio_locked;
+	if (res < nr_pages) {
+		dev_err(dev, "get pages failed: %d-%d\n", nr_pages, res);
+		dio->page_cnt = res;
+		crystalhd_unmap_dio(adp, dio);
+		return BC_STS_ERROR;
+	}
+
+	dio->page_cnt = nr_pages;
+	/* Get scatter/gather */
+	crystalhd_init_sg(dio->sg, dio->page_cnt);
+	crystalhd_set_sg(&dio->sg[0], dio->pages[0], 0, uaddr & ~PAGE_MASK);
+	if (nr_pages > 1) {
+		dio->sg[0].length = PAGE_SIZE - dio->sg[0].offset;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+#ifdef CONFIG_X86_64
+		dio->sg[0].dma_length = dio->sg[0].length;
+#endif
+#endif
+		count -= dio->sg[0].length;
+		for (i = 1; i < nr_pages; i++) {
+			if (count < 4) {
+				spsz = count;
+				skip_fb_sg = 1;
+			} else {
+				spsz = (count < PAGE_SIZE) ?
+					(count & ~0x03) : PAGE_SIZE;
+			}
+			crystalhd_set_sg(&dio->sg[i], dio->pages[i], spsz, 0);
+			count -= spsz;
+		}
+	} else {
+		if (count < 4) {
+			dio->sg[0].length = count;
+			skip_fb_sg = 1;
+		} else {
+			dio->sg[0].length = count - dio->fb_size;
+		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 23)
+#ifdef CONFIG_X86_64
+		dio->sg[0].dma_length = dio->sg[0].length;
+#endif
+#endif
+	}
+	dio->sg_cnt = pci_map_sg(adp->pdev, dio->sg,
+				 dio->page_cnt, dio->direction);
+	if (dio->sg_cnt <= 0) {
+		dev_err(dev, "sg map %d-%d\n", dio->sg_cnt, dio->page_cnt);
+		crystalhd_unmap_dio(adp, dio);
+		return BC_STS_ERROR;
+	}
+	if (dio->sg_cnt && skip_fb_sg)
+		dio->sg_cnt -= 1;
+	dio->sig = crystalhd_dio_sg_mapped;
+	/* Fill in User info.. */
+	dio->uinfo.xfr_len   = ubuff_sz;
+	dio->uinfo.xfr_buff  = ubuff;
+	dio->uinfo.uv_offset = uv_offset;
+	dio->uinfo.b422mode  = en_422mode;
+	dio->uinfo.dir_tx    = dir_tx;
+
+	*dio_hnd = dio;
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_unmap_sgl - Release mapped resources
+ * @adp: Adapter instance
+ * @dio: DIO request instance
+ *
+ * Return:
+ *	Status.
+ *
+ * This routine is to unmap the user buffer pages.
+ */
+BC_STATUS crystalhd_unmap_dio(struct crystalhd_adp *adp, crystalhd_dio_req *dio)
+{
+	struct page *page = NULL;
+	int j = 0;
+
+	if (!adp || !dio) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return BC_STS_INV_ARG;
+	}
+
+	if ((dio->page_cnt > 0) && (dio->sig != crystalhd_dio_inv)) {
+		for (j = 0; j < dio->page_cnt; j++) {
+			page = dio->pages[j];
+			if (page) {
+				if (!PageReserved(page) &&
+				    (dio->direction == DMA_FROM_DEVICE))
+					SetPageDirty(page);
+				page_cache_release(page);
+			}
+		}
+	}
+	if (dio->sig == crystalhd_dio_sg_mapped)
+		pci_unmap_sg(adp->pdev, dio->sg, dio->page_cnt, dio->direction);
+
+	crystalhd_free_dio(adp, dio);
+
+	return BC_STS_SUCCESS;
+}
+
+/**
+ * crystalhd_create_dio_pool - Allocate mem pool for DIO management.
+ * @adp: Adapter instance
+ * @max_pages: Max pages for size calculation.
+ *
+ * Return:
+ *	system error.
+ *
+ * This routine creates a memory pool to hold dio context for
+ * for HW Direct IO operation.
+ */
+int crystalhd_create_dio_pool(struct crystalhd_adp *adp, uint32_t max_pages)
+{
+	struct device *dev;
+	uint32_t asz = 0, i = 0;
+	uint8_t	*temp;
+	crystalhd_dio_req *dio;
+
+	if (!adp || !max_pages) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return -EINVAL;
+	}
+
+	dev = &adp->pdev->dev;
+
+	/* Get dma memory for fill byte handling..*/
+	adp->fill_byte_pool = pci_pool_create("crystalhd_fbyte",
+					      adp->pdev, 8, 8, 0);
+	if (!adp->fill_byte_pool) {
+		dev_err(dev, "failed to create fill byte pool\n");
+		return -ENOMEM;
+	}
+
+	/* Get the max size from user based on 420/422 modes */
+	asz =  (sizeof(*dio->pages) * max_pages) +
+	       (sizeof(*dio->sg) * max_pages) + sizeof(*dio);
+
+	dev_dbg(dev, "Initializing Dio pool %d %d %x %p\n",
+		BC_LINK_SG_POOL_SZ, max_pages, asz, adp->fill_byte_pool);
+
+	for (i = 0; i < BC_LINK_SG_POOL_SZ; i++) {
+		temp = (uint8_t *)kzalloc(asz, GFP_KERNEL);
+		if ((temp) == NULL) {
+			dev_err(dev, "Failed to alloc %d mem\n", asz);
+			return -ENOMEM;
+		}
+
+		dio = (crystalhd_dio_req *)temp;
+		temp += sizeof(*dio);
+		dio->pages = (struct page **)temp;
+		temp += (sizeof(*dio->pages) * max_pages);
+		dio->sg = (struct scatterlist *)temp;
+		dio->max_pages = max_pages;
+		dio->fb_va = pci_pool_alloc(adp->fill_byte_pool, GFP_KERNEL,
+					    &dio->fb_pa);
+		if (!dio->fb_va) {
+			dev_err(dev, "fill byte alloc failed.\n");
+			return -ENOMEM;
+		}
+
+		crystalhd_free_dio(adp, dio);
+	}
+
+	return 0;
+}
+
+/**
+ * crystalhd_destroy_dio_pool - Release DIO mem pool.
+ * @adp: Adapter instance
+ *
+ * Return:
+ *	none.
+ *
+ * This routine releases dio memory pool during close.
+ */
+void crystalhd_destroy_dio_pool(struct crystalhd_adp *adp)
+{
+	crystalhd_dio_req *dio;
+	int count = 0;
+
+	if (!adp) {
+		printk(KERN_ERR "%s: Invalid arg\n", __func__);
+		return;
+	}
+
+	do {
+		dio = crystalhd_alloc_dio(adp);
+		if (dio) {
+			if (dio->fb_va)
+				pci_pool_free(adp->fill_byte_pool,
+					      dio->fb_va, dio->fb_pa);
+			count++;
+			kfree(dio);
+		}
+	} while (dio);
+
+	if (adp->fill_byte_pool) {
+		pci_pool_destroy(adp->fill_byte_pool);
+		adp->fill_byte_pool = NULL;
+	}
+
+	dev_dbg(&adp->pdev->dev, "Released dio pool %d\n", count);
+}
+
+/**
+ * crystalhd_create_elem_pool - List element pool creation.
+ * @adp: Adapter instance
+ * @pool_size: Number of elements in the pool.
+ *
+ * Return:
+ *	0 - success, <0 error
+ *
+ * Create general purpose list element pool to hold pending,
+ * and active requests.
+ */
+int crystalhd_create_elem_pool(struct crystalhd_adp *adp,
+		uint32_t pool_size)
+{
+	uint32_t i;
+	crystalhd_elem_t *temp;
+
+	if (!adp || !pool_size)
+		return -EINVAL;
+
+	for (i = 0; i < pool_size; i++) {
+		temp = kzalloc(sizeof(*temp), GFP_KERNEL);
+		if (!temp) {
+			dev_err(&adp->pdev->dev, "kzalloc failed\n");
+			return -ENOMEM;
+		}
+		crystalhd_free_elem(adp, temp);
+	}
+	dev_dbg(&adp->pdev->dev, "allocated %d elem\n", pool_size);
+	return 0;
+}
+
+/**
+ * crystalhd_delete_elem_pool - List element pool deletion.
+ * @adp: Adapter instance
+ *
+ * Return:
+ *	none
+ *
+ * Delete general purpose list element pool.
+ */
+void crystalhd_delete_elem_pool(struct crystalhd_adp *adp)
+{
+	crystalhd_elem_t *temp;
+	int dbg_cnt = 0;
+
+	if (!adp)
+		return;
+
+	do {
+		temp = crystalhd_alloc_elem(adp);
+		if (temp) {
+			kfree(temp);
+			dbg_cnt++;
+		}
+	} while (temp);
+
+	dev_dbg(&adp->pdev->dev, "released %d elem\n", dbg_cnt);
+}
+
+/*================ Debug support routines.. ================================*/
+void crystalhd_show_buffer(uint32_t off, uint8_t *buff, uint32_t dwcount)
+{
+	struct device *dev = chddev();
+	uint32_t i, k = 1;
+
+	for (i = 0; i < dwcount; i++) {
+		if (k == 1)
+			dev_dbg(dev, "0x%08X : ", off);
+
+		dev_dbg(dev, " 0x%08X ", *((uint32_t *)buff));
+
+		buff += sizeof(uint32_t);
+		off  += sizeof(uint32_t);
+		k++;
+		if ((i == dwcount - 1) || (k > 4)) {
+			dev_dbg(dev, "\n");
+			k = 1;
+		}
+	}
+}
diff --git a/drivers/staging/chd/crystalhd_misc.h b/drivers/staging/chd/crystalhd_misc.h
new file mode 100644
index 0000000..86aa6fd
--- /dev/null
+++ b/drivers/staging/chd/crystalhd_misc.h
@@ -0,0 +1,182 @@
+/***************************************************************************
+ * Copyright (c) 2005-2009, Broadcom Corporation.
+ *
+ *  Name: crystalhd_misc . h
+ *
+ *  Description:
+ *		BCM70012 Linux driver general purpose routines.
+ *		Includes reg/mem read and write routines.
+ *
+ *  HISTORY:
+ *
+ **********************************************************************
+ * This file is part of the crystalhd device driver.
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This driver is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this driver.  If not, see <http://www.gnu.org/licenses/>.
+ **********************************************************************/
+
+#ifndef _CRYSTALHD_MISC_H_
+#define _CRYSTALHD_MISC_H_
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/ioctl.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include "bc_dts_glob_lnx.h"
+#include "crystalhd_hw.h"
+
+// forward declare
+struct crystalhd_hw;
+
+/* Global element pool for all Queue management.
+ * TX: Active = BC_TX_LIST_CNT, Free = BC_TX_LIST_CNT.
+ * RX: Free = BC_RX_LIST_CNT, Active = 2
+ * FW-CMD: 4
+ */
+#define	BC_LINK_ELEM_POOL_SZ	((BC_TX_LIST_CNT * 2) + BC_RX_LIST_CNT + 2 + 4)
+
+/* Driver's IODATA pool count */
+#define	CHD_IODATA_POOL_SZ    (BC_IOCTL_DATA_POOL_SIZE * BC_LINK_MAX_OPENS)
+
+/* Scatter Gather memory pool size for Tx and Rx */
+#define BC_LINK_SG_POOL_SZ    (BC_TX_LIST_CNT + BC_RX_LIST_CNT)
+
+enum _crystalhd_dio_sig {
+	crystalhd_dio_inv = 0,
+	crystalhd_dio_locked,
+	crystalhd_dio_sg_mapped,
+};
+
+struct crystalhd_dio_user_info {
+	void			*xfr_buff;
+	uint32_t		xfr_len;
+	uint32_t		uv_offset;
+	bool			dir_tx;
+
+	uint32_t		uv_sg_ix;
+	uint32_t		uv_sg_off;
+	int			comp_sts;
+	int			ev_sts;
+	uint32_t		y_done_sz;
+	uint32_t		uv_done_sz;
+	uint32_t		comp_flags;
+	bool			b422mode;
+};
+
+typedef struct _crystalhd_dio_req {
+	uint32_t						sig;
+	uint32_t						max_pages;
+	struct page						**pages;
+	struct scatterlist				*sg;
+	int								sg_cnt;
+	int								page_cnt;
+	int								direction;
+	struct crystalhd_dio_user_info	uinfo;
+	void							*fb_va;
+	uint32_t						fb_size;
+	dma_addr_t						fb_pa;
+	void							*pib_va; // pointer to temporary buffer to extract metadata
+	struct _crystalhd_dio_req		*next;
+} crystalhd_dio_req;
+
+#define BC_LINK_DIOQ_SIG	(0x09223280)
+
+typedef struct _crystalhd_elem_s {
+	struct _crystalhd_elem_s	*flink;
+	struct _crystalhd_elem_s	*blink;
+	void				*data;
+	uint32_t			tag;
+} crystalhd_elem_t;
+
+typedef void (*crystalhd_data_free_cb)(void *context, void *data);
+
+typedef struct _crystalhd_dioq_s {
+	uint32_t		sig;
+	struct crystalhd_adp	*adp;
+	crystalhd_elem_t	*head;
+	crystalhd_elem_t	*tail;
+	uint32_t		count;
+	spinlock_t		lock;
+	wait_queue_head_t	event;
+	crystalhd_data_free_cb	data_rel_cb;
+	void			*cb_context;
+} crystalhd_dioq_t;
+
+typedef void (*hw_comp_callback)(crystalhd_dio_req *,
+				 wait_queue_head_t *event, BC_STATUS sts);
+
+/*========== PCIe Config access routines.================*/
+BC_STATUS crystalhd_pci_cfg_rd(struct crystalhd_adp *, uint32_t, uint32_t, uint32_t *);
+BC_STATUS crystalhd_pci_cfg_wr(struct crystalhd_adp *, uint32_t, uint32_t, uint32_t);
+
+/*========= Linux Kernel Interface routines. ======================= */
+void *bc_kern_dma_alloc(struct crystalhd_adp *, uint32_t, dma_addr_t *);
+void bc_kern_dma_free(struct crystalhd_adp *, uint32_t,
+		      void *, dma_addr_t);
+#define crystalhd_create_event(_ev)	init_waitqueue_head(_ev)
+#define crystalhd_set_event(_ev)		wake_up_interruptible(_ev)
+#define crystalhd_wait_on_event(ev, condition, timeout, ret, nosig)	\
+do {									\
+	DECLARE_WAITQUEUE(entry, current);				\
+	unsigned long end = jiffies + msecs_to_jiffies(timeout);		\
+		ret = 0;						\
+	add_wait_queue(ev, &entry);					\
+	for (;;) {									\
+		set_current_state(TASK_INTERRUPTIBLE);		\
+		if (condition) {					\
+			break;						\
+		}							\
+		if (time_after_eq(jiffies, end)) {			\
+			ret = -EBUSY;					\
+			break;						\
+		}							\
+		schedule_timeout((HZ / 100 > 1) ? HZ / 100 : 1);	\
+		if (!nosig && signal_pending(current)) {		\
+			ret = -EINTR;					\
+			break;						\
+		}							\
+	}								\
+	set_current_state(TASK_RUNNING);				\
+	remove_wait_queue(ev, &entry);					\
+} while (0)
+
+/*================ Direct IO mapping routines ==================*/
+extern int crystalhd_create_dio_pool(struct crystalhd_adp *, uint32_t);
+extern void crystalhd_destroy_dio_pool(struct crystalhd_adp *);
+extern BC_STATUS crystalhd_map_dio(struct crystalhd_adp *, void *, uint32_t,
+				   uint32_t, bool, bool, crystalhd_dio_req**);
+
+extern BC_STATUS crystalhd_unmap_dio(struct crystalhd_adp *, crystalhd_dio_req*);
+#define crystalhd_get_sgle_paddr(_dio, _ix) (cpu_to_le64(sg_dma_address(&_dio->sg[_ix])))
+#define crystalhd_get_sgle_len(_dio, _ix) (cpu_to_le32(sg_dma_len(&_dio->sg[_ix])))
+
+/*================ General Purpose Queues ==================*/
+extern BC_STATUS crystalhd_create_dioq(struct crystalhd_adp *, crystalhd_dioq_t **, crystalhd_data_free_cb , void *);
+extern void crystalhd_delete_dioq(struct crystalhd_adp *, crystalhd_dioq_t *);
+extern BC_STATUS crystalhd_dioq_add(crystalhd_dioq_t *ioq, void *data, bool wake, uint32_t tag);
+extern void *crystalhd_dioq_fetch(crystalhd_dioq_t *ioq);
+extern void *crystalhd_dioq_find_and_fetch(crystalhd_dioq_t *ioq, uint32_t tag);
+extern void *crystalhd_dioq_fetch_wait(struct crystalhd_hw *hw, uint32_t to_secs, uint32_t *sig_pend);
+
+#define crystalhd_dioq_count(_ioq)	((_ioq) ? _ioq->count : 0)
+
+extern int crystalhd_create_elem_pool(struct crystalhd_adp *, uint32_t);
+extern void crystalhd_delete_elem_pool(struct crystalhd_adp *);
+
+/*================ Debug routines/macros .. ================================*/
+extern void crystalhd_show_buffer(uint32_t off, uint8_t *buff, uint32_t dwcount);
+
+#endif
